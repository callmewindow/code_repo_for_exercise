# 项目类问题

## 中科院

### 旧集成平台运维

#### 1. 升级6年前的tomcat项目到新版本

确认目前的项目版本和要升级到的版本，检查新版本中的变化，判断是否需要进行大规模改动（针对jdk版本进行调研和确认）
创建备份，确保在升级过程中可以回滚到原来的版本。（考虑到保密性选择了本地备份）
更新项目所用到的第三方库和依赖，确保新版本的兼容性。
对项目的代码进行修改和升级，遵循新版本的规范和标准。
进行测试和调试，确保升级后项目的稳定性和可靠性。

#### 2. 为项目接入Vue与单点登录能力

引入Vue框架和相关依赖，配置前端开发环境（通过cdn进行的引用）
在项目中引入单点登录系统，如CAS等，并进行相关配置。
根据需求开发前端Vue组件和页面，与后台接口进行对接。（利用elementui进行了一些功能的处理）
完成前后端联调和测试，确保系统的可用性和安全性。

#### 3. 基于Java Servlet实现后台

设计后台接口和数据结构，考虑前后端数据传输的格式和安全性。（每次都会尝试和证书进行匹配验证，确保安全性）
根据需求进行Java Servlet代码的编写和测试，保证后台的可用性和稳定性。
集成数据库、缓存等相关技术，确保后台的数据安全性和性能。（这里没有涉及到，只有一些简单的登录、注销、信息获取）
完成与前端的对接和测试，保证前后端的数据传输和业务逻辑的一致性。（利用ajax进行请求的发送和获取）

#### 4. 单点登录的问题

在进行单点登录接入的过程中，可能会遇到一些技术上的难点或者困难，例如统一认证系统与业务系统的数据传输加密、登录凭证的安全存储、跨域问题等。

在编写后端接口时，需要注意安全性，确保数据传输过程中的加密处理，验证token的合法性，以及避免敏感信息的泄露等方面。

在前端实现中，需要考虑到用户打开多个标签页的情况，避免一个标签页登录后，其他标签页仍然需要再次登录，可以通过token的存储和使用方式来避免这种情况。

在单点登录的实现中，需要考虑到单点注销的情况，即当用户从一个系统注销时，如何使其他系统同时注销。可以通过设置单点注销接口，并在业务系统中调用该接口实现单点注销功能。

单点登录对于系统的安全性和用户体验有一些优缺点。优点包括可以提高用户的登录便利性和系统的安全性，缺点则包括可能带来单点故障问题、单点登录中心的安全问题等。因此，在进行单点登录的实现时，需要权衡利弊，结合具体情况做出合理的选择。

### 雷达监控系统

#### 1. 前端架构设计和搭建

确认项目需求和技术选型，选择适合的前端框架和组件。（为了开发效率，选择element）
设计前端架构和页面结构，考虑页面交互和数据流的管理。（基于之前的经验进行，划分为api、component、vuex、router等部分）
根据需求进行前端代码的编写和测试，保证前端的可用性和用户体验。（指定代码规范，虽然是学长但一视同仁）
集成第三方库和组件，优化前端性能和用户体验。（提前引入qs、echarts等库，并且提前编写使用示例）
完成前后端的联调和测试，保证前后端的数据传输和业务逻辑的一致性。（集成api，封装axios，便于后续使用）

#### 2. 复杂图形的绘制（echarts 功能了解）

引入Echarts库，可以从官网下载或使用CDN方式引入。
准备数据源，Echarts需要从数据源中读取数据并进行可视化展示。数据源可以是本地数据，也可以是通过Ajax请求获取的远程数据。
创建一个容器，用于放置Echarts图表。
配置Echarts图表，包括图表类型、数据源、样式、交互等设置。
渲染Echarts图表，将图表渲染到容器中显示出来。

#### 3. 众多配置项的实现（利用字典进行封装，遍历值来实现，这一方法在后续项目中也有应用）

为了管理近百个配置项，我选择了使用前端框架Vue.js开发一个动态生成表单的组件，以便快速实现可配置化。
在这个组件中，我们可以通过一个配置项来定义需要展示哪些表单元素，以及这些元素的类型、校验规则、初始值等属性。
组件会根据这个配置项生成对应的表单元素，并提供一些常见的表单校验规则，比如必填、邮箱格式、手机号格式等。
这样一来，开发人员就可以快速地构建出一个配置页面，同时也避免了重复的代码编写。
后来离开项目组之后，后续同学也继续基于我的代码进行了更新，说很好用

### 成像快视

成像快视项目是现阶段最能带给我成就感的项目，不只是因为他是一个百亿级的国家级项目，而是在这个项目的开发过程中我对自己的软件研发能力有了新一阶段的提高。

在该项目中我通过学习优秀项目的架构设计，将模块化、组件化的思想应用到python客户端中，在开发过程中频繁使用工厂模式来复用代码，并利用数据链模式进行数据处理的过程的管理，同时利用pylint、cspell、日志库等内容来进行项目规范的维护。

目前已实现了基于文件夹的任务数据监测、对五个子系统数十个配置项管理的大型配置管理系统、借助rabbitMQ实现任务检测与任务处理的进程并发，对大数据进行切片编号的并行处理，以及基于matplotlib的图示绘画等工作。
该项目不只是对我架构设计和带队能力的一次实地考察，也让我对更多的技术以及设计模式的掌握有了一个深入了解的机会，并且后续该项目将作为航空领域的重点项目持续运维，我也十分有信心。

#### 1. 架构设计（应用层、服务层、实体层的设计，模块化封装时的思想）

为了更好地维护和扩展系统，我采用了分层架构的方式来设计后台系统。
我们将整个系统划分为表现层、服务层、数据访问层三个层次，每个层次都有其独立的职责和功能。
表现层主要负责接收用户的请求，展示数据给用户，而服务层则负责处理业务逻辑，数据访问层则负责与数据源进行交互。通过这种分层的方式，我们可以更好地实现系统的解耦和模块化，提高系统的可维护性和可扩展性。
对表现层又进一步划分了组件、部件、核心界面的结构
在服务层引入了工具类，封装有关代码
数据访问层则是提前对数据模型进行定义，规范结构

#### 2. python 的困难规范（了解到实际为什么不用 python）

制定代码规范：可以通过编写代码规范文档的方式，规定代码中的命名、注释、缩进等规范。
使用代码检查工具：可以使用一些常用的代码检查工具，如flake8、pylint等，通过工具对代码进行检查，确保代码符合规范。
使用IDE插件：常见的IDE如PyCharm、VSCode等都有对Python代码规范的检查和修正插件，可以帮助开发者规范代码格式。

#### 3. 在客户端应用中尝试分离式开发（前端思想的应用）

将UI界面与业务逻辑分离：在设计客户端界面时，尽可能将UI与业务逻辑分离，使用类似MVVM的框架，例如Qt中的QML，来实现前端UI的开发和逻辑的编写。这样做可以让前端开发者专注于UI的设计和布局，而不需要了解太多后端的业务逻辑，后端开发者则可以专注于业务逻辑的实现。

利用消息队列实现前后端交互：将前端和后端之间的交互通过消息队列来实现，前端向消息队列发送请求，后端通过监听消息队列来接收请求并处理。这样做可以将前后端分离得更彻底，避免了前端和后端直接交互时的耦合性。

定义好消息格式和协议：为了让前后端之间的通信更加顺畅，需要在客户端和服务端之间定义好消息的格式和通信协议，例如使用JSON格式来传输数据、使用自定义协议来进行消息交换等。

使用框架来提高开发效率：为了提高开发效率，可以选择使用类似Electron或者Qt等框架来实现客户端开发。这些框架可以提供一些常用的UI组件和开发工具，让前端开发者能够更加专注于业务逻辑的实现。

使用自动化工具进行构建和部署：为了让客户端项目的构建和部署更加方便，可以使用自动化工具进行构建和部署。例如使用Jenkins来实现自动化构建和部署、使用Docker来实现打包和部署等，从而提高开发效率和项目的可维护性。

#### 4. 配置系统研发

在成像快视系统中我使用了之前开发雷达监控系统的经验，由于系统需要对不同阶段的数十个配置项进行管理，为了便于用于操作以及我们的后续延伸，经过调研后选择了可读性较高的ini配置文件来进行配置项的保存，便于科研人员的使用。

首先为了隔离不同阶段的相同配置项，通过声明多个配置文件的方式进行了解决，并通过实现一个配置控制类，他提供了基于配置文件名进行不同配置文件切换的功能，并可以在内部对不同子系统的配置项或者所有配置项进行获取和更新。

为了能够在界面中让用户便捷操作这数十个配置项，我们采取了对象封装的策略，即通过工厂模式首先设计好每个配置项的有关属性，例如展示的中英文名称、计量单位、他所属的子系统；进而将实际需要配置的配置项信息保存在数据库中，这样我们便可以实现一个动态的若干配置项的搭建。

在实际渲染时我们也是声明了一个通用的配置项组件，这样只需要基于用户当前希望访问的类型，去数据库中获取有关配置项的信息，通过配置项对象以及配置项组件的相结合，便可通过一个配置项数组再结合pyside的行列布局，实现快速的配置界面搭建。

并且为了应对不同窗口的配置展示需求，还提供了针对特定子系统配置项的获取的组件，其他窗口只需调用后声明配置文件名以及需要的子系统名称便可快速获取对应的配置文件，极大程度减轻了开发负担。

当然为了减少和数据库的交互，我们也设计了缓存机制，如果用户实时新增了配置项，则需要手动刷新来实现数据库的再次获取和界面的更新。

#### 5. 大数据切片处理

需要处理大量的数据，因此采用了数据切片和多线程并行处理的设计模式来提高数据处理的效率。
根本任务便是在数据上传过程中对数据进行实时获取和处理，最终利用matplotlib基于数据进行相应的绘图

具体处理方式如下：

1. 首先为了提高访问的便捷性，我们采用了网络映射的技术将对应的文件夹映射在了本地，来便于访问。这样当大量的数据保存在数据文件中时，我们便可以直接通过本地文件读取的方式进行数据的访问。

2. 为了便于后续的切片操作，我们使用了类似stream的文件流的概念，即通过保存文件句柄，基于句柄来进行数据的读取和文件偏移量的记录，这样当我们需要获取中间或者结尾的一部分数据时便可以通过提前记录文件偏移量和移动的策略完成对这个文件流中任意位置数据的读取。

3. 为了优化体验，我们在数据量较少时，一般出现在数据刚开始上传，我们会直接串行对这小部分数据进行处理和计算，尽快完成绘图，实现一个快速的首屏加载；当数据量较大时，我们便会根据设定的数值来进行数据的切片，例如当文件中剩余10000单位的数据，切片单位设置为1000，此时我们的原始数据控制类会将剩余的10000个数据拆分为10包并编号记录索引，同时根据当前的文件偏移位置计算出每包数据的起始和结束位置；进而将拆分的数据包信息交给线程池进行处理，处理时由于目前还是本地测试阶段，所以每次只使用四个线程进行并发，当四个数据包处理结束再去处理下一部分数据（后续使用高性能设备可以进一步提高并发量）；通过这种数据包的编号以及偏移量不重叠的保证，便可以避免死锁问题，在处理完毕后也按照编号进行数据的合并。

比较类似于web前端对大文件切片后分批上传给服务端，再由服务端合并的过程，这里我们相当于通过多个控制类实现了这一能力。

同时，在数据处理完成后，我还编写了一个FTP的工具类，会在处理结果处理之后，对数据进行打包，格式转化和FTP备份，以确保数据的可靠性和安全性。

#### 6. 基于RabbitMQ并行检测任务与处理

1. 连接到RabbitMQ服务：使用pika包中提供的Connection和Channel类，可以连接到RabbitMQ服务，并创建或消费消息队列。在这个步骤中，我们需要考虑的是如何设置RabbitMQ的连接参数、如何声明队列等等。

2. 定义消息处理函数：为了处理消费者从消息队列中取出的消息，我们需要定义一个消息处理函数来处理这些消息。这个函数需要根据业务逻辑进行处理，并将处理结果发送到其他队列或者交换机中。

3. 设置并发消费：为了实现并发消费，我们需要将消费者进程分配到多个进程中，并且让它们监听同一个队列。为此，我使用了Python的multiprocessing包来实现多进程，并且在每个进程中创建一个独立的Channel来处理消息。为了避免不必要的竞争，每个进程只会处理消息队列中的部分消息，这可以通过设置消费者的prefetch_count属性来实现。

4. 错误处理和日志记录：在使用RabbitMQ时，我们需要考虑如何处理可能出现的错误，并记录日志以便排查问题。这可以通过try...except语句和Python的logging模块来实现。

##### 在web系统中如何利用rabbitmq

假设有两个前端实例 A 和 B，同时对同一条数据进行修改，如果直接使用后端服务处理这两个请求，可能会导致数据的不一致性。

这时可以使用rabbitmq作为中间件来实现消息队列，并解决并发问题，具体方案如下：

1. 前端发送请求时，将消息发送到rabbitmq中，消息中包含要修改的数据的ID和修改的内容。

2. rabbitmq接收到消息后，将消息存储到队列中，等待后续处理。

3. 后端服务作为消息的消费者，从rabbitmq的队列中获取消息，并对要修改的数据进行加锁操作。

4. 后端服务完成对数据的加锁操作后，再进行数据的修改，并将修改后的数据发送给所有订阅了该数据变更的前端实例。

5. 前端实例接收到修改后的数据后，更新界面的显示，同时解除对数据的加锁。

通过这种方式，可以避免多个前端实例同时修改同一条数据的情况，确保数据的一致性和可靠性。同时，rabbitmq的消息队列机制可以保证消息的可靠传输，即使在消息消费过程中出现故障，也可以确保消息不会丢失，从而提高了系统的健壮性和可靠性。

尝试将所有前端请求都存储在RabbitMQ队列中，让后端服务去消费队列中的请求并进行处理，会发生什么
避免因大量并发请求导致服务崩溃或响应缓慢等问题。

1. 但是这种方式也存在一些缺点，主要有以下几点：

2. 可能增加系统复杂性：将请求存储在队列中需要引入RabbitMQ等中间件，并需要编写消费端代码进行处理。这可能会增加系统的复杂性和开发难度。

3. 增加系统延迟：将请求存储在队列中会导致请求的处理延迟，因为后端服务需要等待请求从队列中取出并进行处理。这可能会增加系统的响应延迟。

队列可能成为瓶颈：将请求存储在队列中可能会导致队列成为系统的瓶颈，因为当队列中的请求过多时，可能会导致队列的处理速度变慢，甚至导致队列堆积。

###### 针对请求过多时的堵塞问题，可以考虑采用以下方案

1. 增加消费者数量：增加消费者数量可以提高消息处理的并发能力，从而缓解消息堆积的情况。但是需要注意，增加消费者数量可能会增加系统负载，需要根据实际情况进行调整。

2. 优化消费者代码：消费者代码需要做到高效且非阻塞，可以采用异步处理消息的方式，避免在消费消息时出现阻塞情况。同时，消费者代码也需要考虑异常情况的处理，避免因为异常情况导致消息无法正常消费。

3. 使用消息确认机制：在消费者消费消息之后，可以发送确认消息给 RabbitMQ，告知 RabbitMQ 已经成功处理了该消息，这样 RabbitMQ 就会将该消息从队列中移除。如果消费者在一定时间内未发送确认消息，RabbitMQ 将会将该消息重新发送给其他消费者处理。这样可以确保消息被及时处理，并避免消息丢失。

4. 消息预取：消息预取是 RabbitMQ 中的一个优化参数，用于指定消费者从队列中预取的消息数量。在消费者处理消息的同时，RabbitMQ 会预取一定数量的消息，当消费者处理完当前消息后，可以直接处理预取的下一条消息，从而提高消息处理的效率。

#### 7. 大型Python客户端项目的管理规范

由于项目的专有名词较多，一些概念也没有接触过，首先我在共享材料库中会针对一些专用词进行介绍，针对客户端搭建和数据处理等模块分别进行有关技术的说明，便于大家了解。
并且有专门的文档记录python开发的规范，并会定期更新。

日志规范：在项目中添加日志记录，使用标准日志记录框架（例如logging模块），并根据不同的日志级别（例如debug、info、warning、error、critical）进行记录。对于异常情况和重要事件，应记录更详细的信息以帮助调试和问题解决。同时，建议使用统一的日志格式和命名规则，以便更好地管理和检索日志信息。
按照日志级别分文件存放，为避免日志文件过大定期自动更新

代码规范：为了确保代码的可读性和可维护性，建议遵循PEP 8规范（Python编码风格指南）。使用代码质量分析工具（例如Pylint）来检查代码的规范性，并在版本控制系统中使用代码审查工具（例如GitHub pull request）来确保代码的质量和一致性。
我会经常进行代码审查，并汇总大家过程中存在的问题
使用同样的格式化插件来帮助大家的格式一致，对比之后选择yapf。
yapf是一个Google开源的Python代码格式化库，具有以下特点：
代码简洁易用，只需要一行命令即可格式化代码
支持几乎所有的PEP8风格规范，并可以自定义部分规则
可以处理大型代码库，并且格式化速度快
可以与许多编辑器和IDE集成
一个易于使用、可扩展和高度可定制的库，可以处理大多数情况，比较烦autopep8将import自动前提的功能。

统一：
在项目中使用统一的代码结构、文件命名和目录结构，以便更好地管理和维护项目。同时，应确保所有团队成员都遵循这些规则，并定期进行代码审查和更新。
利用模块的__init__文件进行内容的说明

模块划分：使用模块化的设计方法，将代码划分为多个模块和子模块，并根据功能进行组织和管理。
同时，应将公共代码和库放在单独的模块中，并在不同的模块之间使用明确的接口进行通信。
对同一个对象设立他的基础model，controller，service等内容，将一个模块下的功能进行封装。
利用架构图的形式展示架构情况，便于开发人员理解

注释：
为了提高代码的可读性和可维护性，在代码中添加适当的注释。
考虑到项目后续会运维很久，注释很重要，例如文件开头会介绍当前文件的名称含义、具体功能、此前的开发作者等等；在函数内部的一些重要操作或者特殊变量也会注释进行强调。
为了提高注释的可读性，还引入了vscode插件进行美化，会根据注释后的字符为注释设立不同的颜色和样式，例如!是警告，todo是下一步工作，?是疑问
并使用标准的文档生成工具（例如Sphinx）生成文档，后续会考虑同时，应确保注释和文档的准确性和实用性，并将其视为代码本身的一部分。

## alight

### 1. 组件库管理

基于vue2+ts+scss+webpack优化的组件库，参考elementui进行了有关功能的实现。

组件库项目同样是我很有成就感的项目一，可以说支撑起了深光科技的前端页面，但是由于自己不是核心开发人员，因此没有立刻介绍，但是在运维管理的过程中我也对组件库开发的技术有了深入了解。
对于组件库涉及的技术可以说是我目前学习的启蒙，例如ts、scss以及针对webpack的优化策略。
在该项目中我主要学习到了基于vue2的组件库的搭建策略，包括混入的使用、基于ts类型的组件管理、vue2框架下组件、全局对象以及指令的开发方式。
也是在该项目中我也是了解到了复杂前端项目的例子，虽然对于当时的我来说比较复杂，难以对每一部分进行理解透彻，但是目前反过来看，通过对前端技术的深入以及架构、设计模式的学习，也发现复杂项目其实也没有什么可怕的，也坚定了我后续希望能深入架构的想法。

#### 组件库结构

packages：
    组件源代码，自定义指令源代码，自定义全局对象源代码
    theme:
    保存组件的样式定义文件，基于scss

public：引入一些alight自己的能力，min.js

src：

directives：自定义的指令源代码

mixins：包含了组件库的混入源代码，负责对一些重复属性和重复方法进行基于Vue对象的定义，可以被组件库使用，来混入属性或方法。mixins 目录通常存放一些可以在多个组件中复用的功能代码，比如计算属性、方法等等。这些 mixin 可以通过 mixins 选项引入到需要使用的组件中，从而避免了在多个组件中重复书写相同的代码，提高了代码的复用性和可维护性。

utils：声明了若干辅助函数，包括但不限于从element-ui中学习的一些pop遮盖层的代码，获取鼠标位置，扁平数组转树的辅助函数

types：对各个组件或指令或全局对象进行结构定义和声明

jsconfig.json：配置文件，用于定义组件库的 JavaScript 编译规则，包括别名定义

babel.config.js：

vue.config.js：

打包配置文件，配置如下：
configuereWebpack：加载一些externals的依赖，externals: 配置不打包进输出文件的依赖。
  
css: 配置 CSS 相关选项。extract: true: 将 CSS 提取到单独的文件中。

chainWebpack: 通过链式操作对 webpack 配置进行修改或扩展

.use('babel'): 使用 babel-loader 进行处理。
.loader('babel-loader'): 指定使用 babel-loader。
config.resolve.alias: 配置别名。

##### babel-loader

babel-loader 是一个 webpack 加载器(loader)，它的作用是将 JavaScript 代码进行编译和转换，使得其可以在浏览器中运行。

在 Vue2 项目中，可以使用 babel-loader 将 TypeScript (ts) 代码编译为浏览器可以识别的 JavaScript (js) 代码。

具体来说，babel-loader 会读取项目中的 babel.config.js 配置文件，根据其中的配置规则将 ts 代码转换为 js 代码。babel 的转换过程包括以下几个步骤：

1. 解析 (parse)：babel-loader 将输入的代码解析为抽象语法树 (AST)。
2. 转换 (transform)：babel-loader 在 AST 上运行一系列的插件 (plugins)，对代码进行转换。例如，将 ES6 语法转换为 ES5 语法，将 JSX 转换为普通的 JavaScript 函数调用等。
3. 生成 (generate)：babel-loader 将转换后的 AST 再次转换为字符串形式的代码。

除了将 ts 编译为 js 外，babel-loader 还可以执行一些额外的操作，例如代码压缩、代码混淆等。这些操作可以通过配置 babel.config.js 文件中的插件 (plugins) 来实现。

与 babel-loader 不同，webpack 的插件 (plugins) 主要用于执行一些比较复杂的操作，例如代码分割、打包优化、资源管理等。插件和 loader 的区别在于，loader 只是对文件进行转换处理，而插件则可以执行更加细粒度的操作，例如在代码转换完成后，对转换后的代码进行优化和压缩等。

##### 配置文件中loader和plugin的区别

babel-loader，其作用是将 JavaScript 代码转换成浏览器可识别的代码
通过配置 loader，我们可以告诉 webpack 如何处理不同类型的文件，比如转换、压缩等。

plugin，它是 webpack 中用于扩展功能的插件。与 loader 不同的是，plugin 可以影响到整个构建过程，而不仅限于对单个文件的处理

比如，我们可以使用 HtmlWebpackPlugin 插件将生成的 js 文件自动注入到 HTML 中，或者使用 CleanWebpackPlugin 插件清除构建产生的无用文件等等。总之，plugin 是 webpack 中非常强大的一个功能，它可以实现各种各样的构建需求。

#### 组件库内容

##### card组件

0. 编写具体的组件内容

    如果使用了其他组件需要先import
    这里的组件声明使用的是常规的vue文件，即template，script，style的结构
    没有使用defineComponent的方法，推测是便于我们理解，当然也可能认为这样更佳可观

1. 调用组件库的内置能力和一些定义来初始化数据

    通过调用utils中的钩子函数来达到一些能力，比如获取鼠标位置，判断当前组件能否发起touch事件

    引入mixins扩充一些通用的参数和属性

2. 定义组件提供功能的辅助数据

    例如当前位置，是否正在执行css动画等属性

3. 组件挂载之后增加监听器获取用户操作

    例如点击事件，鼠标事件，分别为他们绑定methods下定义的若干方法
    aui组件库中没有使用Vue自带的事件监听器添加方法，而是自行通过addEventListener的方式进行的挂载

4. 声明有关的监听器进行处理

    例如调用获取鼠标位置的方法获取x轴y轴情况
    最核心的card的拖拽能力就会在touchmove属性中不断更新当前组件的位置，通过tarnsform能力实现转移。
    为了能够快速获取card的dom元素，通过挂载ref的方式，进行，这样只需通过this.$ref便可获取到对应元素，并修改他的样式

5. 其他方法的声明

    除了监听器的直接函数，还有一些辅助函数，用于让组件内部的一些组件进行其他操作，card暂时没有其他操作，所以没有太多的额外方法

##### select选择器

相比card组件，选择器组件更加复杂

1. 利用slot插槽进行了部分内容的外部接收
2. 其次是使用了其他的组件来组成当前页面
3. 利用model对组件的v-model指令进行接管，制定了传入父组件的属性名和触发的事件，对于model指定的属性，会在父组件传入时由props下的同名变量接收。并且event可以指定model改变时触发的事件，对于select我们设定了change事件，通知父组件绑定的值发生了改变
4. 利用this.$emit()负责和父组件进行通信，例如change时间更新值，select更新select的值；父组件只需要利用@xxx便可指定接收的函数，来对子组件发送时附带的参数进行获取和处理。
示例如下：
在子组件中定义一个方法，该方法可以通过调用this.$emit()方法来触发自定义事件，并传递数据给父组件，例如：

```javascript
methods: {
  handleClick() {
    this.$emit('custom-event', 'some data');
  }
}
```

上面的代码中，handleClick()方法会触发名为custom-event的自定义事件，并传递字符串'some data'给父组件。

在父组件中使用子组件，并监听子组件触发的自定义事件，例如：

```js
<template>
  <div>
    <child-component @custom-event="handleCustomEvent"></child-component>
  </div>
</template>

<script>
import ChildComponent from './ChildComponent.vue';

export default {
  components: {
    ChildComponent
  },
  methods: {
    handleCustomEvent(data) {
      console.log('Received data:', data);
    }
  }
};
</script>
```

##### 全局对象loading

对于全局对象，他的install方法是Vue.use，然后在Vue的原型中新增$loading方法
实现了一个全局的显示加载情况的对象，这个比较复杂，不是太清楚

1. 定义了一个transition组件当作进度条
利用after-leave和父组件通信
2. 利用核心的index代码对组件进行加载，以及封装
在加载完毕和加载开始时会动态进行页面元素的建立和删除
个人认为效率不是太高，但是好像也没有别的方法
3. 在加载结束时会根据speed的设定对动态的持续时间进行设置和处理

##### 新指令click-outside

一个比较轻量的组件
通过vue.directive进行指令的注册
利用main对能力进行实现
实现方法即在bind这个指令后，会舰艇父组件的click方法，进而判断父组件的click是否点击在了当前组件的区域内。
判断是否在当前区域，使用的是contains方法

##### setting页面，对组件库的利用

属于一个比较大型的组件，涉及的组件定义功能较多，例如@component装饰器来定义组件，利用插槽提供给外界使用，scss样式的使用

1. 引入有关接口功能和组件

    设置页面由于涉及到诸多通信能力，因此首先需要引入提前下载好的依赖，并引入有关能力，例如内容排序能力，版本检查能力
    并且作为一个大页面，setting是由多个alight-ui组成的，因此需要引入

2. 利用vue的组件声明装饰器声明当前页面是一个组件

    内部对组件名称和一些基础变量进行声明

3. 继承Vue对象进行具体页面能力的实现

    通过继承Vue，便可在内部进行当前文件有关属性的声明，以及有关方法的声明

4. 同步异步提高效率

    考虑到配置文件需要读取当前的版本和配置情况进行加载，所以在onMounted方法中进行了这些信息的获取，为了提高组件的挂载速度，这里利用async和await异步调用请求

5. 利用全局对象进行交互能力实现

    当需要用户选择确认与否时，直接调用同步确认组件，让用户进行内容的选择
    例如组件删除：

    ```ts
    const confirmed = await this.$asyncConfirm("确认要删除这些笔记吗?","提示",{
        customClass: "my-confirm-window",
    });
    if(confirmed) {
        await services.notes.clear(this.selected);
        await this.$alert("删除成功！");
    }
    ```

6. 通过样式隔离，进行样式的处理

    出了基础的使用scss变量进行全局样式的统一，还使用了嵌套选择器
    来进行更精确的样式选择，例如&>div对父组件下的所有div进行样式设定，&可以指向当前父组件
    此外还包括css3的一些选择器，例如last-child，最后一个组件，实现分隔符的最后一个不显示

#### d.ts声明组件库内容

通过模型定义文件定义当前组件库中的有关组件、指令或全局命令，其中组件和指令会集成基础的ui组件，在基础ui组件中会继承Vue对象，并利用install方法实现所有组件的自行install，install方法由各个组件的index.js调用，根据组件的类型进行安装。

例如对于指令扩展的v-clickoutside，会调用Vue.derective方法将自己注册进Vue的指令中。

对于组件则会通过Vue.component方法进行注册。

对于全局指令则会直接在d.ts文件夹中对他们进行声明，并在调用时直接进行页面中的渲染

```ts
declare module 'vue/types/vue' {
    interface Vue {
        /** Used to show feedback after an activity. The difference with Notification is that the latter is often used to show a system level passive notification. */
        $message: AlMessage
    }
}
```

#### monorepo概念

该组件库不算一个monorepo，虽然每个组件都有一个单独的文件夹，但并没有独立的package.json进行版本依赖的管理，通过npm实现组件库代码包的上传和版本管理。

monorepo的概念是指将多个相关项目或库放在一个代码仓库中进行管理，这样可以方便进行协同开发和版本管理。而基于TypeScript的monorepo管理方案则可以更好地支持类型检查和代码重用。

在公司级别的UI组件库中，我们可以采用monorepo的方式来管理组件库的代码。具体的实现方式可以参考以下步骤：

创建一个新的Git仓库来作为monorepo的根目录。

在monorepo中创建packages目录，并在其中创建不同的组件库项目，每个组件库项目都应该有自己的package.json文件和src目录。

在monorepo的根目录中创建一个lerna.json文件来配置monorepo的管理方式，如版本管理、依赖关系等。

在每个组件库项目中使用TypeScript来进行开发，并通过lerna来管理组件库的依赖关系。

在monorepo中使用npm来进行包的发布和版本控制，可以通过lerna来自动化这个过程。

使用monorepo管理组件库的好处在于可以更好地管理代码的重用和版本控制，同时也可以方便地进行协同开发和调试。

#### 搭建npm私服

搭建一个npm私服(verdaccio)用来上传和管理npm包可以方便组件库的内部使用和维护

1. 搭建verdaccio私服，npm安装并启动
2. 配置npm
    在使用verdaccio之前，需要配置npm，将npm的registry配置为本地的私服地址
    npm config set registry <http://localhost:4873/>
3. 添加用户
    使用以下命令添加用户：
    npm adduser --registry <http://localhost:4873/>
    按照提示输入用户名、密码和邮箱即可
4. 发布npm包
    在组件库的根目录下执行以下命令，发布npm包到私服
5. 下载组件库
    在需要使用组件库中的npm包的项目中，可以将npm的registry配置为私服地址，然后使用npm install命令安装npm包

为了保证私服中的npm包安全可靠，应该在上传之前进行代码审查和单元测试，确保代码质量和安全性。同时，还应该对私服进行权限管理，避免未经授权的人员上传和访问npm包

##### npm包的打包和上传

在组件库的根目录下，使用npm init命令创建一个package.json文件，按照提示填写相关信息。

在package.json文件中，修改name字段为您想要发布的npm包名。

在package.json文件中，修改version字段为您想要发布的npm包的版本号。

在package.json文件中，添加private字段，将其设置为true，表示这个npm包是私有的，不会被发布到公共的npm仓库中。


1. 确保组件库代码已经符合 npm 包的结构要求，即所有组件、样式等代码都在一个指定的目录下，且该目录下应该包含一个 package.json 文件。在 package.json 文件中，需要指定该组件库的名称、版本号、依赖等信息，并指定入口文件。

2. 通过命令行进入组件库所在的目录，执行以下命令，将组件库打包成一个 npm 包：
npm pack
执行该命令后，Webpack 会将组件库打包成一个 tar 包，并生成一个类似于 component-library-1.0.0.tgz 的文件。

3. 如果需要将该组件库发布到 npm 包管理器上，可以通过以下步骤进行：
在 npm 官网上注册一个账号，并登录到该账号中。
在命令行中进入组件库所在的目录，执行以下命令，登录到 npm：
npm login
在命令行中执行以下命令，将组件库发布到您的私有npm仓库中。
npm publish
执行该命令后，npm 会将组件库打包并发布到 npm 上，其他开发者可以通过 npm install 命令将其安装为依赖包，并在代码中使用它们。

### 2. 系统运维与经验分享

#### 1. dns 解析，二级域名管理

一个好的域名管理方案可以帮助公司更好地管理域名，提高网站的可用性和可靠性。以下是一些具体的改进方式和规范建议：

使用专业的域名管理工具，例如阿里云
合理规划二级域名的命名，例如按照功能、地区、环境等进行命名，可以提高管理效率。
针对不同的业务场景，使用不同的解析方式，例如A记录、CNAME记录、MX记录等，可以满足不同的需求。

针对不同的地区和网络环境，设置不同的DNS服务器地址，可以提高网站的访问速度和可靠性。

#### 2. ssl 证书处理管理

在互联网公司中，安全性是非常重要的一项。使用SSL证书可以有效地保护网站的安全性，提高用户的信任度。以下是一些具体的改进方式和规范建议：

使用专业的SSL证书管理工具，例如Let's Encrypt、阿里云SSL证书管理等，可以方便地申请、续期和管理SSL证书。
合理规划SSL证书的命名和存储位置，例如按照域名、功能、过期时间等进行命名和存储，可以方便管理和查找。

定期检查和更新SSL证书，避免证书过期或被篡改，导致安全问题。

##### HTTPS的安全性保证

HTTPs使用了SSL/TLS协议来保证通信过程中的安全性，它主要通过以下方式来确保安全：

1. 加密传输：HTTPs使用SSL/TLS协议加密通信内容，使得数据在传输过程中无法被窃取或篡改。
2. 防抵赖：HTTPs使用数字证书，确保通信双方的身份可信，防止通信过程中出现伪装或否认行为。
3. 数据完整性：HTTPs使用数据完整性校验机制，确保数据在传输过程中没有被篡改或破坏。

SSL/TLS协议通过使用公钥和私钥来实现加密。
在传输过程中，客户端和服务器会交换公钥（客户端会先尝试从服务器获取公钥，公钥会保存在cert证书文件中），并使用公钥对通信中的敏感信息进行加密。
然后，服务器会使用私钥对加密的信息进行解密。
公钥和私钥都是数字证书的一部分，数字证书是由证书颁发机构（CA）签名的一份电子文件，用于验证服务器的身份，当客户端连接到使用HTTPS的网站时，浏览器会检查服务器的数字证书，以确保它是由受信任的证书颁发机构颁发的，并且没有过期或被撤销。
数字证书一半是pem或der格式，PEM格式是基于Base64编码的ASCII文本格式，可以直接在文本编辑器中打开查看。而DER格式则是二进制编码的格式，不易读取；其中包含了证书以及相关信息的一个文件，包括证书的颁发机构、有效期等，以及公钥和与之匹配的私钥
但一般私钥也会单独保存，一般是pem或key文件。

如果证书未过期且是由受信任的颁发机构颁发的，则浏览器会使用服务器的公钥加密通信，从而确保传输的安全性。
如果证书已过期或被撤销，浏览器会显示一个错误页面，指示连接不安全。

#### 3. 基于md编写技术wiki总结经验

公司基于coding进行wiki的管理，我主要进行了开发以及运维有关文档的编写。

在互联网公司中，技术积累和知识分享是非常重要的一项。使用Markdown编写技术wiki可以方便地总结经验和分享知识。以下是一些具体的改进方式和规范建议：

使用专业的wiki平台，可以方便地创建、编辑和分享wiki页面。
使用Markdown语法编写wiki页面，可以方便地添加格式、链接、图片等，使页面更加美观和易读。
按照一定的规范进行命名和分类，例如按照功能、技术栈、项目等进行命名和分类，可以方便地管理和查找。

定期更新和维护wiki页面，避免过时和不准确的信息，保持wiki的及时性和有效性。

迄今针对组件库使用、系统运维、后端开发规范和技术均编写过wiki笔记

##### 平时也会编写笔记分享经验

几乎每门课程我都会整理笔记，并且以学生会的角度分享给大家，帮助大家理解知识

并且在小组内我也会经常对遇到的一些问题进行思考和解决，并在最终解决后分享给小组的其他同学，帮助大家进步。
例如matlab翻译python代码时不同语言之间的区别，项目开发经常会遇到的深拷贝问题以及如何解决，数据包拆分之后的合并样例等等，并且也会鼓励大家在组会或者平时分享自己的一些经验。

#### 4. 搭建rap2平台

RAP2是一款前后端分离的接口管理工具，可以协助前端和后端工程师协作，提高接口开发效率。

1. 搭建基础node、mysql环境
2. npm安装，配置mysql连接并启动即可

### 3. 后端开发有关

#### 1. docker-compose 管理docker镜像，实现微服务

Docker Compose 是 Docker 官方提供的一个工具，可以定义并运行多个 Docker 容器。它可以让我们通过一个 YAML 文件来管理多个容器，并且可以定义容器之间的依赖关系和通信方式。

编写 Dockerfile 文件，定义应用程序和依赖项的镜像构建方式；
编写 docker-compose.yml 文件，定义应用程序的服务，包括前端应用服务和后端微服务；
运行 docker-compose up 命令来启动所有的服务。

我们定义了一个名为“mynetwork”的网络，并将service1和service2容器连接到该网络。这意味着这两个容器可以相互通信，使用它们在该网络上的名称来进行通信。

#### 2. docker容器之间的交互

我们参考了业务单元之间通信规范，即RPC（Remote Procedure Call）是一种远程调用的通信协议，可以使得不同的服务之间相互调用。

我们可以使用 gRPC 作为 RPC 协议，它是由 Google 开源的高性能、跨语言的 RPC 框架。gRPC 基于 Protocol Buffers（一种语言无关、平台无关、可扩展的序列化格式）实现，可以在不同的编程语言中使用。

编写 Protocol Buffers 文件定义服务接口和消息类型；
使用 Protocol Buffers 编译器生成不同编程语言的代码；
编写服务端和客户端的代码实现服务调用。

各个业务单元被分配在同一个网络internal下，我们声明了rpc模块，专门负责基于rpc进行模块间的通信。

例如教室模块需要获取用户模块的具体信息，用户模块首先声明开放给其他模块的rpc接口，进而教师模块便可直接调用对方的rpc接口来进行有关操作

#### 3. 外部公司api的接入与测试

Postman：是一种流行的 API 测试工具，可以轻松地创建和发送 HTTP 请求，并且可以检查响应的内容和结构。

#### 4. 部署adminer实现数据库的web操纵

Adminer是一个功能强大的数据库管理工具，可以方便地进行数据库的操作。下面是在Docker中部署Adminer的具体步骤

可以使用以下命令在Docker中创建一个Adminer容器：

```bash
docker run --name adminer -d --restart=always -p 8080:8080 adminer
```

该命令会创建一个名为adminer的容器，将容器的8080端口映射到主机的8080端口，并启动Adminer容器。

Adminer容器启动后，可以通过浏览器访问Adminer的地址，在Adminer中连接数据库，并进行数据库的操作。

#### 5. 结合swagger实现接口的快速预览

1. 首先基于swagger规范编写代码注释和有关文档内容
2. 基于swagger的镜像建立docker容器
3. 在docker内部实现对代码的获取，并映射端口到某个具体的端口
4. 进而只需访问该端口即可查看接口
通过基于docker运行swagger，我们可以方便地预览API接口的信息，加快了前端开发的速度和效率。同时，也可以方便地和后端开发人员进行沟通，减少了沟通成本。

## 公安

### 预警和数据统计系统

#### 1. sass 和 less 的接触（css 模块化思想）

LESS是一种CSS预处理器，它提供了很多便捷的语法和功能来增强CSS的能力，如变量、混合、嵌套等。

使用LESS可以大大简化CSS的编写和维护，提高代码的可重用性和可维护性。

例如，使用LESS可以定义变量来存储颜色、字体大小等常用值，然后在CSS中引用这些变量

#### 2. 升级旧版系统

基于现有UI风格进行小幅度改动。
旧版系统UI已经足够好看，只需要针对一些细节进行优化，比如改变颜色、字体、按钮形状等。可以考虑使用CSS预处理器（如Less、Sass）和CSS框架（如Bootstrap）来快速完成样式改动。

#### 3. 制定Restful规范接口

1. 采用统一的URL格式。例如，GET请求的URL应该只用于查询操作，而POST请求的URL应该只用于新建资源操作。URL应该使用名词来表示资源，动词用于表示对资源的操作。
2. 采用合适的HTTP方法。例如，GET用于查询数据，POST用于新增数据，PUT用于更新数据，DELETE用于删除数据。
3. 使用HTTP状态码表示操作结果。例如，200表示成功，400表示客户端请求错误，404表示资源不存在，500表示服务器内部错误等。
使用JSON格式作为数据交换格式。JSON格式具有良好的可读性和扩展性，同时也易于处理和解析。

#### 4. 行列布局数小时搭建可视化系统

1. 首先，我会针对系统的需求和设计稿进行布局设计，确定所需要的行列布局数量及样式，通过设计确定了左中右三部分布局，左侧负责数据情况统览（饼图），右侧进行基于具体类型的情况展示，中间提供大量数据的分页搜索和展示。
2. 接着，我会选用合适的框架，即vue2 + elementUI。
3. 在布局的基础上，我会根据设计稿的要求添加相应的组件及交互效果，因为数据来自json文件，所以没有做api部分，直接按需读取数据，并进行适当的优化，提高可视化系统的用户体验。

#### 5. 大数据分页问题

这个项目中由于数据来自json，所以只是单纯的前端分页，会针对不同数量长度的json文件自动计算总页数，并基于index去获取对应的数据。
在前端通过JS代码实现分页处理。具体实现可以将所有数据加载到前端，然后通过JS代码进行分页、排序、过滤等操作，最终呈现给用户。但是，对于大数据量的分页，这种方式需要考虑到性能和内存的问题。

如何优化前端页面渲染性能，减少大数据量的渲染时间和资源消耗

为了提高数据展示的性能，可以考虑使用懒加载和分页加载的方式。懒加载可以将数据的加载延迟到用户需要时再进行加载，而不是一次性将所有数据都加载进来，可以减轻页面的压力。

分页加载可以将数据分成若干页，每次只加载一页数据，也可以减少数据的加载量，提高性能。

分片加载数据：将数据分为多个小块，然后在需要展示的时候动态加载。这样可以减少首次加载时所需时间，并且可以更好地控制内存占用。

懒加载：只有在需要显示某一部分数据时再加载这一部分数据。这样可以减少不必要的数据加载，提高加载速度。

数据预处理：对数据进行预处理，例如缓存计算结果、数据格式转换等，可以提高数据处理速度。

服务端渲染：利用服务端渲染将数据渲染到HTML中，可以减少客户端的渲染时间，提高用户体验。

## 瑞航

初步接触框架，了解到规范的前端开发
团队合作，接口的联调

### 展馆管理系统

#### 1. 本地存储与 cookie 的初步使用

##### 1. 缓存

在HTTP响应头中添加缓存控制的相关字段，例如Cache-Control和Expires。其中Cache-Control可以设置缓存的过期时间或者禁止缓存，而Expires则可以设置缓存的到期时间。

合理使用ETag（实体标签）和Last-Modified（最后修改时间）两个字段，可以让浏览器根据服务器端资源的状态进行缓存的更新。

使用LocalStorage或SessionStorage等浏览器本地缓存机制，可以将一些频繁使用的静态资源存储在本地，提升用户访问速度。

##### 2. cookie

使用cookie记录用户token
在JavaScript中，通过document.cookie可以读取和设置Cookie。Cookie有很多属性，其中比较重要的是过期时间。

设置Cookie的过期时间，可以使用如下代码

```ts
// 以7天为例，获取当前时间并加上7天的时间戳，然后将时间戳转换成UTC时间格式
var expires = new Date(+new Date() + 7 * 24 * 60 * 60 * 1000).toUTCString();
document.cookie = "name=value;expires=" + expires;
```

#### 2. 基于ajax的请求管理

引入jQuery或者其他JavaScript库，因为jQuery封装了一些Ajax方法使其使用更方便。引入jQuery可以通过以下代码实现：

封装Ajax请求。将Ajax请求封装到一个函数中可以使代码更加模块化和可维护，封装之后我们可以在项目的任何地方使用该函数来发起Ajax请求。以下是一个简单的Ajax请求封装函数的示例代码：

```ts
function sendAjaxRequest(url, method, data, successCallback, errorCallback) {
    $.ajax({
    url: url,
    method: method,
    data: data,
    success: function(response) {
        if (successCallback) {
        successCallback(response);
        }
    },
    error: function(error) {
        if (errorCallback) {
        errorCallback(error);
        }
    }
    });
}
```

通过 jQuery.ajax 方法封装 Ajax 请求，通过 successCallback 和 errorCallback 分别处理成功和失败的回调逻辑。

发送Ajax请求。当需要发送Ajax请求时，调用封装好的Ajax函数并传入请求的URL、方法、数据等参数即可。

## 信息办

### 周年庆弹幕网站

#### 1. jquery 对 dom 的操纵

在HTML中添加弹幕元素，可以用 \<div> 标签表示，设置一些样式如颜色、大小、位置等。

通过 JavaScript 获取弹幕元素的引用，一般使用 document.querySelector 或 document.querySelectorAll。

使用 setInterval 或 requestAnimationFrame 实现定时器，根据一定的时间间隔，对弹幕元素的位置等属性进行修改，从而实现弹幕效果。

```js
// HTML
<div class="danmu">Hello, world!</div>

// CSS
.danmu {
    position: absolute;
    font-size: 16px;
    color: #fff;
    text-shadow: 0 0 3px #000;
}

// JavaScript
const danmu = document.querySelector('.danmu');
let position = 0;

setInterval(() => {
    position += 2;
    danmu.style.transform = `translateX(${position}px)`;
}, 10);
```

使用jQuery可以大大提升项目开发的效率和代码的可维护性。

例如，使用jQuery可以通过选择器轻松地访问和操作DOM元素

#### 2. vw，vh 等计量单位的了解

使用vw和vh作为元素的宽高单位，根据viewport的宽度和高度来计算元素的大小

他们是css3新增的相对单位
分别代表视窗（viewport）的宽度和高度的百分比。比如，1vw表示视窗宽度的1%
vw和vh的计算是基于视窗的宽度和高度的，而不是基于元素的宽度和高度。

vw和vh是相对单位，它们的大小随着视窗的大小而变化。

在计算vw和vh的值时，会将视窗的宽度和高度分别除以100，然后用结果乘以相应的百分比值，得到最终的值。

#### 3. php数据的获取和页面实时更新

在 PHP 后端编写一个数据接口，返回需要更新的数据。
在前端使用 setInterval 或 WebSocket 等方式定时或实时地请求该接口。

获取到新的数据后，可以使用 JavaScript 对页面的 DOM 进行操作，实现数据的实时更新。

## 个人网站

### vue3版本

#### 1. vue3的新特性

Composition API：Vue 3 中引入了 Composition API，它可以让开发者根据功能逻辑划分组织代码，而不是按照组件生命周期来组织。Composition API 更加灵活，能够更好的解决代码复用和组织问题。

Teleport：Teleport 是一个新的内置组件，可以帮助我们将组件的内容渲染到任意的 DOM 节点中，而不必将其包裹在父组件中。

Performance Improvements：Vue 3 通过优化虚拟 DOM，提高了渲染性能。另外，新的编译器能够生成更小、更快的运行时代码。

Vue 3中，虚拟DOM主要应用于模板编译和渲染过程。Vue 3使用了一个全新的编译器，它采用了更快的模板编译策略，可以在运行时对模板进行即时编译，生成虚拟DOM渲染函数，并将其缓存以提高性能。

Vue 3中，虚拟DOM的实现相比Vue 2有一些改进。首先，Vue 3中的虚拟DOM是基于Proxy的，这使得Vue 3能够更好地捕获对象上的属性变化，并更快地更新视图。

其次，Vue 3中的虚拟DOM对片段和Teleport等新特性进行了优化，使其能够更好地支持动态组件、条件渲染和列表渲染等功能。

此外，Vue 3中的虚拟DOM也针对多个平台进行了优化，包括Web、Weex和原生移动端平台。

#### 2. 利用ts的接口和type能力规范变量结构

TypeScript是JavaScript的超集，提供了静态类型检查、代码重构等功能，能够提高代码的可读性和维护性。

TypeScript的静态类型检查和代码重构，它们可以有效提高代码的可读性和可维护性。

静态类型检查可以帮助开发者在开发过程中及早发现类型错误，减少运行时错误。同时，使用类型注解可以让代码更加清晰易读，同时也方便后期代码维护。

在进行代码重构时，我们可以借助TypeScript的类型定义来辅助重构，比如重构过程中可以根据类型定义来调整函数参数和返回值类型，从而提高代码的可维护性。

#### 3. pinia 相比 vuex 的优势

Pinia是一个新一代的状态管理库，相比Vuex在类型安全、响应式更新等方面更加优秀。

它采用了基于Proxy的响应式实现方式，使得性能更好，并且采用了更加简单易用的API设计，使得开发者可以更加容易地使用

此外，Pinia还充分利用了Vue3的新特性，比如Composition API等，使得状态管理更加灵活、模块化支持更加完善。

优势：
更好的类型支持：Pinia是基于Vue3的响应式系统实现的，因此可以完美地与TypeScript结合使用，从而获得更好的类型支持。同时，Pinia的API设计也非常好，使得开发者可以更容易地在TypeScript环境下使用。

更好的性能：Pinia采用的是基于Proxy的响应式实现方式，相比于Vue2和Vuex的Object.defineProperty实现方式，具有更好的性能。

更简单的API：Pinia的API非常简单易用，且没有繁琐的概念和规则，相比于Vuex来说更加容易上手。

更好的扩展性：Pinia的架构更加清晰，对于插件和中间件的扩展也更加容易。此外，Pinia还提供了插件化的API，可以轻松地进行插件开发和集成。

更好的模块化支持：Pinia的状态管理是基于模块化的方式实现的，可以更加清晰地组织代码和状态，并且可以轻松地共享和复用状态逻辑

劣势：
生态系统不如 Vuex：Vuex 已经有了大量的插件和中间件，Pinia 的生态系统相对较小。

学习成本高：由于 Pinia 使用了新的概念和语法，因此对于新手来说，学习成本可能会更高一些。

#### 4. vueuse 库的强大，学习react的钩子函数

Vueuse是一个为Vue 3设计的实用函数库，提供了许多常用的工具函数和hooks，例如useLocalStorage、useEventListener等，可以方便地增强Vue应用的功能。

React Hooks是一种实现逻辑复用的方式，通过定义自定义钩子函数，实现在不同组件之间共享逻辑的目的。

而VueUse则是对Vue 3的Composition API进行的扩展，提供了许多实用的组合函数，帮助我们更好地组织代码和共享逻辑。

我认为React是一款非常优秀的前端框架，具有良好的生态系统和强大的社区支持，React的主要特点是组件化、单向数据流以及虚拟DOM，这些特点使React在构建大型复杂应用方面表现出色。

关于React的Hooks和VueUse，它们都是为了解决函数组件中状态管理和逻辑复用的问题而产生的。

在实现上，React的Hooks和VueUse都使用了闭包和函数柯里化的技巧，以及函数式编程的思想，这使得它们都非常灵活，能够轻松地进行逻辑复用和状态管理。

同时，React的Hooks和VueUse都可以帮助我们将组件的逻辑与渲染分离，使得代码更加清晰易懂，也更加容易维护。

我非常赞同面试官对React的看法，React是一个非常流行和强大的框架，我也确实很想学习并且在将来的工作中使用。

但是在我的开发经验中，大部分都是使用Vue框架来完成的。我觉得在不同的项目和场景下，选择不同的技术栈是非常正常和合理的选择。同时，我也意识到自己之前在学习和使用React方面的不足，并且已经开始积极主动地学习和实践React相关的知识和技能。我相信在面对新的技术栈时，我的学习能力和适应能力可以让我快速掌握并应用它们。

#### 5. vite 构建的速度与能力是如何实现的

Vite是一款由Vue.js核心团队开发的构建工具，可以在开发过程中提供非常快的构建和热更新速度，提高开发效率。

相比Webpack的提升主要来自于两个方面：
关于Vite和Webpack的区别

Vite在开发环境下采用了ESM原生模块方式，利用浏览器本身支持的模块加载机制，从而避免了Webpack开发模式下频繁的打包和构建，提高了开发效率。

在生产环境下，Vite使用了现代化的技术来实现代码的预编译，例如使用Rollup对依赖库进行单独打包。这样可以使得依赖库不需要被重新编译，只需要在客户端按需加载即可，大大减少了构建时间和打包体积。

同时，Vite还支持热更新，可以做到局部更新而无需整个页面刷新，提升了开发体验和效率。

Vite还采用了缓存技术，缓存的内容包括已经编译好的模块、依赖关系和编译后的代码等，这样在后续的开发过程中，如果没有变化，就可以直接从缓存中读取，避免了重复的编译和打包操作，进一步提高了开发效率。

在实际使用Vite过程中，可能会遇到一些问题，比如一些第三方库并不支持ESM模块，这时候可以使用@vitejs/plugin-legacy插件来支持传统的打包方式。

vite的热更新是如何实现的
Vite使用了基于浏览器原生支持的ES模块的动态导入特性，它可以让应用程序在运行时动态加载新模块，这样在修改了某个模块之后，Vite会把新的模块推送给浏览器端进行实时更新。这种方式比传统的HMR（Hot Module Replacement）更加快速和稳定，而且无需手动配置

如何找到修改了的模块
使用了浏览器端原生的事件监听机制。Vite 在启动时会创建一个 WebSocket 服务器，当文件发生变化时，Vite 会将变化的文件路径信息通过 WebSocket 推送给浏览器端，然后浏览器端通过监听 message 事件实现热更新。

#### 6. 基于commitlint和husky规范commit

使用commitlint和husky可以规范化团队成员的commit信息，确保提交的代码风格一致。

在项目中，可以通过配置husky在提交代码前进行代码检查和校验，通过commitlint来强制规范commit信息的格式，这有助于提高代码可维护性和协作效率。

#### 7. 组件库深层样式修改

vue 文件之间的样式隔离
使用组件库后 deep 进行深层组件的渗透

#### 8. pinia和router的循环引用问题

尝试在路由守卫判断 pinia 中的状态，但是还未初始化

两种解决方案

1. 先创建Pinia，然后创建router

    这样createPinia会在Vue应用实例中创建一个全局的Pinia实例，并将其绑定到Vue应用实例的app.config.globalProperties上。因此，Pinia实例可以在应用程序中的任何地方被访问到。

    在执行createRouter时，可以通过在选项对象中传入app属性，将Vue应用实例传递给路由实例。这样，在路由文件中，可以通过router.app.config.globalProperties.$pinia来访问Pinia实例。

    但是这样不够规范，而且也容易后续出问题，毕竟只是修改引入顺序便会导致出问题，这显然是不合理的

2. 在router创建后的钩子函数中进行pinia的获取

    即等到 Vue Router 初始化之后再进行访问，此时pinia实例一定会被注册，因为此时vue应用程序已经初始化
    因此便可以直接通过Vue Router的 beforeEach 方法中使用 pinia.use 来获取Pinia实例。

### nuxt3版本

#### 1. 服务端渲染的使用体验，以及优势

服务端渲染能够提供更好的SEO和首屏渲染速度，同时提高用户体验。使用服务端渲染，可以在服务器端生成HTML页面，而不是在浏览器端执行JS代码来生成页面。

这样可以减轻客户端的负担，加快页面的加载速度，并且可以让搜索引擎更好地抓取和索引网站内容。

在实际开发中，可以使用框架提供的服务端渲染插件来实现服务端渲染。

更快的首屏加载速度：服务端渲染可以在浏览器加载JavaScript之前将HTML页面发送到客户端，从而缩短了页面的加载时间。这对于一些对性能有较高要求的应用程序来说尤其重要。

更好的用户体验：由于服务端渲染可以提高页面的加载速度，因此用户将更快地看到内容，这可以提高用户体验。

另外，由于服务端渲染可以在没有JavaScript支持的情况下正常工作，因此它可以提供更好的容错性。

#### 2. sass技术的使用，一些技巧

SCSS是CSS的预处理器，提供了许多功能，例如嵌套规则、变量、Mixin、函数等，使得编写CSS更加简单和灵活。

在项目中，可以使用Sass来提高CSS的复用性和可维护性，同时还可以减少代码量和开发时间。在使用Sass时，可以使用变量、嵌套、混合等功能，来简化CSS代码的编写和维护。

另外，Sass还支持模块化开发，可以将CSS样式分解成多个文件，便于管理和维护。

我们在开发一个管理系统的项目时，需要定义很多不同样式的组件，这些组件有时候还需要和其他组件一起使用，这样就需要很好地管理这些样式。
使用Sass可以让我们定义变量、嵌套、继承等，从而更好地管理样式。
比如，我们定义一个基础的按钮样式，并定义了一些变量，然后在不同的组件中继承这个基础样式，同时使用变量进行样式的修改，这样就可以实现样式的统一管理。

## OJ

OJ系统是在我接触中科院项目之前最给我锻炼的项目
该系统作为北航的核心系统，每年都会支撑几百人的上机学习和考试等事务，而我就是背后的技术人员
在运维第四版的过程中我对服务端渲染项目有了进一步的学习，也对redis、cookie等缓存技术的利用有了更进一步的理解，并对实际上线系统可能遇到的XSS、DDoS攻击、服务器时间的利用等问题有了经验，并且通过对评测机分布式系统的管理，也让我对linux服务器的操作有了深入了解。
对于第五版的开发，应该也是我第一次带队开发相对比较复杂的系统，通过 vuetify 组件库和 tailwindcss 样式表进行的UI设计，也是得益于vue框架，在架构设计上我仍然遵循了模块化、组件化的策略，并且将此前的web前端开发技术均进行了应用来确保系统的鲁棒性，包括但不限于：基于restful和bem规范进行接口和样式的管理，基于flex和网格布局进行自适应布局，基于token+路由+计算属性实现复杂权限管理，以及路由懒加载和防止用户频繁提交等性能上的优化策略
OJ项目相当于是锻炼了我对于实际上线系统开发中需要注意问题的全面思考，以及对我过去web前端知识的一次考核。

### 第四版

#### 项目能力

##### 1. 利用session中间件结合cookie管理用户登录态

使用express-session库创建session中间件，并将RedisStore实例作为store属性传入中间件中：

```ts
app.use(session({
    secret: 'ojth',
    resave: false,
    saveUninitialized: true,
    store: new redisStore(),
    cookie: {maxAge: 1000 * 60 * 60 * 24} //null to create a browser-session
}));
```

其中，store属性指定了使用RedisStore存储session数据，secret属性是一个加密密钥，用于对session数据进行加密，resave属性表示每次请求是否都重新存储session数据，saveUninitialized属性表示是否保存尚未初始化的session数据，cookie属性设置了session的cookie选项。

在用户登录成功后，将用户信息存储到 session 中
在需要验证用户登录状态的路由中，判断 session 中是否存在用户信息
在用户注销登录时，删除 session 中的用户信息

其中，session 中间件负责保存用户信息，cookie-parser 中间件负责解析 cookie 中的 session ID，从而实现用户的登录状态管理。

##### 2. 基于redis缓存排行榜信息以优化性能

以下规范和实现方式：

规范：

确保Redis服务器的时间与MySQL服务器的时间一致，避免在保存排行榜信息时出现时间不一致的问题。

使用Redis的有序集合（Sorted Set）来保存排行榜信息，其中集合的成员为网站用户的ID，成员的分值为该用户在网站上的排名。

具体来说，可以使用zadd命令来向有序集合中添加成员和分值，使用zrange命令来获取排行榜信息。

定期将Redis中保存的排行榜信息同步到MySQL数据库中，以便在Redis故障或重启时能够恢复排行榜信息。

##### 3. 比赛和考试的严格权限管理

例如利用服务器时间来对当前时间进行判断，而不是本地时间，防止通过修改本地时间来进行处理

当考试类型的赛事启动时，会关闭代码查看以及题解能力的防止作弊

##### 4. 对代码评测安全的保证

在线代码评测系统：如何安全地隔离用户提交的恶意代码，防止对系统造成损害。

首先对于代码的处理：
代码沙箱隔离：我们采用了 Docker 来运行用户的代码，通过 Docker 确保用户提交的代码与服务器主机隔离，避免了潜在的恶意代码对服务器造成的威胁。

所有代码在被评测机接收到之后，会基于默认镜像创建一个相同的代码环境，这样不仅可以确保评测规则一致，也可以确保不会互相影响

限制 CPU 和内存：我们通过对 Docker 运行环境进行配置，限制了用户代码的 CPU 和内存使用，防止用户恶意占用服务器资源。

代码扫描：我们在代码提交之前会对用户提交的代码进行扫描，检查是否有恶意代码或者漏洞等问题。

##### 5. 基于ip检测的恶意用户的处理

IP 黑名单：我们会监控用户的请求频率，如果发现某个 IP 地址在短时间内频繁提交请求，我们会将该 IP 地址加入黑名单，禁止其继续提交请求。

借助Nginx进行IP请求次数统计和限制。我们可以在Nginx配置文件中添加类似如下的配置

```bash
http {
    ...
    limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;
}
server {
    location / {
        ...
        limit_req zone=one burst=5;
    }
}
```

其中，limit_req_zone用于定义限制请求的zone（区域）以及请求的速率，参数说明如下：

binary_remote_addr：表示客户端IP地址，使用二进制格式，可以替换成其他变量。

zone=one:10m：表示限制区域名称为one，大小为10MB，可以根据需要进行调整。

rate=1r/s：表示限制每秒只能有1个请求

在需要限制请求的location中添加的配置中：

imit_req用于配置限制请求的zone（区域）和突发速率，参数说明如下：

zone=one：表示使用之前定义的限制区域one。
burst=5：表示在请求速率超过限制速率后，最多可以接受5个请求。
通过以上配置，即可限制请求速率并防止DDoS攻击。

#### 系统运维管理

##### 1. 基于PM2+Tmux运维项目

PM2和Tmux是两个常用的Node.js进程管理工具和终端复用工具，可以帮助我们更方便地管理和运行Node.js应用程序。在使用这两个工具的过程中，我们需要注意以下几点：

合理设置进程数量和内存限制，避免资源浪费和进程崩溃；
使用Tmux分离终端会话，避免终端断开或者重启后进程被关闭；
使用PM2的日志记录功能，方便查看和分析应用程序的日志信息。

##### 2. 系统迁移

定期备份，利用实体硬盘结合git的双向备份
放置系统的异常

需要注意以下几点：

1. 数据备份和迁移，避免数据丢失或者损坏；
navicat进行数据的备份和迁移
2. 应用程序代码的迁移和测试，确保应用程序能够正常运行；
由于校内外环境的差异，需要做一些调整，例如联网方式的区别，访问外部资源的区别
3. 更新相关配置文件和环境变量，确保应用程序能够访问正确的资源。
校内环境的ubuntu系统和校外不同，不够强大，甚至时间都不是正常的中国时间，还需要进行批量的时间处理

###### 格林尼治时间和中国时间

关于mysql保存的时间总是比北京时间晚八个小时的问题，可以在MySQL的配置文件中设置时区，使其与北京时间保持一致
MySQL数据库中的时间默认采用UTC时间，即世界标准时间。而北京时间比UTC时间早8个小时，因此在MySQL中保存的时间会比北京时间早8个小时。

这是因为在设计数据库时，采用的是UTC时间是为了保证在不同的时区中处理时间的一致性。当需要显示给用户时，再将UTC时间转换为用户所在时区的本地时间。

UTC的全称是Coordinated Universal Time（协调世界时），是一种标准时间，由国际原子时标准计时（TAI）和地球自转的变化共同决定。格林尼治时间（GMT）是指位于英国伦敦郊区的皇家格林尼治天文台所确定的时间。

UTC是以原子时标准为基础，因此更加精确。GMT是一种以太阳在本初子午线上通过的时间为基础的时间标准。因此，UTC和GMT的时间有些微小的差别，但通常在日常使用中两者可以互换

同时由于校内外系统曾经分别独立运行了一段时间，因此两部分系统中存在着很多重复用户，甚至他们的用户id可能会相同，但用户不同

我们通过编写脚本，基于username判断是否是同一个用户
优先校内的信息，将校外中的代码提交记录进行同步，包括班级信息，比赛成绩信息等等，均基于id进行替换处理。

##### 3. 脚本编写

###### 1. 自动检测评测机情况并重启

使用Linux的ps命令和grep命令来检测正在运行的Node.js进程。具体来说，您可以使用以下脚本：

```bash
#!/bin/bash

# 检测 Node.js 进程是否在运行
if ps aux | grep '[n]ode index.js' > /dev/null
then
    echo "Node.js 进程正在运行"
else
    echo "Node.js 进程未运行，正在启动..."
    # 执行启动脚本
    sh /path/to/start.sh
fi
```

解释一下这个脚本的逻辑：

ps aux 命令用于列出当前正在运行的进程。

grep '\[n]ode index.js' 命令用于查找包含 "node index.js" 字符串的进程，而 "\[n]ode index.js" 则是为了避免将 grep 进程本身也算入进程列表中。

> /dev/null 将命令输出重定向到 /dev/null，以便在运行脚本时不会看到输出结果。

如果 ps 和 grep 命令的组合返回结果，则说明 Node.js 进程正在运行。反之，则说明进程未运行，此时脚本将启动一个启动脚本，例如您可以将您的 Node.js 应用启动脚本的路径写入到 /path/to/start.sh

您可以使用 cron 作业调度程序将此脚本定期执行。例如，如果您想每 5 分钟检查一次 Node.js 进程，请将以下行添加到 crontab 文件中：

```js
*/5 * * * * /path/to/check_node_process.sh
```

这将使脚本每 5 分钟执行一次。请注意，在将脚本添加到 crontab 文件之前，需要将其更改为可执行文件：chmod +x /path/to/check_node_process.sh。

###### 2. 定时执行联网脚本

同样基于corntab工具实现
配置了个定时执行的脚本

##### 4. Mysql数据2w条数据错误修改

1. 发现问题，关闭系统

    导致问题发生的原因是在尝试修改某个课程的用户密码时缺少了课程这一限制条件，从而导致修改了几乎所有用户的密码

    考虑到用户密码发生了变化，该问题虽然不影响使用但是会导致大量用户无法登录系统，因此需要关闭OJ进而进行修复。

    oj的访问有域名和ip两种，为了不让学生使用，关闭域名访问即可，因此只需修改/etc/nginx中的nginx.conf文件即可，目前整理了nginx.conf.normal和nginx.conf.repair两个文件，其中normal为正常情况的配置文件，repair为禁止学生访问的配置文件。

2. 寻找解决方法

    常用的解决方案有两种：
    1、使用mysql自带的mysqlbinlog进行恢复
    2、使用某开源软件binlog2sql进行恢复

    原理都是找到导致问题的代码，然后生成一个反向的sql代码，进而执行反向代码便可恢复出错的数据

3. 备份数据开始生成解决代码

    首先对目前的数据库进行备份，防止后续出现问题。
    为了恢复出错操作，首先需要找到操作的记录，mysql通过开启binlog，可以记录最近的操作，因此首先需要用root用户登录mysql，然后查看目前的状态
    可以看到最新的binlog文件和最新的操作位置，这里的position即记录点

    找到binlog文件后便可以查看binlog的内容，进而找到出错操作开始和结束的记录点

    mysqlbinlog --no-defaults--start-datetime="2022-09-17 02:53:00" --stop-datetime="2022-09-17 02:54:00" binlog.000354
    （默认数据库开启了log_bin功能，否则真的就没法回滚了。。。 show variables like 'log_bin';）

    这里首先需要找到binlog所处的位置，在进入mysql后可以用指令show variables like 'log_bin_basename'; 来找到binlog的位置，校内oj的mysql有关文件位于/home/buaa/workSpace/mysql_data中

4. 小范围测试恢复代码，确保无误后全面回退，通知恢复

    由于导出后的格式太过简陋，因此需要参考文章来批量处理，进而生成可行的sql文件，初步处理后的文件：recover_raw.sql

    但由于本次的用户表较为复杂，生成的sql文件中会有很多的无用字段，而且也无法直接运行。

    还需要利用处理脚本ReReadSQL.py对生成的原始sql文件进行进一步的处理优化，仅保留部分有效的文件
    得到正常的sql文件后，为了确保安全，可以先选择部分sql语句进行小范围测试，测试无误后再利用客户端工具或服务器内部运行sql文件，便可实现数据恢复

##### 5. 评测机卡顿修复

转移到校内后，校内是机械硬盘，导致性能不足

分析原因：

服务器层面：
服务器内存不足，无法处理请求：
网络原因，连接不上其他服务器：

OJ项目层面：
项目内部处理接口出错，无法正常处理后端请求：

评测机层面：
评测机内部异常，无法很快得到评测结果：
评测机无法正常快速修改数据库数据，导致更新过慢：

最后发现是性能问题，并且由于cpu不够强大，容易在内核切换时卡住，后来修改了服务器好一些。

后续的改进

1. 由于后续评测机的机制存在问题：定时请求，容易卡顿，修改为随机几s后获取任务
2. 编写自动重启脚本，当死亡时重启项目，
3. 利用frp结合校内校外的一个核心服务器作为中转，让校外的评测机可以评测代码，后来由于学校安全要求不再让使用

### 第五版

#### 1. 整体数据表设计

数据表设计是一个前后端分离项目中非常重要的一步，设计好的数据表结构能够方便后续的数据操作和开发。以下是一些设计数据表的建议和规范：

定义清晰的表名和字段名，并使用下划线分割单词，例如 user_info 表和 user_name 字段。
尽量避免使用特殊字符作为表名或字段名，因为这可能会导致一些意想不到的错误。

定义合适的数据类型，例如 int、varchar、text 等，避免使用过于宽泛的数据类型。
定义主键和外键，以确保数据的完整性和准确性。
合理使用索引，以提高查询效率。
考虑数据库性能，例如分表、分库等方式。

针对业务对象进行设计：
用户、班级、课程、比赛、题目、代码

#### 2. markdown富文本显示

在前后端分离的项目中，通常需要将后端返回的 Markdown 格式的文本进行解析和显示。以下是一些实现富文本显示的建议和规范：

使用第三方库，例如 marked.js 和 highlight.js，以解析 Markdown 格式的文本和渲染代码块。
将解析后的 HTML 代码存储到数据库中，并在前端使用 v-html 指令进行渲染。

考虑安全性问题，对用户输入的 Markdown 文本进行过滤和转义，以避免 XSS 攻击等安全问题。

考虑性能问题，对于较长的 Markdown 文本，可以在后端进行分页处理，减少前端渲染的时间。

#### 3. 复杂用户的权限管理，具体到组件

首先我们会对每个用户单独设立token，在用户登录后，服务端便于基于spring的JWT库生成token并返回给前端，进而前端在cookie中进行token的存储和再次利用，为了便于进行用户权限的管理，在系统加载后也会通过vuex进行token的获取和检验，利用jsonwebtoken的第三方库来进行合法性的验证，当正常时才会视为登录态。基于用户的合法token，我们会将token放在请求头，首先对用户的权限级别进行获取和存储。

首先会配置路由守卫，在页面级别通过meta字段来对需要登录和不需要登录的页面进行区分，在进入之前便对用户权限进行验证和判断，如果无权限则会跳转到登录页面。
即使用户强行访问某些界面，尝试进行接口的访问，在后端也会验证token的有效性，根据需要可以对所有API或者部分API进行权限控制，对于没有权限的API请求，可以返回错误信息或者提示用户无权限。

进而在页面之中我们还需要对不同组件进行权限的配置，需要确定好权限的种类、作用范围和等级，以及用户、角色和权限之间的关系。
采用RBAC模型（Role-Based Access Control，基于角色的访问控制）来实现用户权限管理。

最终基于Vue-Router和Vue-Store配合实现权限管理，具体步骤如下：

1. 定义路由表，根据权限配置路由表，通过路由守卫对to的页面结合meta中的权限要求做对比
2. 在Vue-Store中存储用户信息，包括角色、权限等信息，以让路由和组件使用
3. 在组件中使用权限控制指令，为了简便的控制各个组件的权限，我们声明了v-auth指令，在其中对指令挂载的组件预计对权限的要求进行获取，进而从store读取用户权限，判断是否存在要求中，如果不存在则直接remove元素，实现隐藏

当然这些只是对基础组件的控制，对于课程中课程成员以及课程管理员等更细分的权限，则会通过各个组件内部的路由钩子函数进行前置判断，动态判断当前用户的权限级别，再对相应的元素通过v-if进行显示与否的控制。

##### v-auth实现策略

首先我们会对用户权限基于数字进行分级，目前0为游客，-1为封禁用户，1为普通用户，2为管理员，10为超级管理员

进而通过声明一个基于insert的v-auth指令，便可实现组件的加载与否
即组件会通过v-auth来声明当前组件需要的权限级别，进而v-auth内部可以获取到当前的组件信息以及具体的级别
进而在auth指令中通过对vuex中存储的用户权限进行判断，当没有权限便会直接remove用户

定义自定义指令 v-auth，该指令接受一个字符串类型的参数，表示需要的权限等级，

```javascript
// src/directives/auth.js

import store from '@/store'

export default {
  inserted(el, binding) {
    const { value } = binding
    const { userInfo } = store.getters

    // 判断用户是否有对应的权限等级
    if (userInfo && userInfo.role >= value) {
      return
    }

    // 没有权限，隐藏元素
    el.parentNode && el.parentNode.removeChild(el)
  }
}
```

在 main.js 中注册 v-auth 指令。

```javascript
// main.js

import Vue from 'vue'
import authDirective from '@/directives/auth'

Vue.directive('auth', authDirective)
```

在需要进行权限控制的组件中使用 v-auth 指令。

```vue
<template>
  <div v-auth="2">
    <p>只有角色等级大于等于 2 的用户才能看到该内容</p>
  </div>
</template>
```

##### RBAC模型

是一种基于角色的访问控制模型，通过将用户分配到不同的角色，并授予角色不同的权限，来控制用户对系统资源的访问。RBAC模型主要包括以下四个基本概念：

用户（User）：系统中的实体，可以是个人、程序或其他组织。
角色（Role）：一组用户的集合，角色可以有父子关系，子角色会继承父角色的权限。
权限（Permission）：指允许或禁止用户或角色对系统资源进行的操作。
资源（Resource）：系统中需要受到保护的对象，如文件、数据表等。

在RBAC模型中，用户只能通过角色来访问资源，这样可以使得系统的访问控制更加灵活、高效、易于维护。

在实际应用中，我们可以通过在前端定义一个全局的角色列表和权限列表，并在后端进行相应的验证和授权，来实现RBAC模型的安全管理。

#### 4. 路由的高级使用，例如不匹配时定向404页面

利用*匹配剩余的所有路径

或者在路由守卫中先获取到了路由所有可达的路径，然后和当前的to做比较，如果存在则正常，不存在则前往404

性能其实差别不大，都是非常快速的操作。不过，我们应该避免在路由守卫中进行复杂的计算和查询操作，以免影响页面的加载速度和用户体验。

#### 5. 安全，防止信息泄漏与XSS，CSRF攻击

在信息保密上我们作为一个服务端渲染项目，会由后端加载好html页面再在前端进行加载，这就首先从一定程度上避免了数据通信的泄漏，为了保护用户信息我们也是在排行榜、个人界面等内容进行了打码处理，为了防止被搜索引擎直接捕获用户的个人界面，也是利用robots进行一些配置。

为了表达对用户的尊重，我们在数据传输过程中也会对用户的敏感信息，例如密码进行哈希加密，以密文形式保存在数据库中，当用户登录时也会首先对密码进行哈希处理，然后再和数据比较判断。

为了避免注入攻击，我们使用了现有的markdown组件进行，做了内容过滤和转义，具体操作如下：

在发送到后端的时候前端首先会对一些特殊内容进行替换过滤：
使用内置函数进行HTML转义
在JS中，可以使用一些内置函数来进行转义，例如：

```javascript
function escapeHtml(text) {
  var map = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;'
  };
  return text.replace(/[&<>"']/g, function(m) { return map[m]; });
}
```

但其实攻击者可以绕过前端校验直接向后端发送请求，因此前端也是放不住的，只能对通过表单提交的信息象征性的进行处理

进而由后端对代码中可能造成数据库操作的方法进行进一步处理；（后端都会对数据进行转义，来放置对数据库产生影响）

前端防止注入：我们选择的markdown组件也有这个功能，可以防止script之类语句的执行，前端的\{\{\}\}差值表达式也会自动对内容转为字符串

## Facelook

### 1. python客户端项目常见设计模式的应用（包括工厂模式，传输链模式）

#### 1. 工厂模式

在Python客户端项目中，常常会使用工厂模式来创建和管理对象，以便在运行时能够动态地创建和管理不同类型的对象。

工厂模式通常用于创建复杂的对象，尤其是那些需要按照特定顺序组装的对象。

首先声明基础的组件类型，然后声明对应的工厂函数，内部对不同的组件进行类型的划分，便于基于用户选择返回对应的组件

#### 2. 传输链模式

主要用于实现请求处理流程，以便让请求对象能够按照一定的顺序经过多个处理对象进行处理。

传输链模式通常用于将请求和处理对象解耦，从而使得请求处理流程更加灵活和可扩展。

可以将请求在多个处理器之间传递，直到找到能够处理请求的处理器为止。在Python客户端项目的组件库搭建中，传输链模式可以用来处理请求，使得不同的请求可以被不同的处理器处理，从而实现更加灵活的组件库设计。

类似于装饰器？

流程如下：

1. 定义请求处理器类。首先需要定义一个抽象基类或接口，用于规范请求处理器的行为。所有的请求处理器都需要继承这个基类或实现这个接口，并且实现处理请求的方法。

2. 实现请求处理器类。针对具体的请求类型，需要实现对应的请求处理器类，继承抽象基类或实现接口，并实现处理请求的方法。处理器类之间需要以传输链的方式相互连接起来，即每个处理器都需要有一个指向下一个处理器的引用。

3. 将请求发送到传输链的起点。将请求发送到传输链的起点，即第一个处理器。每个处理器会依次处理请求，如果某个处理器不能够处理请求，则会将请求传递给下一个处理器，直到找到能够处理请求的处理器为止。

例如首先定义了一个抽象基类RequestHandler，用于规范请求处理器的行为。

然后分别实现了HttpRequestHandler、WebSocketRequestHandler和TcpRequestHandler三个具体的请求处理器类，分别用于处理HTTP请求、WebSocket请求和TCP请求。

这些处理器类之间以传输链的方式相互连接起来，即每个处理器都有一个指向下一个处理器的引用。

最后，定义了一个ComponentRequestHandler类，用于管理请求处理器链，并将请求发送到链的起点，即HttpRequestHandler处理器。

### 2. python客户端架构设计的深入学习

#### 1. 分层架构设计

在构建一个 python 客户端项目时，建议采用分层架构设计，将整个应用分为多个层级，每个层级都有特定的职责和功能。常见的分层架构包括三层架构和四层架构，其中：

三层架构包括表示层、业务逻辑层和数据访问层，每一层都有自己的职责和输入输出。

四层架构基于三层架构，增加了一个服务层，负责业务逻辑的处理和调用，从而降低了表示层和数据访问层之间的耦合度。

采用分层架构设计的好处在于，可以提高代码的可维护性和可扩展性，降低不同层级之间的耦合度，同时也方便进行单元测试和集成测试。

#### 2. 引入设计模式

在 python 客户端项目中，常用的设计模式包括工厂模式、单例模式、观察者模式、代理模式等等。引入这些设计模式可以提高代码的可重用性和可维护性。

例如，可以使用工厂模式来创建对象，避免在代码中直接使用 new 关键字创建对象，从而降低代码之间的耦合度。

同时，通过单例模式可以确保一个类只有一个实例，并且可以在多个地方进行共享，减少资源的占用和浪费。使用观察者模式可以方便地实现事件的处理和消息的通知，使得不同组件之间的协作更加灵活和高效。

#### 3. 面向接口编程

在 python 客户端项目中，建议采用面向接口编程的方式，将不同组件之间的依赖关系抽象出来，从而提高代码的可维护性和可测试性。

通过定义接口规范，可以方便地进行依赖注入和模拟测试，同时也可以降低代码的耦合度，提高代码的复用性。

#### 4. 使用异步编程模型

对于需要处理大量并发请求的 python 客户端项目，建议使用异步编程模型，例如 asyncio 和 aiohttp 等。

异步编程模型可以提高应用的性能和吞吐量，减少资源的占用和浪费。同时，也可以简化代码的编写和维护，降低代码的复杂度和难度。

#### 5. 日志记录和监控

日志记录和监控可以帮助我们快速定位和解决问题。Python中的一些常用日志记录和监控库包括Logbook，Sentry和ELK等。

### 3. 基于pygame框架从原始组件开始搭建，直到渲染整个页面（类似前端组件库的搭建）

确定需求：首先需要明确聊天系统的功能需求，例如文字、图片的显示、聊天记录的存储、用户的登录注册等。

设计界面：在明确需求的基础上，设计出聊天系统的界面，包括窗口、按钮、输入框、显示框等组件的位置、大小、颜色等属性。

设计属性和数据结构：利用model定义一些实体的属性和方法，便于后续的使用，主要设计用户、消息、请求；利用config设置一些状态的参数，基于python的类实现了类似枚举的结构。

开发组件：
我们首先设计了最基础的组件，类似于浏览器中的dom对象，他的属性如下：

```python
def __init__(self, process):
    self.childs = []
    self.state = 0
    self.counter = 0
    self.surface = None
    self.process = process
    self.active = True
    self.data_version = 0
```

并且包含发起事件，刷新页面内容等接口函数，便于后续重写。

进而我们对于文字、图片的显示组件，都在element类的基础上实现

进而根据设计好的界面，开发相应的组件，再根据需求，将组件进行组合，实现相应的功能。例如，将文字、图片的显示组件放置到聊天记录的显示框中，实现聊天记录的实时更新；实现用户的登录注册功能等。

测试与优化：在完成开发后，进行系统测试，确保系统功能正常，并进行必要的优化，提高系统的性能和稳定性。

### 4. 基于python的websocket的使用（其实没有）

选择一个适合的Python WebSocket库，比如Tornado、websocket-client等。

根据WebSocket库的文档，使用Python编写一对一和多对多通信的代码逻辑。在实现私聊和群聊功能时，可以使用WebSocket的特性，例如通过自定义消息类型来标记不同的聊天类型。

在客户端界面中添加私聊和群聊的UI组件，例如文本框和发送按钮。

实现客户端向服务器发送消息的功能。可以在UI组件的事件回调中，调用WebSocket的发送函数，将消息发送到服务器。

实现客户端接收服务器消息的功能。可以通过WebSocket的消息回调函数，将收到的消息显示在客户端的聊天界面上。

针对多对多通信，需要考虑如何实现消息的广播和分组。可以通过在消息中添加接收方的信息，或者在服务器端进行分组处理。

服务端群聊分组：
在服务器端使用数据库来存储群聊的相关信息，如群聊成员列表、群聊名称、群聊ID等。可以使用MySQL、PostgreSQL等关系型数据库，也可以使用MongoDB等非关系型数据库。

具体实现时，可以创建一个数据库表来存储群聊信息，包括群聊ID、群聊名称、创建时间等字段。同时，还需要创建一个表来存储群聊成员信息，包括用户ID、群聊ID、加入时间等字段。

当有用户创建群聊时，可以向数据库中插入一条群聊记录，并在群聊成员表中插入一条记录，表示该用户是该群聊的创建者和成员。其他用户加入群聊时，也需要向群聊成员表中插入一条记录。

在实现群聊消息的广播时，可以通过WebSocket将客户端发送的消息发送到服务器端。服务器端可以根据消息中的群聊ID查询数据库中的群聊成员信息，从而找到所有在该群聊中的成员，进而进行消息的广播。具体实现时，可以使用Python中的Web框架，如Flask、Django等，结合WebSocket库，如WebSocket-Server、Tornado等来实现。

### 5. 基于tcp实现聊天系统的私聊和群聊功能

建立服务器：使用 Python 中的 socket 模块建立一个 TCP 服务器。

客户端连接服务器：客户端使用 socket 模块连接到服务器。

实现私聊：客户端之间可以建立独立的连接，因此你可以在客户端之间建立一个私有的连接来实现私聊功能。

实现群聊：你可以在服务器上维护一个列表，存储所有已连接的客户端套接字，当有一个客户端发送消息时，服务器可以将消息发送给所有客户端。

在实现私聊和群聊时，你需要考虑数据的格式和传输方式。可以定义一个协议，用于规定消息的格式，例如可以定义消息头，用于标识消息的类型和长度，然后在消息体中包含具体的内容。

总的来说，使用 TCP 套接字可以实现一个简单的聊天系统，可以满足基本的私聊和群聊需求。

## vue2 项目

### 糖帮

对前端架构的一次全面深入（router、plugin、store、组件声明与使用）

#### 1. 基于ESlint+Prettier格式化

安装ESlint和Prettier，可以使用npm或yarn进行安装
配置ESlint和Prettier，可以使用官方推荐的默认配置，也可以根据项目需求自定义配置

集成ESlint和Prettier到项目中，可以使用编辑器的插件或者通过命令行工具来进行格式化和自动修复代码

在开发过程中，建议使用编辑器的实时代码检测功能，确保代码风格符合规范

#### 2. 通过路由守卫+JWT管理权限

安装JWT库，可以使用jwt或jsonwebtoken等库

在后端生成token并返回给前端，在前端存储token，这里存储在了localstorage中，并在vuex中利用jwtoken字段进行辅助，判断当前状态是否有token存在，具体是什么

配置路由守卫，根据需要可以对所有路由或者部分路由进行权限控制，对于需要控制权限的路由，如果用户未登录或者token无效，则跳转到登录页面或者提示用户无权限

在后端验证token的有效性，根据需要可以对所有API或者部分API进行权限控制，对于没有权限的API请求，可以返回错误信息或者提示用户无权限

#### 3. 整体的Restful接口设计

```ts
url: `/group/create`,
url: `/group/index`,
url: `/group/MyIndex`,
url: `/group/${id}`,
url: `/group/join/${groupId}`,
url: `/group/quit/${groupId}`,
url: `/group/search/${groupName}`,
url: `/discussions/group/${groupId}`,
url: `/discussions`,
url: `/discussions/${discussionId}`,
url: `/discussions/search/${title}`,
url: `/discussions/groupAndUsername/${groupId}`,
url: `/discussions/edit/${id}`,
url: `/discussions/${id}`,
url: `/comments/at/${discussionId}`,
url: `/comments/create`,
url: `/comments`,
```

#### 4. 基于axios库的API封装方法

使用axios库可以方便地发送HTTP请求并处理响应。但是，每个请求都需要手动设置参数并处理响应，会显得很冗余。因此，可以封装一个API请求方法来简化这个过程。

创建一个API模块，命名为api.js（或其他自己喜欢的名称），用于存放所有API请求方法。

在api.js中导入axios库：import axios from 'axios';
创建一个axios实例，用于全局配置请求参数（如baseUrl、header、timeout等）：

按照不同api所述的模块划分多个请求汇总文件，例如comment，group，分别在内部创建有关的API请求方法
在需要使用API的地方导入该模块，并调用相应的方法

同时对于http请求存在着url字符串传参的情况，此时我们会首先利用反引号进行变量和url的拼接，并且利用qs库的stringify转换函数来进行处理，确保data中的复杂数据可以被发送

#### 5. 响应式布局（整体采用flex，一些地方针对不同设备设置不同长宽）

vuetify提供了一些常用的布局组件，例如Grid System，可以让开发者方便地实现响应式布局。开发者可以使用v-bind指令绑定组件的属性值，实现根据设备类型设置不同的长宽等参数

使用:cols、:sm、:md、:lg等属性，根据设备类型设置不同的列数，:width属性则根据设备类型设置不同的长宽。

\$vuetify.breakpoint.mdAndUp是vuetify提供的一种响应式布局方法，表示当前设备宽度在md尺寸及以上。

#### 6. 工具模块的封装定义和使用

在前后端分离的web项目中，通常会有许多公共的工具模块需要被使用，例如常用的字符串处理、日期处理、加解密算法等等。为了方便代码复用和维护，我们可以将这些常用的工具封装成模块，然后在项目中引入使用。

我们主要分为几个工具模块，格式模块、全局消息模块、ui模块：

格式工具包含了qs对字符串对象转换方法的获取和export，同时主要包含了日期格式从时间戳到中文的现实处理，基于prototype的format方法重写实现

全局消息工具通过引入vuetify的snackbar组件，利用vuex对snackbar的内容和颜色进行管理，该工具组件相当于封装了snackbar的一些方法，相当于单例模式，在不同页面中我们只需要基于这一个snackbar进行消息提示即可。

ui模块主要提供了标题修改、头图修改等功能，便于美化时的使用。

### techshare

#### 1. 基于vuetify组件库的行列布局实现响应式布局

在Vue项目中，使用vuetify组件库可以快速构建具有响应式布局的UI界面。其中，v-container和v-row、v-col组合是最常用的布局方式。

具体地，v-container组件用于包含内容，并设置它的最大宽度。v-row组件用于包含一行中的所有列，并可以设置一些全局的布局属性，例如justify、align等。v-col组件用于定义每一列的宽度和偏移量。

v-col组件分别设置了xs、sm、md、lg四个属性，表示在不同设备上，每个列应该占的长度

Vuetify通过监听浏览器窗口大小变化来自动调整每个列所占的宽度。具体实现是使用了Vue的watch功能，当浏览器窗口大小发生变化时，Vuetify会重新计算每个列所占的宽度，并将其更新到DOM中，从而实现自适应布局

内部使用了CSS媒体查询来检测屏幕尺寸的变化，并根据不同的媒体查询条件来应用不同的CSS样式，以达到响应式布局的效果

Vuetify 通过使用 Vue 的 watch 功能来监听浏览器大小变化。具体来说，Vuetify 在 v-resize 组件内部创建了一个名为 windowResizeHandler 的函数，在v-resize组件渲染时将该函数注册到了浏览器的 resize 事件中。

当浏览器的窗口大小发生变化时，该函数就会被触发。在函数中，Vuetify 通过 window.innerWidth 获取当前窗口的宽度，然后根据当前的屏幕尺寸（即 xs, sm, md, lg 和 xl）以及每个列的 cols 属性计算出每个列应该占据的宽度比例，并将结果保存在组件的状态中。

最后，Vuetify 通过计算属性或者直接绑定样式来将计算得到的宽度比例应用到每个列上，从而实现响应式布局。

但是对于断点breakpoint的更新，是通过vue-match-media插件来检测媒体查询的结果，并根据不同的断点值修改组件的属性的，使用$vuetify.breakpoint.name来获取当前的断点名称，使用$vuetify.breakpoint.width来获取当前设备的屏幕宽度，以便根据不同的情况来定制组件的样式和行为

Bootstrap 中的响应式断点是基于屏幕宽度来定义的，即当屏幕宽度达到特定值时，Bootstrap 会自动应用相应的样式，以适应不同的屏幕大小。具体的断点值是在 Bootstrap 样式表中定义的

Vuetify 中的断点则是根据设备的类型（如手机、平板、台式机等）来定义的，Vuetify 提供了一系列用于响应式设计的内置组件和样式类，可用于针对不同的设备类型应用不同的样式。

#### 2. web项目中的表单搭建与统一验证管理

因为该项目涉及到论文的上传，专家认证等需要很多内容填写的情况，因此需要比较多的表单来进行管理

一个好的表单搭建与验证管理可以提高开发效率和用户体验。以下是一些具体的改进方式和规范。

1. 表单搭建

    表单搭建通常包括两个部分：表单元素和表单布局。对于表单元素，我们可以使用一些开源的表单库来快速地构建表单元素。例如，Element UI和Ant Design Vue都提供了丰富的表单元素组件，可以快速搭建表单。

    对于表单布局，我们可以使用CSS Grid或Flexbox来实现布局。CSS Grid和Flexbox都可以实现响应式布局，并且可以实现复杂的布局效果。

2. 表单验证

    对于表单验证，我们继续使用了vuetify的验证函数，我们可以在增加表单元素时声明对内容的要求，进而只需通过自带的验证器来看是否符合规定，例如必填项验证、正则表达式验证、长度验证等。

3. 统一验证管理

    对于表单验证，我们可以实现统一的验证管理。

    即对于当前表单中的元素会自动进行内容的获取和判断，当验证通过才发送请求给后端，否则会调用不符合要求的组件的验证不通过的方法，显示他的报错提示。

#### 3. vue-router中各种路由参数的灵活使用，基于meta重定向

1. 制定路由参数规范

    为了在vue-router中更好地使用路由参数，我们可以先制定一套规范，例如每个路由都必须指定一些必要的参数，例如id等。这样可以减少路由参数的混乱，并且方便开发者之间的交流。

2. 使用路由导航守卫

    vue-router提供了路由导航守卫，我们可以在路由跳转前或者后进行一些操作。例如在路由跳转前可以进行一些参数验证，确保参数的正确性；在路由跳转后可以进行一些数据的处理，例如请求接口，更新数据等。

3. 基于meta重定向

    使用基于meta的重定向可以更好地控制页面的跳转。我们可以在路由跳转前先判断meta中是否包含了redirect字段，如果包含了，我们就直接重定向到指定的页面，这样可以更好地避免页面跳转的混乱。

    通过meta指定当前路由的辅助信息，例如是否需要验证，是否需是专家，进而结合路由守卫进行快速处理。

#### 4. 内容筛选器的使用

当我们显示搜索结果或者详情时，需要对大段的文字进行截断，一般的css方法有设置溢出隐藏，末尾用省略号表示的方法，例如下列方法：

css中的解决：

1.text-overflow
text-overflow属性可以用来控制文本溢出时的显示方式。其中，ellipsis表示显示省略号，clip表示直接裁剪，string值表示可以自定义溢出时的显示字符串。

2.word-wrap
word-wrap和word-break属性也可以用来解决文本溢出的问题。其中，word-wrap用来控制单词内部的换行，而word-break则是用来控制单词间的换行。通过这两个属性可以实现文本的自动换行，从而避免出现溢出的情况。

但是为了减少对css的使用，我们使用了自定义过滤器的方式
当然也使用vue的计算属性

我们可以使用vue的计算属性来进行内容筛选器的使用。在计算属性中，我们可以根据条件过滤需要展示的数据，并且不会对原始数据产生影响。

我们使用的自定义过滤器

除了使用计算属性，我们还可以自定义过滤器来进行内容的筛选。自定义过滤器可以接受一个参数，例如搜索关键词，并且返回一个过滤后的结果。

通过给过滤器一个参数，可以实现不同需求下截断字符串的长度，非常好用。

最原始的方案：利用js获取文本和元素的宽度，当宽度过长时利用ellipsis隐藏文本

### Beacon

#### 1. 小组任务分配与结对编程

定义任务：在开始任务前开启动会，小组应该共同确定任务的具体目标，明确任务的分工以及完成时间节点，通过共享文档库明确大家的情况，确保每个人都清楚自己的任务职责和完成标准。

每日Scrum：每日Scrum是敏捷开发中常用的日常管理方式，可以在小组成员每天固定时间进行，每个人简要介绍自己昨天完成的任务、今天要完成的任务、以及遇到的困难，讨论后续计划，以及是否需要调整任务分配和优化流程等。

对于我们的瀑布模型，由于大家课程也比较多，因此采取了每周一检查的情况。

结对编程：结对编程是一种在团队中两个程序员协同工作的方法，可以增加代码质量和开发效率。

结对编程可以提高代码质量、减少错误，还可以让团队成员相互学习和沟通，增加协作效率。

#### 2. video标签的基础使用

使用video标签，我们可以通过以下方式进行基础使用：

在template中使用video标签，设置src属性为视频文件地址，可以直接在页面上显示视频。

通过设置video标签的属性，可以设置视频的宽高、自动播放、循环播放等。

controls属性可以显示视频播放控制条，用户可以通过控制条来控制视频播放暂停、音量、快进等操作。
自定义控制条样式，可以使用JavaScript来实现

```ts
<video id="my-video" src="example.mp4"></video>

<script>
var video = document.getElementById('my-video');
var playBtn = document.getElementById('play-btn');
var progressBar = document.getElementById('progress-bar');

playBtn.addEventListener('click', function() {
    if (video.paused) {
    video.play();
    playBtn.innerText = 'Pause';
    } else {
    video.pause();
    playBtn.innerText = 'Play';
    }
});

video.addEventListener('timeupdate', function() {
    progressBar.value = video.currentTime / video.duration;
});
</script>

```

在这个例子中，实现了一个播放/暂停按钮和一个进度条，通过JavaScript控制video标签的播放状态和进度条的进度

#### 3. vue-router配置路由子路由

在Vue中，我们可以使用vue-router库来管理前端路由，实现SPA（单页应用程序）。而在实际开发中，常常会涉及到嵌套路由（子路由），这时我们就需要使用vue-router的子路由配置功能。

我们在课程界面利用嵌套路由实现了内部的讨论区、课程学习等界面的切换。

直接基于children进行切换，自组件通过路由中获取id信息便可进行有关信息的获取。

#### 4. vue-router实现路由懒加载

路由懒加载是指在路由被访问时才加载对应的组件，可以大幅度缩短页面的加载时间，提高用户体验。

在Vue.js中，我们可以通过Webpack的code splitting功能来实现路由懒加载。具体的实现步骤如下：

1. 在router.js文件中，使用import()语法动态导入组件，而不是提前加载好所有页面，然后指定component

2. 将Webpack的chunkFilename选项设置为动态命名
这个例子中，我们将chunkFilename选项设置为'\[name].
\[chunkhash].js'，表示将动态导入的组件保存为动态命名的文件
会生成单独的js文件，这些js文件会在需要时进行动态加载，从而提高了页面加载速度和性能。
但是这种使用路由懒加载会增加打包文件的大小，因为每个动态chunk都需要包含被加载的组件的代码和依赖关系。
如果不配置，打包时仍然会只打包一个文件夹，还是需要下载更多的文件，但是在开发环境下可以提高启动速度，可以让webpack之家在需要的代码。

#### 5. 基于js的文件上传与发送后端

我们的方案是基于form-data的http请求创建一个input元素，设置type属性为file，让用户可以选择要上传的文件。
通过JavaScript获取用户选择的文件，使用FormData对象将文件数据封装成表单数据，使用XMLHttpRequest发送请求，并监听上传进度和上传结果。

后端接收表单数据，将数据解析成文件，保存到服务器指定的位置。

简单的示例代码：

```ts
<template>
    <div>
    <input type="file" ref="fileInput" @change="uploadFile">
    </div>
</template>

<script>
export default {
    methods: {
    uploadFile() {
        const fileInput = this.$refs.fileInput
        const file = fileInput.files[0]
        const formData = new FormData()
        formData.append('file', file)
        const xhr = new XMLHttpRequest()
        xhr.open('POST', '/api/upload')
        xhr.upload.addEventListener('progress', (event) => {
        if (event.lengthComputable) {
            const percentComplete = event.loaded / event.total * 100
            console.log(percentComplete)
        }
        })
        xhr.addEventListener('load', () => {
        console.log(xhr.responseText)
        })
        xhr.send(formData)
    }
    }
}
</script>

```

##### 其他方法上传文件

此外当然也有一些替代方法，具体如下：

Base64 方式上传：将文件内容进行 Base64 编码，然后将编码后的字符串作为参数发送给服务器，服务器接收到参数后进行解码即可得到文件内容。

这种方式可以在不支持文件上传的场景下实现文件上传，但会造成数据传输量的增大，而且无法上传大文件。

使用第三方云服务：可以使用第三方云服务，如阿里云、七牛云等，提供的文件上传 API 来实现文件上传。这种方式可以实现高效的文件上传和存储，但需要付费，并且需要与第三方服务商进行集成。

#### 6. 大文件的切片多线程上传

切片上传的基本思路是将大文件分割成若干个小文件进行上传，最终在服务端将这些小文件合并成一个完整的大文件。

具体实现可以通过以下步骤进行：

客户端将大文件按照指定大小分割成若干个切片。

客户端通过 HTTP 协议将这些切片上传到服务端，每个切片都有自己的索引和唯一标识。

服务端接收到切片后，将它们存储到磁盘上，以便后续进行合并操作。

客户端上传完所有切片后，向服务端发送一个请求，告诉服务端所有切片已经上传完毕。

服务端收到这个请求后，将存储在磁盘上的切片合并成一个完整的大文件。

需要注意的是，切片上传的方案也会带来一些新的问题，例如切片上传过程中可能会出现网络中断、服务器宕机等问题，我们需要对这些情况进行特殊处理，保证上传的稳定性和可靠性。

此外，为了提高上传速度，我们还可以考虑使用多线程上传的方式。多线程上传可以将一个文件分割成若干个线程同时上传，以提高上传速度。

```ts
const fs = require('fs');
const path = require('path');
const request = require('request');

const filePath = path.join(__dirname, 'test.mp4'); // 待上传的文件路径
const fileSize = fs.statSync(filePath).size; // 获取文件大小
const chunkSize = 1024 * 1024 * 2; // 每个切片的大小为2MB
const totalChunks = Math.ceil(fileSize / chunkSize); // 计算总共需要上传的切片数量

// 切片上传
function uploadChunk(chunkIndex) {
  const start = chunkIndex * chunkSize;
  const end = Math.min(start + chunkSize, fileSize);
  const formData = {
    chunkIndex,
    totalChunks,
    file: fs.createReadStream(filePath, { start, end }),
  };
  request.post({
    url: 'http://example.com/upload',
    formData,
  }, (error, response, body) => {
    if (error) {
      console.error(`Failed to upload chunk ${chunkIndex}: ${error}`);
    } else {
      console.log(`Uploaded chunk ${chunkIndex}: ${body}`);
    }
  });
}

// 多线程上传
function uploadFile() {
  for (let i = 0; i < totalChunks; i++) {
    uploadChunk(i);
  }
}

uploadFile();
```

##### 大文件的其他上传优化

1. 压缩文件

    对于一些文本文件，例如文本文档、CSV、XML等，可以先将其压缩成一个ZIP文件，然后再上传。这样可以减小文件大小，提高上传速度。

2. 上传速度限制

    可以限制文件上传的速度，防止服务器过载。一种方法是在前端限制上传速度，可以使用JavaScript实现。另一种方法是在后端实现上传速度限制，例如使用NGINX进行限速。

3. 多线程上传

    使用多线程上传可以加速文件上传的过程。将一个大文件分成多个块，然后使用多个线程同时上传这些块。这样可以提高上传速度，但同时也需要考虑到服务器的承载能力。

4. P2P 方式上传

    使用 P2P 技术实现文件的分片上传，将文件分成若干个块，然后使用 P2P 技术将文件块上传到其他用户的客户端，其他客户端将收到的文件块上传到服务器上，服务器接收到所有块后进行合并。这种方式可以实现高效的文件上传和分发，但需要客户端进行相应的支持

##### 涉及到的http头部字段

Content-Type：指定上传文件的类型。例如，对于图片文件，Content-Type 可以设置为 image/png 或 image/jpeg 等。

Content-Length：指定上传文件的大小，以字节为单位。在切片上传中，需要根据每个切片的大小累加计算出整个文件的大小，并设置 Content-Length 字段。

Content-Disposition：指定上传文件的文件名。可以设置为 inline 或者 attachment。inline 表示在浏览器中显示，attachment 表示提示下载。

Range：指定上传文件的起始位置和结束位置，以字节为单位。在切片上传中，可以使用 Range 字段指定每个切片的起始位置和结束位置。

Accept-Ranges：指定服务器支持断点续传。在切片上传中，服务器需要返回 Accept-Ranges: bytes 字段，表示支持以字节为单位的范围请求。

If-Match：用于条件请求，指定上传文件的 ETag 值。在切片上传中，可以使用 If-Match 字段指定上传的文件的 ETag 值，以保证上传的文件是最新的版本。

If-Range：用于条件请求，指定上传文件的起始位置和结束位置。在切片上传中，可以使用 If-Range 字段指定上传文件的起始位置和结束位置，以保证上传的文件是最新的版本。

Content-Range：指定上传文件的范围。在切片上传中，服务器需要返回 Content-Range 字段，指定上传文件的范围。


一般也会使用一些自定字段来便于处理：

```js
const file = document.getElementById('file-input').files[0];

const CHUNK_SIZE = 1024 * 1024; // 每个切片的大小（1MB）

let startByte = 0;
let endByte = CHUNK_SIZE;

while (startByte < file.size) {
  const chunk = file.slice(startByte, endByte); // 切片文件
  const xhr = new XMLHttpRequest();
  xhr.open('POST', '/upload', true);

  xhr.setRequestHeader('Content-Type', 'application/octet-stream');
  xhr.setRequestHeader('X-File-Name', file.name);
  xhr.setRequestHeader('X-File-Size', file.size);
  xhr.setRequestHeader('X-Start-Byte', startByte);
  xhr.setRequestHeader('X-End-Byte', endByte);

  xhr.onreadystatechange = function() {
    if (xhr.readyState === 4 && xhr.status === 200) {
      console.log('Uploaded ' + chunk.size + ' bytes.');
    }
  };

  xhr.send(chunk);

  startByte = endByte;
  endByte = Math.min(endByte + CHUNK_SIZE, file.size);
}
```

使用了如下的头部字段：

Content-Type: 用于指定上传文件的 MIME 类型。
X-File-Name: 用于指定上传文件的文件名。
X-File-Size: 用于指定上传文件的大小。
X-Start-Byte: 用于指定当前切片在文件中的起始字节位置。
X-End-Byte: 用于指定当前切片在文件中的结束字节位置。
同时，在服务端，我们使用了 HTTP Range 头部字段来实现文件的切片上传功能。

基于规范头部字段请求

```js
async function uploadSlice(file, url, startByte, endByte) {
  const headers = {
    'Content-Type': 'application/octet-stream',
    'Content-Range': `bytes ${startByte}-${endByte}/${file.size}`
  };
  const slice = file.slice(startByte, endByte + 1);
  const response = await fetch(url, {
    method: 'PUT',
    headers,
    body: slice
  });
  return response;
}

async function uploadFile(file, url, chunkSize = 1024 * 1024) {
  const sliceCount = Math.ceil(file.size / chunkSize);
  let sliceIndex = 0;
  for (let startByte = 0; startByte < file.size; startByte += chunkSize) {
    const endByte = Math.min(startByte + chunkSize - 1, file.size - 1);
    const response = await uploadSlice(file, url, startByte, endByte);
    if (response.ok) {
      sliceIndex++;
    } else {
      return response;
    }
  }
  return response;
}
```

#### 7. 文件浏览速度缓慢问题

网课平台：如何优化视频的加载速度和播放体验

对于大尺寸的视频文件，可以通过压缩技术进行压缩，减小视频文件的大小，从而降低加载时间。常用的视频压缩格式有H.264、H.265等。

用流媒体技术可以让视频文件像流一样被传输，不需要等到整个视频文件下载完毕才能开始播放，这样可以提高视频的加载速度和播放体验。常用的流媒体技术有HLS、RTMP、WebRTC等。

如何在前端视频播放时使用流媒体技术来优化速度，可以使用HLS（HTTP Live Streaming）协议来实现，具体步骤如下：

将视频分成多个TS（Transport Stream）分段。

使用M3U8文件来描述分段视频文件的列表，M3U8文件可以通过HLS流式传输。

在前端使用video标签来播放视频，并指定M3U8文件的URL。

HLS协议的优点在于可以根据当前的网络情况和带宽自动切换视频质量和分辨率，从而保证流畅的视频播放体验。

### ucloud

#### 1. 后台Docker运行情况与前端的同步

可以使用Websocket协议在前端和后台之间建立实时通信，以便及时获取Docker运行情况的变化。当Docker运行状态发生变化时，后台通过Websocket将变化的数据实时推送给前端，前端接收到推送后更新相关的界面显示即可。

另外，可以在后台部署Docker容器时，将Docker的运行日志输出到一个指定的文件中，前端通过定时向后台发送请求获取该文件的内容，从而获取Docker运行情况的变化。

具体实现时，可以使用Node.js的fs模块读取该文件的内容，并通过API接口将内容返回给前端。

我们采取的方案是后者，即前端会通过http请求去尝试获取日志文件的内容，并且定期刷新

#### 2. 基于flex实现自适应布局

可以使用CSS的flex布局来实现自适应布局。flex布局是一种弹性盒子布局模型，通过设置容器的display属性为flex，即可将其内部的子元素按照一定的比例分配空间，实现自适应布局。

具体实现时，可以使用flex布局来设置容器的各项属性，例如flex-direction、justify-content、align-items、align-content等属性来控制容器内部子元素的布局方式和位置。

此外，为了适配不同的屏幕大小和设备类型，可以使用媒体查询来设置不同的样式规则。

媒体查询可以根据屏幕的宽度和高度等参数来判断当前设备的类型和屏幕尺寸，并根据需要加载不同的样式文件或样式规则，从而实现不同设备类型的适配。例如：

## 小程序

### 权益菌

#### 1. webview能力的感慨

微信小程序中的webview是基于webview组件实现的，它提供了一种在小程序中展示网页的方式，类似于在原生应用中打开一个网页。在小程序中使用webview，需要注意以下几点：

webview的域名需要在小程序的合法域名列表中；
webview的安全域名需要在小程序的request合法域名列表中；
webview页面中的资源请求也需要在小程序的合法域名列表中

微信小程序中的webview是一个容器组件，用于展示Web页面或H5应用。它的实现原理可以大致分为以下几个步骤：

1. 微信小程序开发框架会将webview组件的url地址转换成一个特殊的scheme格式，例如：weixin://dl/business/?appid=12345678&url=\<http://www.example.com\>，其中url参数就是要展示的H5页面的地址。

2. 微信客户端接收到这个特殊的scheme地址后，会调用系统内置的WebView控件加载这个url。

3. 当WebView控件加载完毕后，微信客户端会将WebView的渲染结果截图，并将截图传递给小程序开发框架。（这里的截图其实是指网页快照，也就是不会实时更新的，当用户滑动时其实就是在不停的渲染这个网页快照的剩余部分）

4. 小程序开发框架会将这个截图展示在小程序的webview组件上，从而实现了H5页面在小程序中的展示。

这种基于网页快照的加载方式可以减少客户端的资源占用，提高小程序的性能和用户体验.
但注意，webview组件运行在一个独立的沙箱环境中，它不能直接访问小程序的JavaScript环境，也不能直接调用小程序的JavaScript方法。
因此，在webview组件中运行的H5页面，如果需要与小程序进行交互，必须通过特定的API接口来实现。

#### 2. NoSQL的初步了解

NoSQL是Not Only SQL的缩写，指的是一类非关系型数据库。

相对于传统的关系型数据库，NoSQL具有以下几个特点：
不需要固定的表结构，可以灵活地存储非结构化数据；
不需要使用SQL语句进行数据操作，可以使用各种编程语言和API进行操作；

可以分布式存储和处理数据，具有较好的扩展性和容错性。
一些常见的NoSQL数据库包括MongoDB、Cassandra、Redis等。

#### 3. 微信小程序使用云数据库

微信小程序提供了云开发能力，其中包括云数据库。云数据库是基于MongoDB协议的NoSQL数据库，可以在小程序中方便地使用。

开发后端接口的步骤如下：
在小程序中创建云开发环境，并创建云数据库；
在小程序代码中引入云开发的API，并连接云数据库；
在云函数中编写需要的接口逻辑，并对数据库进行增删改查等操作；
在小程序中调用云函数，获取后端数据并展示在页面中

小程序的数据获取便是基于promise进行的封装，可以通过then进行获取数据的处理。

### 偕行

从调研到开发的全过程模拟
从零开始策划到实现的流程

## 原生 HTML

### 初始网站

了解网站的开发方式

### 金融平台

大团队开发的痛苦
需要一个良好的团队氛围
