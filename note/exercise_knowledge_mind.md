# 刷题思想有关知识点全记录

## 算法

### 排序

排序操作在一些需要寻找最值的情况下比较常用
并且当在需要寻找最值时也应该首先尝试排序后再处理，会提高很多效率

#### 编程语言的排序

各个语言一般都有自己的排序函数，例如 js 的 arr.sort，python 的 sort 等等
这些排序的时间复杂度一般是：？？？

### 查找

#### 二分查找

二分查找适合任何有顺序的情况，因为他的复杂度低，一次可以筛选掉一半的元素
例如要寻找最值、判断某个元素是否位于一个序列中，只要有顺序，一般都会有二分的出现。

复杂应用：

1. 利用中值快速找到符合情况的数
   > 示例题目：1760. 袋子里最少数目的球
   > 二分查找找到的是作为情况判断的数字，来进行返回，例如找小于某个数的值，寻找某个值时能满足条件
   > 这里的能满足条件其实范围非常广，它可以是这个数在某个范围中，也可以是当是这个值时，能满足题目的要求，比如 1760 题目中
   > 需要尽可能的让拆分后的值最小，并给出了拆分次数的限制
   > 此时可以看出，要让拆分的值最小，寻找最值；并且拆分值小的同时，还需要满足拆分次数小于限制的情况
   > 那么很有可能就是二分，因此该题目中便需要去中分这个拆分的最小的值，然后基于这个值去看，要想拆分到这个值需要多少次操作，进而和操作次数比较，不满足条件则找更大的值，满足则找更小的值并记录下这个最小值

### 遍历

#### 子数组

##### 所有子数组

> 示例题目（假）： 力扣 6234. 最小公倍数为 K 的子数组数目，只是开始理解错以为是所有子数组

##### 连续子数组

### 动态规划

#### dp 的顺序

动态规划一般需要基于前面的来的到后面的，此时只需要正常 dp，即类似于前缀和，从前到后一点点动态即可

但对于有些题目，倒序更加利于寻找，比如按顺序选择，判断如何选择可以让选择的结果最大
此类题目一般在选择一个后需要暂缓一段时间才能选择下一个，因此如果从前向后便无法得到后面的最优解，为了解决这一问题便需要先动态我需要的，即后面的，因此便需要逆序 dp

> 示例简单题目：面试题 17.16. 按摩师

#### dp 数组的搭建

##### 定义

一般情况下 dp 的长度是和需要处理的数组相同的
定义后需要初始化，对一些边界值进行处理
也因此考虑到边界值的存在，有时需要对 dp 的大小进行扩增，一般扩增 1，扩增后可以直接通过循环初始化，比较便捷
示例如下：

```typescript
const prefix = new Array(n + 1).fill(0); // 记录前缀和，用于后续初始化dp数组
for (let i = 0; i < n; i++) prefix[i + 1] = prefix[i] + nums[i]; // 多初始化一位可以不用专门初始化第一位
const dp = new Array(n + 1).fill(0).map(() => new Array(k + 1).fill(0));
// k多声明一位便于理解
for (let i = 1; i <= n; i++) dp[i][1] = prefix[i] / i; // 0~i划分为1份时的平均值
```

上面的 prefix 和 dp 两个数组都扩增了一位用来记录
同时对于 dp 数组，还在二维数组进行了扩增，即 k+1，这是因为 k 在这里有一个次数的含义，因此+1 后脚标 i 对应的便是次数 k，在后续写程序时有助于自己的理解。

##### 优化

对于复杂 dp，通常需要定义一个很大的数组，但其实并不是所有情况下都需要高维，如果每次 dp 都只需要遍历自己的前一个值，那么其实对于这一维度便可将空间复杂度优化为 1，即只用一个数来保存即可

不过考虑到思路的连续性，不用一开始便考虑如何优化，可以写完代码后再根据代码的情况来做处理

同时优化后，因为维度之前的区分度被剥离了，如果按照原本的从前到后顺序处理 dp 数组，可能会出现污染上一次循环的数值的情况，此时便需要调整顺序，或者不优化。

> 优化示例题目：813. 最大平均值和的分组

#### 状态转移方程的搭建

##### 寻找比较的值

1. 简单情况：告诉方位
   一般来说 dp 是以之前计算的值为基础来进行进一步计算的，因此如何寻找这个基于的值是 dp 核心
   一般来说 dp 是以前一个或后一个为基础进行进一步运算，而当多了限制条件时则需要跳过一些值，例如三个之后的情况，或者两个之前的情况

上述情况都是对于不需要寻找，而是告诉了具体方位的

2. 复杂情况：需要寻找
   但大部分复杂情况下，这个要比较的值都是需要去循环判断的
   例如最长上升子序列，我要寻找比自己小的值，此时便需要循环去找

   > 示例题目：面试题 08.13. 堆箱子
   > 而一旦涉及循环，便可能出现超时的情况，因此需要根据情况来使用技巧

   即不要始终从靠近 dp\[i\]的地方开始
   有时候需要寻找平方值、最小的值，此时如果从 i 位置开始一个个找的话，很可能浪费很多无用的时间
   例如数组从小到大排序，那么要找最小的值，便可直接从脚标 0 开始找
   例如要寻找平方后等于自己的值，那么就应该使用二分的策略，才能最快找到符合条件的数

   > 示例题目：6258. 数组中最长的方波

#### 前缀和

#### 最长公共子字符串

### 贪心

### 广度优先算法 BFS

### 深度优先算法 DFS

## 数学

### 基础运算

即加减乘除

无论是 js 还是 ts，都有加减乘除不准的问题，这是由于底层是将数字转为二进制再计算，进而返回给用户时没有做好约分导致的

具体示例如下：

```typescript
console.log(2 - 0.3); // 1.7
console.log(0.7 - 0.4); // 0.29999999999999993
console.log(0.7 - -0.4); // 1.1
console.log(6 * 0.7); // 4.199999999999999
console.log(0.3 * 0.5); // 0.15
console.log(19.9 * 100); // 1989.9999999999998
console.log(3.1 + 0.2); // 3.3000000000000003
console.log(0.1 + 0.3); // 0.4
console.log(1.1 + 1.7); // 2.8
console.log(1.2 / 0.2); // 5.999999999999999
console.log(5.2 / 0.2); // 26
console.log(0.4 / 5); // 0.08
console.log(2 / 10); // 0.2
```

可以看出，可能是大，可能是小，比较棘手
问题会在某些情况出现，如果出现了此类问题，需要解决的方式有待研究

### 复杂运算

#### 幂运算

幂运算即某个数字若干次和自身相乘的运算

##### 题目结合

1. 运算优化类
   一般幂运算比较适合和运算优化类题目结合（保留 n-1 次幂，来快速得到 n 次幂）

2. 进制转化
   此外幂运算还和进制有着一定的关系
   例如如果某个数字可以拆分为 3 的 n 次幂之和（不重复），那么如果将该数字转为 3 进制的数字，这个 3 进制数字中一定只会出现 0 和 1，（3 进制不会出现 3，如果出现 2 就说明有重复的 3 的 n 次幂）

   > 示例题目：1780. 判断一个数字是否可以表示成三的幂的和

### 常见计算规律

#### 倍数

倍数的计算分为多种情况，分别的处理策略如下

1. 寻找恰好为 k 的倍数的数

   恰好倍数则需要取余 k 后结果为 0，进而再直接除法便可得到倍数

2. 对 num 寻找一个倍数 p 满足 p\*k<=num<(p+1)\*k

   此时相当于寻找一个\*k 还小于 num 的最大倍数
   相当于计算 num 中包含多少个完整的 k
   一般计算方法即直接根据除法结果向下取整，即 floor(num/k)，便可得到上述的最大倍数

3. 对 num 寻找一个倍数 p 满足(p-1)\*k<num<=p\*k

   和情况 2 类似，相当于找到一个\*k 大于 num 的最小倍数
   看起来只需要对情况 2+1 即可，但对于整除情况无法处理，会多一个无意义的 1
   因此需要使用一些技巧，即加上 k-1 然后再向下取整即可，即 floor((num+k-1)/k)，便可得到上述的最小倍数
   原理：相当于将恰好整除的情况独立出来，因为如果恰好整除，k-1/k 在向下取整后=0，不会多加 1；如果不整除，num 一定比 k 的倍数多至少 1，至多 k-1，那么加上 k-1 后就等于(k~k+k-2)/k，在向下取整后很显然都等于 1，符合对情况 2 的扩展

   > 示例题目：1785. 构成特定和需要添加的最少元素

#### 连续数的和

即 1 ～ n 的和，可知最简单的就是 n(n+1)/2
在判断的时候由于除法运算慢，因此可以将 2 转移到对比的另一侧进行，不过如果可能溢出则不能使用这一方法

除了从 1 加到 n，对于连续的若干数，他们的总和也很好计算
即中位数\*数量，中位数即中间脚标的数或者中间两个脚标的平均值
例如 3，4，5，6 的中位数 4.5\*4=18，2，3，4，5，6 的中位数 4\*5=20

反向推理，如何基于总和计算可能由哪些连续数组成，也可以倒推，即 num/n，n 不断减小，直到得到的值符合中位数规律即可

在得到中位数之后，便可直接基于脚标得到其他数，因为其他数和中位数的大小差恰好就是脚标差，对于偶数因为是 0.5，脚标也是 0.5，因此脚标相差也有 0.5，因此仍然得到的是正常的数，写成程序如下：

```typescript
// 对于中位数和长度i的关系，只有两种可能：要么整数且i为奇数，要么余0.5且i为偶数
let arr = Array(i)
  .fill(0)
  .map((_, index) => {
    return mid - (midI - index);
  });
// arr会成为一个中位数为mid，长度为i的连续数数组
```

#### 最大公约数

> 示例题目： 力扣 6234. 最小公倍数为 K 的子数组数目

```typescript
function gcd(a: number, b: number): number {
  return b !== 0 ? gcd(b, a % b) : a;
}
```

#### 最小公倍数

> 示例题目： 力扣 6234. 最小公倍数为 K 的子数组数目

需要结合最大公约数进行计算，即等于 a\*b 除以 a 和 b 的最大公约数

```typescript
function lcm(a: number, b: number): number {
  return Math.floor((a * b) / gcd(a, b));
}
```

### 位运算

位运算是对数字做的运算，和条件判断的&&和||有相似之处但是不是同一类运算符，需要注意

#### 应用场景

1. 使用二进制的每一位当作情况记录器

   二进制时每一位都只有 0 和 1，此时可以用 0 表示一个情况，1 表示另一个情况
   但是需要注意，二进制长度有限，不是所有情况都适用

   一般这种情况需要用&和|来进行情况的记录和调整

   并和全 0 或者全 1 进行有关的比较

   全 0:直接 0 即可
   全 1:直接将 1 左移 n+1 位，然后-1，便可得到 n 位的全 1

#### 特殊规则

1. 位运算优先级高

   位运算的优先级高于正常运算，即 n << 1 + 1 会被解析位 n << (1 + 1)，因此注意加括号：(n << 1) + 1

2. 位运算有范围

   对于位运算，包括应用，都只适用于 32 位的二进制数字范围，即上限为 2147483647，下限为-2147483648
   超过这个范围的数需要使用其他的一些技巧了

3. 作用对象有限

   位运算一般仅可对数字使用，对 true 和 false 虽然类比于 1 和 0，但是使用时还是需要转化一下

#### 基础

##### 取反

对一个二进制数的每一位都取反，0 变 1，1 变 0

但要注意，取反会自动在最前增加一位 0，并将 0 取反为 1，从而使得十进制数取反一定会得到一个负数

```typescript
console.log(~5); // 5 ~0101 -> 1010 -6
console.log(~0); // 0 ~0 -> 1 -1
console.log(~1); // 1 ~01 -> 10 -2
// 对对应的负数再取反就会变回来
```

##### 异或^

当两侧数不相同时返回 1，相同则是 0
如果对两个十进制数异或，会将他们视作二进制，对每位进行异或，进而再返回十进制

应用：

1. 寻找单一元素

   考虑到异或在不相同时返回 1 的性质，可知 num^0 = num，同时 num^num = 0
   因此可声明一个 0，通过和若干元素异或，来实现单一元素的寻找，因为 0 的话才可以保证原本的数不变

   进阶：判断单一字符，可以转为 ascii 码然后异或实现判断

2. 规律替换

   考虑到 1^1=0,0^1=1，可以用这个规律使得一个变量在 0 和 1 之间替换，其他的数字或者符号之间的规律替换也可以利用这一性质

3. 判断两个数是否相等

   两个相同的数异或会得到 0，也因此如果不同的数异或，一定不是 0，即得到的数转化为二进制后一定有一个是 1
   因此可通过 a^b==0 来判断 a 和 b 是否相等
   利用该性质可以找到这两个不同的数，原本在哪一位上不同，进而可以将这两个数区分开来

   > 示例题目：剑指 Offer 56 - I. 数组中数字出现的次数

##### 和&

两侧数都是 1 返回 1，否则 0

应用：

1. 元素状态的判断

   一个数变成二进制数时，相当于成为了一个 n\*1 的数组，每一位都可以保存状态 0 和 1，因此结合&便可对他们进行判断
   例如利用 0 递增到 2 的 n 次幂时二进制会从全 0 到全 1 一步步递增上去，通过这一规律便可设计一个和数组长度相同长度的二进制数来保存状态，例如 3 个值就是 2 的 3 次幂
   进而便可通过判断这个递增的数 mark 中，哪些位是 0，哪些位是 1，来实现全排列

   具体判断方式即直接&和运算，通过将 1 向左转移相应脚标长度的距离 i，便会达到自己的状态位，此时只有 i 为 1，其他都是 0，因此只要和 mark 做&，便相当于只判断了 i 位的状态（其他位都是 0&0 或者 0&1 肯定 0，对于 i 位可能 1&0 和 1&1，要么 0 要么 1），如果&后为 0，则说明 i 位为 0，否则为 1，进而做其他的处理

   > 示例题目：784. 字母大小写全排列

2. 1 的剔除

   根据二进制数性质，如果 n 是奇数，则减 1 不会导致其他位改变，如果 n 是偶数，则减 1 后会导致连续的所有 0 都变为 1，遇到的第一个 1 变为 0

   由此可得，n-1 的二进制表达中，一定会导致原本 1 的数量减少 1（偶数的 0 生成的不算）

   根据此性质可计算汉明重量，即利用-1 后只会影响到最近的一个 1 的性质：
   对末尾是 1，例如 1001001，-1 后为 1001000，通过&运算会发现，因为 1 改变了，所以得到的就是变化的 1 前面的内容没有改变，其自己成为了 0

   对末尾是 0，例如 1001000，-1 后为 1000111，可以发现，也只有最近的一个 1 变为了 0，而其他的 0 变为了 1，而我们的目的是找到 1，所以新变成 1 的不需要，因此只需&运算，便可把变化的 1 及他右边的位数全变 0，不影响左边的

   属于位运算的一个经典应用

   > 示例题目：剑指 Offer 15. 二进制中 1 的个数

3. 判断奇偶

   1 其实等于 00...0001，因此任何数&1 都相当于这个数的最后一位&1，因此奇数&1=1，偶数&1=0
   基于&1==1 便可判断数字是奇数还是偶数

##### 或|

两侧只要有一个是 1 返回 1，否则 0

应用：

1. 结合 0 来记录某些元素是否存在
   因为或计算对于 01 和 11 都是 1，因此可以基于某一数位来判断当前位置的情况是否出现过，进而进行某元素是否出现的情况的判断

   > 示例题目：1832. 判断句子是否为全字母句

#### 移位

##### 有符号移位<<和>>

分别是左移和右移
左移会在右侧补 0，右移会导致右侧数消失

对于数的符号不会改变，即如果是有符号的也不会影响原本的符号（即不会影响最左侧的符号位）

应用：

1. 元素状态的保存

   考虑到左移会自动补零，因此可以通过对 1 左移，来实现多个元素状态的存储，但仅可保存两个状态
   实现思路即：1 不左移，表达第一个元素，1 左移 1，此时对应的数为二进制的 10
   不难看出，1 左移 x 便可得到 x+1 位为 1，后面为 0 的情况，通过左移后修改对应位置为 1 或 0 便可保存第 x 个元素的状态

   若要判断状态可进行和&运算，因为&只有两个 1 才是 1，因此其他位的 0 一定是 0，不会影响对当前位的判断
   若要修改状态，可使用或|运算，|运算有 1 就是 1，因此其他位的 0 不会对原本的值产生影响

   > 示例题目：力扣 面试题 01.01. 判定字符是否唯一

2. 遍历

   相当于前者的进阶，结合 01 对状态的保存来实现不同情况的筛选
   即比如找三元素数组的所有子数组，只需用 mark 从 1 遍历到 8，那么就会得到 001、010、011、100、101 等从 001 到 111 的所有可能
   进而只需遍历三元素数组，通过当前脚标和 mark 进行和运算，便可基于 1 的出现位置来得到所有的子数组

   > 示例题目：805. 数组的均值分割

3. 加速运算

   对于乘 2 和除 2 之类的操作，使用位运算可以使得运算更快
   乘 2 的话只需左移<<1，除 2 的话是右移>>1

   注意除 2 由于会直接消失一位（可能 0 或者 1），所以相当于 Math.floor()函数
   也因此如果要计算负数的一半，会比正常的小 1，即-3 >> 1 会得到 -2
   结合这个 floor 的性质，可以通过对负数+1 来实现处理，即(-3+1) >> 1 == -1
   也不会影响偶数：(-4+1) >> 1 == -2

   利用这个性质，比如要计算正数除以 2 的 n 次幂后的整数，便可以直接右移，而不需要再调用 Math 函数

##### 无符号右移 >>>

该无符号右移会将所有的数视作无符号（正数）
即使是负数，也会讲最左侧的符号位视作正常的用来计算大小的位数，同时会在剩余位上补零
因此如果对一个正数无符号右移会正常进行，对一个负数无符号右移会导致结果比较意想不到，因为符号位也会计算进来

```typescript
console.log(8 >>> 1); // 4
console.log(-8 >>> 1);
// 2147483644, 2147483648 - 4
// 即使无符号右移0也会使得符号位被运算
console.log(-8 >>> 0);
// 4294967288, (2147483648 - 4) * 2
console.log(-1 >>> 1); // 2147483647, max - 1
console.log(-1 >>> 0); // 4294967295, max*2 - 1
```

使用该技巧可以快速的实现有符号数转为无符号数，即直接 num >>> 0 即可，并且此时不会改变原本的二进制数排列，只是调整了读取逻辑使其成为无符号数

### 取余%

取余可得到一个元素除以另一个数的余数

```typescript
a = 7 % 3; // 1
b = -7 % 3; // -1
```

对于正数比较好理解，负数的话可以看出余数也会是一个负数，可以从原理上理解

```typescript
a % b == a - b * fix(a / b); // fix看作向零取整，如果是负数就是ceil，正数就是floor
// 因此可知，当可以整除时，余数一定0，不可以整除时通过上述公式便可知道余数的状态
console.log(7 % -3); // 7/-3 = -2，余数= 7-6=1
console.log(-7 % 3); // -7/3 = -2，余数=-7-3*-2 = -1
// 即符号是跟着取余数走的，因为(a%-b) = -1*(-a%b)
console.log(-7 % -3); // -7/-3 = 2，余数=-7--3*2 = -1
```

应用：

1. 判断奇偶

   对于正数，%2 后判断是否等于 1 即可，负数需要判断-1
   这里注意不是所有情况都能直接 abs%2 去处理，因为可能负数为边界值-2147483648，此时对应的正数 2147483647 是溢出的，会变成 infinity

   因此需要分情况处理

2. 对某个长度的多次利用

   当取余数的绝对值小于被取余数的绝对值时，余数等于自身，当大于时但小于 2 倍时，就相当于自身减去被取余数
   利用这个性质可以实现从灵活的循环

   ```typescript
   for (let i = n; i < n + s.length; i++) {
     // 取余可以实现从n加到l-1，再从0加到n-1
     newS += s[i % s.length];
   }
   ```

   当需要将值限制在 1 ～ n 之间时，主要难点即 n 如何限制为 n
   只需(num-1)%n+1 即可，这样原本等于 0 的 n，处理后等于 n-1，+1 便会变成 n，不+1 便会限制在 0 ～ n-1

   ```typescript

   ```

3. 计算数位和

   数位和即一个数字各个位上数字之和，例如 123 的数位和是 1+2+3=6
   利用取余 10 可以每次取到最后一位，取完最后一位除 10 去除最后一位，直到 num 变为 0 循环即可

   ```typescript
   // 计算数位之和
   let tmp = 0,
     num = lowLimit;
   while (num > 0) {
     tmp += num % 10;
     num = Math.floor(num / 10);
   }
   ```

4. 判断是否是整数

   通过判断 num%1==0 即可，如果是整数会等于 0，否则会是小数

### 运算优化

#### 开根号

开根号需要使用 sqrt 函数，该计算比较复杂，会占用比较多的时间
因此可将 a == sqrt(b)调整为 a\*a == b 实现计算的调整

#### 除法

##### 优化为乘法

除法运算同样较为耗时，同时可能由于 0 值出现计算出错或者 Infinity 的情况
在计算过程中可将 a == b/c 统一调整为 a\*c == b 来优化运算

> 示例题目：力扣 1232. 缀点成线

1. 斜率计算公式

   y2-y1/x2-x1 == y3-y1/x3-x1 便可进行优化为 y2-y1\*x3-x1 - y3-y1\*x2-x1

2. 1 ～ n 的和

   n*(n+1)/2，判断大小可优化为 n*(n+1) < 2\*something

3. 平均值

   两部分平均值是否相同，转化为 A 的 sum \*B 的 len 和 B 的 sum \*A 的 len 进行就计算

## 技巧

### 常见问题

#### 变量使用

1. 初始化

   当需要多次使用某个变量时，例如全局变量，常量，循环里的变量
   一定要记得初始化，在到需要多次使用变量前就应该初始化他

2. 防止埋下祸根

   当需要对一个值调整时，主要他的初始值，他是否可能被多次调整

   如果可能被多次调整，那么就要注意修改值时多使用+=，-=等基于自身运算的符号，也因此对初始值有一定要求

   1. 当需要多次\*时，应该初始化 1
   2. 当需要多次+时应该初始化为 0

3. 减少对高级数据结构的频繁使用

   对于高级数据结构尝试引用都是一个比较大的时间花销，例如获取数组某脚标元素，在 map 中获取键值
   在开发中可以避免对这些的频繁使用，可以用如下方法来规避：

   1. 不需要修改，需要多次使用

      用临时变量保存值，来进行判断

   2. 需要修改

      同样尽量用临时变量先保存当前值，然后再基于临时变量对值进行修改

      > 示例题目：剑指 Offer 66. 构建乘积数组

#### 边界值

1. 边界值的处理

   动态规划较为常见，在动态规划方程中经常有使用临近元素的情况，例如 a-1，b+2
   此时需要判断不要超出范围

2. 边界值的判断

   当存在有效数字的限制时，那就可能意味着存在一个可以提前达到的边界值来提前结束循环
   如果要判断这一边界值，要么在递归时传入参数，要么全局变量保存状态，要么通过循环实现，每次处理后判断结果，如果溢出则可以直接返回边界值

   > 示例题目：808. 分汤

### 常用操作

#### 数值判断

1. 判断奇偶

   只需对数值

### 优化

#### 时间优化

1. 判断元素是否存在

   当需要判断元素是否存在
   使用 set 比使用 array 更快，set 判断是否存在是 o(1)的时间

2. 交换变量

   不需要临时变量交换数值可以通过元组来实现直接交换，比较简洁，示例如下

   ```typescript
   [a, b] = [b, a];
   ```

   但也有代价？？？例如使用更多的空间

3. 减少函数的调用和传值

   例如 console.log 会占用很多时间，提交时注意去除
   以及使用 min，max 等函数，虽然好用，但是一定会增加运行时间（如果主要的时间消耗是在其他的循环中，则可以使用 min 来节省代码编写；如果是需要频繁调用有关函数，则应该优化）
   还有一些额外的操作，例如将数组拆分后进行遍历和直接基于脚标遍历，拆分肯定会耗时

   例如当需要多次用相同参数调用函数时，此时便可用临时值保存，来实现时间的节省

   > 示例题目：剑指 Offer 16. 数值的整数次方

4. 避免对元素的删除

   对于数组或字典之类的数据虽然删除元素比较方便，利用 shift、splice 便可实现，但其实他们的时间复杂度都很高，可能的替换方法：

   1. 使用不需要频繁剔除的数据结构

      如果需要频繁的剔除无用数据，应该尝试修改为其他数据结构（基于数组搭建其他的数据结构所花的时间一定比 O(n2)低）

   2. 通过修改值来替代删除

      即使需要做剔除操作，使用调整参数的方式也比剔除更优，即通过将值修改为无意义的-1 或 undefined 来进行“剔除”

   3. 通过对整个数组进行处理，用临时值来保存新值

      该情况比较特殊，在 bfs 和 dfs 中较为常用，一般此时需要遍历一部分值，基于这部分值会得到一部分新的需要遍历的值，进而对他们处理
      一般情况是一边 shift 从前取值，一边 push 在后放值，导致花费的时间很多，因此可以用临时数组来保存新的值，进而直接 for 遍历旧的，以节省时间，示例如下：

      ```typescript
      // bfs寻找最短边
      let city = [1]; // 每次处理的城市数组
      while (city.length > 0) {
        let tmp = [];
        for (let cur of city) {
          for (let [next, w] of graph[cur]) {
            minDis = minDis < w ? minDis : w;
            if (vis[next] == 0) {
              vis[next] = 1;
              tmp.push(next);
            }
          }
        }
        city = tmp;
      }
      ```

#### 空间优化

1. 减少可能的额外变量

   例如对某个数组的一部分进行处理，一般有生成新数组和基于脚标处理的方法
   如果生成新数组则一定会花费多余的时间空间

2. 减少函数的调用

   函数调用的过程中也会生成临时数据占用空间
   如果数据量过大便可能导致栈溢出而报错，因此同样需减少调用

### 当前情况分析

#### 临时值的选择

选择临时的比较值或者标记时，注意判断原本的数据是否会和选择的冲突，例如数值选择 0 作为标记，如果原本便可能出现 0，则 0 不能作为标记，需要避免此类情况

### 测试

#### 边界值

测试时注意边界值的测试，例如空，例如大量数据等等

#### 影响

设计测试样例时注意刻意针对薄弱点进行，例如对 0 位置进行了修改，便需要针对这里进行针对测试

## 其他内容

### 常用单词翻译

| 英文      | 中文 | 缩写  |
| --------- | ---- | ----- |
| result    | 结果 | res   |
| spiral    | 遍历 | -     |
| count     | 计数 | cnt   |
| odd       | 奇数 | o     |
| even      | 偶数 | e     |
| recursion | 遍历 | recur |
| high      | 高   | hi    |
| low       | 低   | lo    |
| left      | 低   | lo    |
| right     | 低   | lo    |
| mid       | 低   | lo    |
| current   | 低   | lo    |
| distance  | 低   | lo    |
| graph     | 低   | lo    |
| visit     | 低   | lo    |
| word      | 低   | lo    |
| length    | 低   | lo    |
| width     | 低   | lo    |
| height    | 低   | lo    |
| depth     | 低   | lo    |

### vscode 使用技巧

#### 扩展推荐

| 扩展名                         | 扩展类型 | 扩展描述 |
| ------------------------------ | -------- | -------- |
| auto rename tag                |          |          |
| change case                    |          |          |
| code spell checker             |          |          |
| css peek                       |          |          |
| doxygen documentation generate |          |          |
| eslint                         |          |          |
| gitlens                        |          |          |
| icon fonts                     |          |          |
| javascript and typescript      |          |          |
| live server                    |          |          |
| material icon theme            |          |          |
| mysql                          |          |          |
| one dark pro                   |          |          |
| open in brower                 |          |          |
| path intellisense              |          |          |
| prettier                       |          |          |
| pylance                        |          |          |
| python indent                  |          |          |
| qt for python                  |          |          |
| regex previewer                |          |          |
| remote ssh                     |          |          |
| typescript hero                |          |          |
| vs code counter                |          |          |
| vue language feature           |          |          |
| wsl                            |          |          |

#### 快速编辑内容

考虑到 win 和 mac 的控制键不同，win 是 ctrl，mac 是 command，但使用上是一样的，因此下文如果需要使用该类型按键，会用 cBtn 代替

##### 局部选中

全选是 cBtn + a
有一局部选中操作，即 cBtn + d

通过局部选中可以对光标所在的关键字、变量、数值、字符串等内容进行自动识别和选中，选中后可进行复制、剪切等操作

1. 快速复制/剪切内容

   光标转移到需要复制的内容上，cBtn + d 局部选中，cBtn + c/x 即可复制/剪切该内容

2. 快速搜索内容

   搜索是 cBtn + f，基于前文描述可能会认为要先 d 再 c 再 f，但其实当光标放在某内容上时，只需要直接 cBtn + f 即可自动局部选中该内容并替换掉搜索框中的内容

   但注意这里自动局部选中后不会自动复制到剪切板，只是转移到了搜索框，如果要复制的话还是需要 cBtn + c

##### 整行操作

1. 快速复制一行

   将光标放在某一行上，可以是中间也可以是末尾，直接 ctrl/command + c 即可复制一整行，复制后是带有回车的

   同时使用这种方式复制的内容，在粘贴时，只要没有选中要粘贴的区域（例如替换掉几个字），均会将内容重启一行然后再粘贴，即使光标在一行的中间也不会影响这一行的内容

2. 快速剪切一行

   和复制类似，只需修改为剪切指令即可：ctrl/command + x

3. 快速删除一行

   用 vim 插件的话可以直接 dd，无奈还是感觉不方便
   在正常模式下，只需使用剪切的技巧即可，即将光标放在要删除的那一行，然后执行剪切指令，即可实现删除（不粘贴就算删除）

<link rel="stylesheet" type="text/css" href="../assets/auto_title_number.css" />
