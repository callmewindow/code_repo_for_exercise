# 刷题知识点全记录

## TypeScript 有关知识点

### 基础内容

#### 代码规范

##### 命名

变量和函数均采取小驼峰命名

##### 类型声明

声明变量和函数返回值使用冒号+变量类型可实现类型的指定和相应的判断
如果不符合或者没有定义则可能会报错提示
声明子元素的类型：

```typescript
// 在元素类型后面加上[]
let arr: number[] = [1, 2];

// 或者使用数组泛型
let arr: Array<number> = [1, 2];
// 注意对于复杂类型，只能使用泛型来定义类型，如下
let nodeA: Set<Node> = new Set();
```

对于可能是多种类型值的变量，可以声明 any，这样不会报错，但是最好的方法还是在定义时用或来进行标记

如果要声明多类型变量，只需加上或即可
如果要声明一个多类型的数组，则需要借助括号来同时起作用，示例如下

```typescript
let root: Node | null;
let nodeList: (Node | null)[];
let nodeList2: Array<Node | null>;
```

##### 空格和缩进

###### 缩进选择

考虑实际编写习惯，准备在 javascript 和 typescript 中均采取 2 个空格缩进，尽量利用好空间

css 同样采取 2 个缩进
对 html 文件采取 4 个缩进？待定

###### 空格

1. 运算符左右
2. 保留关键字后
3. 定义类型的冒号后

##### 变量声明

###### let 和 const 对比

声明变量一般都尽量使用 let 和 const，而不会使用 var
let 只会在当前代码块起作用需要注意声明位置，例如在 if 块中声明，离开了 if 就无法访问到 let 变量了
const 一般用于声明一些不会被改变的量，例如全局使用的参数，此时放置在函数外即可

具体场景分析：

1.

#### 条件语句

##### 条件

###### 对错

一般来说 true 是标准的对，false 是标准的错
在数字中，如果直接将数字作为条件来判断，0 表示错，其他数表示对
对于无值 null 和 undefined，也都表示错，因此加感叹号!便可判断是否是无值

###### 相等

判断相等一般是直接使用两个等号==，该方式会先尝试将二者的类型转化为同一类型，然后判断转化后的值是否一致

同时还有三个等号===的判断方法，该方法会先判断类型，类型不同则不相等，只有类型相同才会判断有关的值是否一致，更加严谨

具体对比如下：

1. 双等号==
   类型相同：进行三个等号(===)的比较，直接比较值
   类型不同：根据以下规则进行类型转换在比较：
   1、如果一个是 null，一个是 undefined，那么相等
   2、如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较

2. 三等号===
   类型不同：一定不相等
   类型相同：开始后续的比较

   1. 数值
      是同一个值则相等；如果其中至少一个是 NaN，即使都是 NaN 也不相等（判断一个值是否是 NaN，只能使用 isNaN()来判断）
   2. 字符串
      每个位置都相同才相等，否则不相等
   3. 条件
      两个值都是 true，或是 false 则相等
   4. 引用
      如果两个值都引用同一个对象或是函数则相等
   5. 无值
      都是 null，或都是 undefined 才相等

   ```typescript
   // undefined 与 null 的值相等，但类型不相等：
   typeof undefined; // undefined
   typeof null; // object
   null === undefined; // false
   null == undefined; // true
   ```

##### switch

ts 中右 switch 语句，可以结合 case 来同时对一个变量等于多个值的情况进行判断，每个值用 case 标记，示例如下：

```typescript
// expression 是一个常量表达式，必须是一个整型或枚举类型
switch (expression) {
  case 1: // 这里判断的需要和expr的类型一致
    statement(s);
    break; // 不加break，会自动执行case2的statement
  case 2:
    statement(s);
    break;
  // default会在前面的case都没有匹配时执行，必须在末尾
  default:
    statement(s);
  // default可以没有break
}
```

##### 三元式

一般用于赋值：条件?值 1:值 2
当条件满足时返回值 1，否则返回值 2

```typescript
minX = tower[0] < minX ? tower[0] : minX;
```

##### 脚标递增或递减

脚标递增一般在 for 循环中使用的较多，在一些需要循环处理的代码中也常用
一般使用的如下

```typescript
i++; // 返回值还是i
++i; // 返回值是i+1
i += 1; // 不返回i
```

一般情况下++i，--i 更加好用，因为可以直接返回变化后的值，进而进行一些处理，不需要再去获取判断
当需要 i 从 0-n 时可以 i++，当需要从 1-n 时，++i 更加好用

#### 常见值

##### 无值 / 空值

1. null
   空，表示 "什么都没有"。
   null 是一个只有一个值的特殊类型。表示一个空对象引用,用 typeof 检测 null 返回是 object。
   常见于链表，树等节点所在的地方，用 null 来表示结尾

2. undefined
   未定义，是一个没有设置值的变量,typeof 一个没有值的变量会返回 undefined。
   常见于 map.get 等函数，当尝试获取某个值时，如果存在会返回对应值，否则会返回 undefined
   对应函数：
   map.get, arr.shift(), arr.pop()

Null 和 Undefined 是其他任何类型（包括 void）的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined。

当变量为 null 或 undefined 的时候，直接判断它得到的一定是 false，基于这个性质可以减少很多的判断，示例如下：

```typescript
let a = undefined;
if (a) console.log(2);
if (!a) console.log(1);
// 输出1
// 令人震惊的是，如果直接比较null和undefined，他们是相同的，会是true
console.log(null == undefined);
```

而在 TypeScript 中启用严格的空校验（--strictNullChecks）特性，就可以使得 null 和 undefined 只能被赋值给 void 或本身对应的类型，示例代码如下：

```typescript
// 启用 --strictNullChecks
let x: number;
x = 1; // 编译正确
x = undefined; // 编译错误
x = null; // 编译错误
// 上面的例子中变量 x 只能是数字类型。如果一个类型可能出现 null 或 undefined， 可以用 | 来支持多种类型，示例代码如下：

// 启用 --strictNullChecks
let x: number | null | undefined;
x = 1; // 编译正确
x = undefined; // 编译正确
x = null; // 编译正确
```

##### 极限值

1. Infinity
   在除 0 时出现，有正负之分，正负之间为符号的差异，可通过 Math.abs 来进行比较

#### 函数使用

##### 参数传递

1. 普通变量
   对于数字、字符串等基础数据结构，在传递时会直接复制一份进行传输，因此在函数中修改时不会影响原来的变量

2. 数组
   对于数组此类高级数据结构，在传递到函数中时，实际传输的是一个引用，不会复制一份（太占时间空间）
   此时即使在函数中进行修改也会导致原变量的改变，示例如下

   ```typescript
   function test(num: number[]): void {
     num[0] = 0;
   }
   a = [1, 2, 3];
   test(a); // 此时a的第一位也会变成0
   ```

   该性质可以利用，例如这种同步修改数组，可以实现函数间值的同步
   也可能导致问题，例如没有复制一份出来直接修改，导致原本传入函数的不想被修改的值发生改变

### 数据类型

#### 基础类型

下面对部分常用类型进行一些简要介绍和展示

0. 任意 any

   该类型的变量可以背赋予任何值，通常用于接收一些可能为 undefined 或者正常值的参数

   任意值是 TypeScript 针对编程时类型不明确的变量使用的一种数据类型，它常用于以下三种情况。

   1. 变量的值会动态改变时，比如来自用户的输入，任意值类型可以让这些变量跳过编译阶段的类型检查

   ```typescript
   let x: any = 1; // 数字类型
   x = "I am who I am"; // 字符串类型
   x = false; // 布尔类型
   ```

   2. 当需要在编译时选择的包含或移除类型检查时

   ```typescript
   let x: any = 4;
   x.ifItExists(); // 正确，ifItExists方法在运行时可能存在，但这里并不会检查
   x.toFixed(); // 正确
   ```

   3. 当需要定义存储多类型数据数组时

   ```typescript
   let arrayList: any[] = [1, false, "fine"];
   arrayList[1] = 100;
   ```

1. 数字 number

   最普通的数值类型，双精度 64 位浮点值，可以用来表示整数和分数。

   > ts 和 js 都没有单独的整数类型，都是属于 number 的

   ```typescript
   let binaryLiteral: number = 0b1010; // 二进制
   let octalLiteral: number = 0o744; // 八进制
   let decLiteral: number = 6; // 十进制
   let hexLiteral: number = 0xf00d; // 十六进制
   ```

2. 字符串 string

   一个字符系列，使用单引号（'）或双引号（"）来表示字符串类型。反引号（`）来定义多行文本和内嵌表达式
   具体可见后续 String 部分

   ```typescript
   let name: string = "Runoob";
   let years: number = 5;
   let words: string = `您好，今年是 ${name} 发布 ${years + 1} 周年`;
   ```

3. 元组 tuple

   元组类型用来表示已知元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同。

   常用于数据的交换，和临时或复杂的数据类型存储

   ```typescript
   let x: [string, number];
   x = ["Runoob", 1]; // 运行正常
   x = [1, "Runoob"]; // 报错
   console.log(x[0]); // 输出 Runoob
   ```

4. 枚举 enum

   可用于定义一个数值集合，可通过点运算符标记自己是哪个值

   ```typescript
   enum Color {
     Red,
     Green,
     Blue,
   }
   let c: Color = Color.Green;

   //默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。
   //例如，我们将上面的例子改成从 1开始编号：
   enum Color {
     Red = 1,
     Green,
     Blue,
   }
   let c: Color = Color.Green;

   //或者，全部都采用手动赋值：

   enum Color {
     Red = 1,
     Green = 2,
     Blue = 4,
   }
   let c: Color = Color.Green;

   //枚举类型提供的一个便利是你可以由枚举的值得到它的名字。
   //例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：

   enum Color {
     Red = 1,
     Green,
     Blue,
   }
   let colorName: string = Color[2];

   console.log(colorName); // 显示'Green'因为上面代码里它的值是2
   ```

   如果 A 的值是被计算出来的。注意注释部分，如果某个属性的值是计算出来的，那么它后面一位的成员必须要初始化值。

   ```typescript
   const getValue = () => {
     return 0;
   };

   enum List {
     A = getValue(),
     B = 2, // 此处必须要初始化值，不然编译不通过
     C,
   }
   console.log(List.A); // 0
   console.log(List.B); // 2
   console.log(List.C); // 3
   ```

5. 错误 never

   never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值
   意味着声明为 never 类型的变量只能被 never 类型所赋值，在函数中它通常表现为抛出异常或无法执行到终止点（例如无限循环）

   一般在未指定变量类型，而直接尝试调用方法时会报错不能调用 never 类型的变量
   例如：let a = []; a.push(1);就会报错

   ```typescript
   let x: never;
   let y: number;

   // 编译错误，数字类型不能转为 never 类型
   x = 123;

   // 运行正确，never 类型可以赋值给 never 类型
   x = (() => {
     throw new Error("exception");
   })();

   // 运行正确，never 类型可以赋值给 数字类型
   y = (() => {
     throw new Error("exception");
   })();

   // 返回值为 never 的函数可以是抛出异常的情况
   function error(message: string): never {
     throw new Error(message);
   }

   // 返回值为 never 的函数可以是无法被执行到的终止点的情况
   function loop(): never {
     while (true) {}
   }
   ```

#### 特殊类型

1. bigint

大数，范围超级大，大约为：？？？
声明时可通过在数值后加上字符 n 来声明

```typescript
let mod = 1000000007n; // 声明了大数范围的1e9+7
// 计算需要类型一致，这里的num2定义时也需要带n，这类大数如果直接输出会带n字符
let num2 = 1n;
console.log(mod); // 1000000007n
// 计算后为了去除n，需要用Number转化，注意如果不取模对大数强行转Number，可能由于溢出而会四舍五入截断导致数值不匹配
Number(num2 % 1000000007n);
```

但注意对于大数如果直接输出的话也会带着 n，因此需要使用 Number 等工具进行转化
同时大数也无法和普通数一起运算

##### 科学计数法

在 js 中可以通过 e 来实现乘 n 个 10 或者 n 个 0.1 的的情况，但是只有默认类型，无法和大数等类型匹配

```typescript
console.log(1.5e10);
console.log(1e-4);
console.log(1.2e-3);
// 15000000000
// 0.0001
// 0.0012
```

对于大数只能

##### 转化

1. parseInt(str)

   通过传入数字字符串可返回转化为数字类型的数值

#### 数组 Array

##### 初始化

可以直接使用中括号声明一个空数组，但是无法做一些额外工作，例如指定长度填充数据等
比较合理的方式是调用 Array 类，通过 new Array()或 Array()实现声明

括号内可加数组长度信息，后续可使用 fill、map 等函数进行初始化，示例如下：

```typescript
// 声明一个全0长度为5的数组
let arr1 = new Array(5).fill(0);
```

##### 调整

1. splice(start, cnt, item)

   splice 可以实现删除和增加，start 为起始脚标，cnt 为删除的数量，item 为增加的元素
   item 需要和数组类型一致，对于数组可以使用...arr 来实现批量加入，这里的加入是正序的

   如果 cnt<=0 那么不会删除任何元素，返回值会变为空数组，如果>1，则会返回删除元素组成的数组

   ```typescript
   // 删除hello数组1脚标开始的2个元素后，插入4，5，6
   let hello = [0, 1, 2, 3, 4];
   console.log(hello.splice(1, 2, ...[4, 5, 6])); // 输出[1,2]，单纯增加元素只会返回空数组
   // hello:0,4,5,6,3,4
   // 注意加入元素的位置是对应着start的，即如果不删除直接加入，会把原本start位置的元素后移
   let arr = [1, 2, 3];
   arr.splice(1, 0, 4); // arr:[1,4,2,3] // 在脚标1位置删除0，插入4
   ```

   如果第一个参数是-1，如果 cnt>0，则必定会剔除最后一个元素，即使 cnt>1 也只会剔除一个，因为是从-1 开始剔除

   如果增加元素则是在原本最后一个的位置进行加入，即成为倒数第二个元素，脚标对应的仍然是旧 len-1

   ```typescript
   let hello = [1, 2, 3];
   hello.splice(-1, 0, 4);
   console.log(hello); // [1,2,4,3]
   ```

2. length

   length 不只可以用于获取精度，通过增减 length 可以实现对数组基于末尾的增加和减少
   例如 length-1 会导致数组最后一个数据直接丢失，再+1 也不会回来
   length+1 会在末尾生成一个空元素，undefined

###### 增加

1. push()

   一般使用可在数组末尾增加一个元素
   向数组的末尾添加一个或更多元素，并返回新的长度。

2. unshift()

   在数组头部增加一个元素，并返回新的长度。

3. concat(arr)

   通过在 concat()中传入一个数组可实现二者的合并，并返回新数组，如果不传入参数则相当于对数组进行复制
   常用于数组的复制，复制后对新数组操作不会影响旧数组

   ```typescript
   let arr = [0, 1];
   let newArr = arr.concat([2]);
   arr[1] = 2;
   console.log(newArr); // 0,1,2
   ```

###### 减少

1. pop()

   删除数组末尾的元素并返回被函数的元素

2. shift()

   删除数组头部的元素并返回

3. delete

   delete 是一个关键字，在后面加入一个数组元素可以实现基于引用的清空
   清除后会变成 undefined

###### 变化

1. reverse()

   将数组元素顺序反转并返回反转后的结果

2. sort(func)

   排序，如果不输入参数，默认按从小到大的字典序排序，注意是字典序，不是大小从小到大的
   进阶操作可在括号中加入函数，实现对数组元素的精准判断处理，示例如下

   > 注意，sort 函数比较特殊，该函数在数组中被执行后，会直接修改数组的值，因此如果不想如此需要提前深拷贝

   ```typescript
   // 将sArr排序为前一个元素的索引小于后一个元素索引的情况
   // back为后一个元素，front为前一个元素，当返回值大于等于0则不调整顺序，小于0则反转前后顺序
   sArr = sArr.sort(
   (b, f) => {
      let bI = oMap.get(b), fI = oMap.get(f);
      if (bI != undefined && fI != undefined) return bI - fI
      // 不存在的默认排在前面，小于0时会转b和f的顺序，大于等于0则顺序不变
      return fI == undefined ? 1 : -1;
   }

   // 可以根据条件灵活的对元素进行调序，例如将奇数放在偶数前
   // sort函数如下
   nums.sort((b, f) => {return f % 2 == 1 ? 1 : -1;})

   // 同时还可以直接传入函数来实现复杂的排序，一般接收两个参数，表示一后一前
   return nums.sort(checkOrder);
   // 示例题目：面试题45. 把数组排成最小的数
   ```

3. map(func)

   通过指定函数处理数组的每个元素，并返回处理后的数组

   映射，func 是一个可接收多个参数的函数，返回值代表基于当前值所得到的新值
   如果只有一个参数，该参数就代表按顺序遍历的数组的值
   如果有两个参数，该参数就代表按顺序遍历的数组的值和对应的索引

   > map 函数中接受的值是原本的类型，其他运算符也会适配其类型，例如字符串就会是拼接

   ```typescript
   // sA是字符串数组，ch是字符串
   console.log(sA.map((ch) => ch + 1)); // 拼接了1的字符串
   console.log(sA.map((ch) => String.fromCharCode(ch.charCodeAt(0) + 1))); // ascii码+1的字符
   ```

   进阶可通过 map 结合 fill 来实现多维数组的初始化，示例如下：

   ```typescript
   // 注意map需要数组有值，因此需要先fill一个临时值再去map
   let earn: number[][][] = Array(n)
     .fill(0)
     .map(() =>
       Array(5)
         .fill(0)
         .map(() => Array(3).fill(0))
     );
   // earn是一个n*5*3的数组
   // 如果不使用map还需要多层for循环遍历
   ```

##### 获取

###### 判断存在

1. includes(item)

   返回 item 是否存在于当前数组中

2. indexOf(item) / lastIndexOf(item)

   返回数组中第一个 / 最后一个 item 元素的脚标，不存在返回-1

###### 遍历

1. for..of

   通过 of 可对数组内容进行依次获取

2. every(func)

   检测数值元素的每个元素是否都符合条件

   ```typescript
   function isBigEnough(element, index, array) {
     return element >= 10;
   }

   var passed = [12, 5, 8, 130, 44].every(isBigEnough);
   console.log("Test Value : " + passed); // false
   ```

   every 函数同样可用于遍历数组，可以同时处理索引和值，但是推出方式比较奇怪，需要在匿名函数内返回 false，示例如下：

   ```typescript
   let nums1 = ["a", "b", "c"];
   nums1.every((n_1, i_1, nums1) => {
     console.log(n_1, i_1);
     return true; // true表示循环继续，必须要有
   });
   // 按顺序输出a,1;b,2;c,3
   ```

3. some(func)

   检测数组元素中是否有元素符合指定条件。

   ```typescript
   function isBigEnough(element, index, array) {
     return element >= 10;
   }

   var retval = [2, 5, 8, 1, 4].some(isBigEnough);
   console.log("Returned value is : " + retval); // false

   var retval = [12, 5, 8, 1, 4].some(isBigEnough);
   console.log("Returned value is : " + retval); // true
   ```

   4. filter()

   检测元素，并返回符合条件所有元素的数组。

   ```typescript
   function isBigEnough(element, index, array) {
     return element >= 10;
   }

   var passed = [12, 5, 8, 130, 44].filter(isBigEnough);
   console.log("Test Value : " + passed); // 12,130,44
   ```

   可以结合匿名函数实现便捷的符合条件的元素的返回，示例如下：

   ```typescript
   return items.filter((item) => item >= 10); // 获取所有大于等于10元素组成的数组
   ```

   5. forEach()

   数组每个元素都执行一次回调函数。

   ```typescript
   let num = [7, 8, 9];
   num.forEach(function (value) {
     console.log(value);
   });
   ```

   6. ES6 新方法：keys(),values(),entries()方法

   这三个方法本质都是返回一个特殊的迭代器，迭代器有 next()方法，会按顺序返回遍历到的内容，示例如下：

   ```typescript
   // 获取迭代器，替换成key和value同理，只是value不同
   let arrEntries = arr1.entries();
   // 按顺序获取值
   let entry = arrEntries.next();
   // 如果已经遍历完了，next会返回一个done为true的值，以此为依据可暂停
   while (!entry.done) {
     console.log(entry.value); // value为迭代器的值
     entry = arrEntries.next();
   }
   ```

   keys()的迭代内容为键，在数组中即索引，从 0-n-1
   values()的迭代内容为值，数组中即从第一位到最后一位的值
   entries()的迭代内容为键和值组成的元组，即\[key,value\]

   进而结合 for of 循环，便可以直接遍历的循环，下面以 entries 为例介绍 for of 结合迭代器的使用

   ```typescript
   let arrB = ["a", "b"];
   for (let [iB, vB] of arrB.entries()) {
     console.log(iB, vB); // [0,'a'],[1,'b']
   }
   ```

###### 计算

1. reduce() / reduceRight()

   reduce 将数组元素计算为一个值（从左到右）（reduceRight 即从右到左，其他没区别）
   可在 reduce()中传入一个具有两个参数的函数，返回值可对两个参数进行处理
   返回结果为基于返回值对整个数组元素从脚标 0 开始，对前两个元素的返回值作为第二个元素传入第二和第三个元素的处理函数中，以此类推处理所有元素

   ```typescript
   // 计算数组元素总和
   let sum = numArr.reduce((f, b) => f + b);
   ```

   > 注意和 sort 不同的是，reduce 的值是按顺序的前后，当前两个元素计算完成后，结果会作为 f 和再下一个元素传入函数

   利用 reduce 还可以通过对数字进行转化，实现一个数字各位上数字之和，但是比较耗时

   ```typescript
   // c = 123， cCnt = 6
   let cCnt = String(c)
     .split("")
     .map((ch) => Number(ch))
     .reduce((f, b) => f + b);
   // 注意reduce的返回值需要和f，b类型一致，即arr原本的类型
   // 例如上述操作，如果不加map将字符串转为数字数组，则需要在reduce中加上两个Number和一个String，如下
   let cCnt = String(c)
     .split("")
     .reduce((f, b) => {
       return String(Number(f) + Number(b));
     });
   ```

###### 拆分

1. slice(ia,ib)

   通过在 slice 中传入两个参数，返回基于元数组脚标的子数组
   生成子数组和脚标的关系为[left,right)，从 left 开始不取到 right
   如果只有参数 ia，则会自动选择末尾为拆分的结尾，即[ia, end)

   ```typescript
   // 从left拆分到m
   let s2 = s.slice(left, m);
   // 注意slice只会严格按照ia和ib拆分，如果ib<=ia则会返回空数组
   ```

   如果只有一个参数-1.则会返回最后一个元素的数组，此时第二个参数如果有值，则必定是空数组

   ```typescript
   let arr = [1, 2, 3, 4];
   console.log(arr.slice(-1)); // 输出[4]
   ```

##### 转化

1. join(ch)

   join 函数会依次读取数组的值，并将 ch 作为分隔符穿插在中间，转化为一个字符串

##### 高级操作

###### ...操作符

通过在一个数组前加...操作符，可将其传入一些不能传入数组的函数中
例如 Math.max，可计算数组的最大值
例如 push，会一个个的把数组元素输入

```typescript
let arr = [1, 2, 3];
Math.max(...arr); // 3
arr.push(...[4, 5, 6]); // 1,2,3,4,5,6，挺奇怪
```

#### 字符串 String

##### 初始化

一般定义一个字符串直接使用双引号或单引号直接声明
或者可以使用 String 类的构造函数进行，构造函数还可将数字等变量转为字符串形式

```typescript
let s = String(123);
console.log(s); // "123"
```

##### 调整

###### 增加

1. 加号+

   直接使用加号便可实现在字符串末尾增加字符

###### 删除

1. trim()

   trim 函数可对字符串整体进行调整
   trim 会移除字符串开始和末尾处的所有换行符，空格(包括连续的空格)和制表符
   如果这些空白字符在字符串中间时，它们将被保留，不会被移除

2. replace()

   通过匹配字符并将内容替换为"“即可实现删除，具体匹配方式可在下文替换中的 replace 函数学习

###### 替换

1. 前置说明

   字符串如果使用脚标得到的值只是当前位置的只读值，是无法修改的
   如果要修改只有先转为数组才能修改，如果要返回字符串还需要 join 回来
   或者比较麻烦的方法是使用两个 slice 类的拆分函数进行字符串的拆分合并

2. replace(pattern, str)

   可通过传入匹配模式和新字符串，实现匹配内容的替换，不会改变原本的 s
   模式可以是字符、字符串和正则表达式

   如果是字符或字符串，会自动识别到第一个匹配的内容并替换为 str
   如果是正则表达式则会将所有匹配的内容进行替换，具体正则表达式的书写方式可在高级操作的“正则表达式”中进行学习

   同时在该类函数中，还可利用函数对匹配内容进行的二次判断后的处理，示例如下：

   ```typescript
   // 函数的两个参数分别是值和索引，如果只有一个参数就是值
   // 函数的返回值会作为第二个输入参数输入给replace
   return S.replace(/\s/g, (s, i) => (i >= length ? "" : "%20"));
   ```

###### 调序

1. reverse()

   和数组相同，将字符串变为倒序

###### 转化

1. encodeURI()

   该函数通过将字符串传入该函数，可将内容转为地址栏中的 url 格式并返回
   例如空格会被转为%20，百分号会被转为%25

##### 获取

###### 有关函数

1. includes(ch)

   返回是否存在

2. indexOf(ch)

   返回第一个匹配 ch 字符的脚标，不存在返回-1

   应用：

   1. 根据前文可知，一般情况下 indexOf(s[i])返回的应该是 i，除非有重复的字符，导致匹配到了前一个出现的 s[i]的位置
      通过这一性质可以用于检测是否有重复字符或判断两个字符串间是否出现字符的规律相同

   > 示例题目：205. 同构字符串

3. charAt(index)

   返回字符串在该脚标的字符

4. charCodeAt(index)

   返回字符串在该脚标的字符的 ASCII 码
   在新版中至少需要输入一个元素，如果只有一个字符串也需要输入 0
   常见的 ascii 码：
   整体范围：0~9 < A~Z < a~z
   0:48,A:65,a:97

5. String.fromCharCode(num)

   返回 ascii 码等于 num 的字符

###### 遍历

1. for..of

   通过 of 可对字符串内容进行依次获取

###### 拆分

1. slice()

   和数组相同，字符串同样可直接基于 slice()拆分，使用和性质均和数组一致，这里不再赘述

2. substring()

3. substr()

##### 转化

###### 大小写转化

1. toLowerCase()

   全部转为小写

2. toUpperCase()

   全部转为大写

> 对上述两个函数加上 Locale 会根据本机语言进行转化，例如 toLocaleLowerCase()

###### 转化为数组

1. split()

   基于传入的字符或字符串将字符串进行拆分，形成字符串数组，如果为''即将每个字符全部拆开

##### 高级操作

###### 反引号

通过反引号`实现在内部直接拼接变量和字符串的效果
变量需要使用${}进行封装，示例如下

```typescript
// 将numA和numB的值进行合并，形成(a的值)(b的值)样式的字符串
const num = `(${numA})(${numB})`;
```

###### 结合数组实现灵活的数组处理

1. 计算数字的各数位之和
   ```typescript
   // 先变字符串然后变数组，map转为数字后reduce计算和
   let rCnt = String(r)
     .split("")
     .map((ch) => Number(ch))
     .reduce((f, b) => f + b);
   ```

#### 正则表达式 RegExp

正则表达式 expr 可通过有关的符号进行内容的匹配
进而可结合 replace 等函数进行有关内容的替换

##### 初始化

利用初始化函数 new RegExp()可以创建一个正则表达式，可传入多个参数，示例如下

```typescript
let str = "a";
let expr = new RegExp(str, "g"); // 生成一个可全局匹配单个a的正则表达式
// 注意一些特殊符号在正则表达式中有含义，例如\
// 因此如果要基于\生成正则，需要先替换为相应的转义符号，如下所示
if (str === "\\") str = "\\\\";
```

##### 语法规则

介绍如下：
正则表达式的开始和结尾：开始为/，结束为/g，在中间便可输入字符，示例如下

```typescript
// /[\s]/g，匹配字符串中的空格，\s即对应空格
// 将所有的空格转化为%20
newS = s.replace(/[\s]/g, "%20");
```

更多符号：

1. 开头结尾

   ^表示字符串开头，$表示字符串结尾

2. 条件

   |表达或，满足一个条件即可，&表达且，满足多个条件才可匹配，示例如下：

   ```typescript
   s = s.replace(/^\s*|\s*$/g, ""); // 删除开头结尾的空格
   ```

3. 数量

   中括号 \[expr\]
   表示一个或零个 expr，如果只有一个[]出现，那么就是匹配单独的 expr
   expr 可以是一个值，也可以是范围

   ```typescript
   let t = s.replace(/[a-z,A-Z]/g, "0"); // 所有大小写字母换成0
   ```

4. 星号 expr\*

   表达匹配一个或多个连续出现的 expr，示例如下

   ```typescript
   // 将一个以上的空格替换为一个空格
   s = s.replace(/\s\s*/g, " ");
   ```

#### 栈 stack 和队列 Queue

#### 集合 Set

##### 初始化

初始化通过 Set 类的构造方法声明，如果要传入参数使用一维数组

```typescript
const meta = new Set(["a", "e", "i", "o", "u", "A", "E", "I", "O", "U"]);
// 生成一个初始有10个元素的集合
```

##### 调整

###### 增加元素

1. add()

   在 set 中新增一个值，如果已存在不会做任何操作

##### 获取

###### 有关数值

###### 有关函数

1. has()

   返回 set 是否存在该元素

##### 高级操作

#### 字典 Map

##### 初始化

初始化通过 Map 类的构造方法声明，如果要传入参数需要用二维数组

```typescript
const keyToIndex = new Map([["name", "wyx"]]);
// 生成一个初始有键name，值wyx的字典
```

注意 map 在大多数情况下可以用数组替换，即通过搭建一个数组，给数组的索引一个意义，便可实现基于索引对某些内容进行统计

##### 调整

###### 增加元素

1. set()

   为 map 新增或修改现有的键值对

##### 获取

1. size

   获取 map 中键值对的数量

###### 单元素

1. has()

   判断 map 是否具有某个键，返回 true 或 false

2. get()

   获取某个键对应的值，返回值或 undefined

###### 遍历

1. keys() / values()

   获取按 set 前后顺序所排序的所有键或者值的 map 迭代器
   利用 for 循环等方式便可进一步遍历

##### 高级操作

#### 枚举 Enum

##### 初始化

枚举的定义和其他不太相同，是以创建类的方式创建的，直接 enum 变量名 {元素}
注意元素不需要加双引号，直接字符串即可，示例图下：

```typescript
enum msg {
  type,
  color,
  name,
} // 枚举匹配内容
```

##### 基础使用

基础使用即将字符串和数字对应起来，示例如下：

```typescript
// 通过枚举可匹配type，color和name的字符串，并返回他们的脚标0，1，2
// 进而可以结合同样排序的数组进行高级处理
function countMatches(
  items: string[][],
  ruleKey: string,
  ruleValue: string
): number {
  enum msg {
    type,
    color,
    name,
  } // 枚举匹配内容
  return items.filter((item) => item[msg[ruleKey]] == ruleValue).length; // filter筛选
}
```

##### 高级操作

#### 链表 NodeList

#### 树 NodeTree

#### 类 Class

##### 结构定义

定义一个类使用 Class name {}的结构

在内部可使用 private、public 等类型声明变量，声明后在其他方法中可通过 this.来进行调用

constructor 方法可定义初始化时接收的参数并处理，内部可调用其他函数

其他方法可直接通过函数名(输入参数){}的结构声明，不必也不能添加 function 关键字

##### 初始化

初始化通过对应类名的构造方法即可声明，注意需按 constructor 的参数进行变量传入

```typescript
var obj = new ParkingSystem(big, medium, small);
```

##### 调整

###### 增加元素

##### 获取

###### 有关数值

数值获取上和定义时的类型有关，分别如下：
private：
protect：
public：

```typescript

```

###### 有关函数

```typescript
// 直接.操作符调用相关方法，属性则有一定限制
obj.addCar(carType);
```

##### 高级操作

### 有关库的使用

#### Math 库

##### 常用函数

注意，使用函数确实比较方便，但终究还是会导致运算时间加长，因此在对时间内存有要求时，尽量不要用函数

###### 计算

1. sqrt(num)

   对传入的数值计算平方根

2. pow(a,b)

   计算 a 的 b 次幂

   替换：
   考虑从 a 的 0 次幂开始，每次乘 a，把结果保存，可以应对需要从 a 的 0 次幂计算到 n 次幂的情况

3. abs(num)

   返回绝对值

   替换：
   通过是否大于零来判断是否乘-1

###### 获取

1. max，min(a,b,c,,)

   最大值最小值，可通过逗号分隔传入多个数值判断
   如果要传入数组，需要使用...运算符

   替换：
   替换为三元表达式

###### 约分

1. floor()

   向下（更小的）约分

   替换：
   可直接替换为位运算的有符号右移>>

2. ceil()

   向上（更大的）约分

   替换：
   替换为有符号右移 >> +1 即可

#### Number 库

##### 常用数值

1. MAX_VALUE

   可表示的最大的数，MAX_VALUE 属性值接近于 1.79E+308。大于 MAX_VALUE 的值代表 "Infinity"。
   MAX_SAFE_INTEGER 表示安全的最大值

2. MIN_VALUE

   可表示的最小的数，即最接近 0 的正数 (实际上不会变成 0)。最大的负数是 -MIN_VALUE，MIN_VALUE 的值约为 5e-324。小于 MIN_VALUE ("underflow values") 的值将会转换为 0。
   MIN_SAFE_INTEGER 表示安全的最小值

3. NaN

   非数字值（Not-A-Number）。

4. NEGATIVE_INFINITY

   负无穷大，溢出时返回该值。该值小于 MIN_VALUE。

5. POSITIVE_INFINITY

   正无穷大，溢出时返回该值。该值大于 MAX_VALUE。

##### 转化

和字符串的 String 相同，直接使用 Number('123')也会将其中的内容尝试转为数字
并且会转为合法数字，例如 1.200 会转为 1.2

## 算法

### 遍历

#### 子数组

##### 所有子数组

> 示例题目（假）： 力扣 6234. 最小公倍数为 K 的子数组数目，只是开始理解错以为是所有子数组

##### 连续子数组

### 动态规划

#### 前缀和

#### 最长公共子字符串

### 贪心

### 广度优先算法 BFS

### 深度优先算法 DFS

## 数学

### 常见计算

#### 最大公约数

> 示例题目： 力扣 6234. 最小公倍数为 K 的子数组数目

#### 最小公倍数

> 示例题目： 力扣 6234. 最小公倍数为 K 的子数组数目

### 位运算

位运算是对数字做的运算，和条件判断的&&和||有相似之处但是不是同一类运算符，需要注意

注意，位运算的优先级高于正常运算，即 n << 1 + 1 会被解析位 n << (1 + 1)，因此注意加括号：(n << 1) + 1

#### 基础运算

##### 取反

对一个二进制数的每一位都取反，0 变 1，1 变 0

但要注意，取反会自动在最前增加一位 0，并将 0 取反为 1，从而使得十进制数取反一定会得到一个负数

```typescript
console.log(~5); // 5 ~0101 -> 1010 -6
console.log(~0); // 0 ~0 -> 1 -1
console.log(~1); // 1 ~01 -> 10 -2
// 对对应的负数再取反就会变回来
```

##### 异或^

当两侧数不相同时返回 1，相同则是 0
如果对两个十进制数异或，会将他们视作二进制，对每位进行异或，进而再返回十进制

###### 应用

1. 寻找单一元素

   考虑到异或在不相同时返回 1 的性质，可知 num^0 = num，同时 num^num = 0
   因此可声明一个 0，通过和若干元素异或，来实现单一元素的寻找

   进阶：判断单一字符，可以转为 ascii 码然后异或实现判断

2. 规律替换

   考虑到 1^1=0,0^1=1，可以用这个规律使得一个变量在 0 和 1 之间替换，其他的数字或者符号之间的规律替换也可以利用这一性质

##### 和&

两侧数都是 1 返回 1，否则 0

###### 应用

1. 元素状态的判断

   一个数变成二进制数时，相当于成为了一个 n\*1 的数组，每一位都可以保存状态 0 和 1，因此结合&便可对他们进行判断
   例如利用 0 递增到 2 的 n 次幂时二进制会从全 0 到全 1 一步步递增上去，通过这一规律便可设计一个和数组长度相同长度的二进制数来保存状态，例如 3 个值就是 2 的 3 次幂
   进而便可通过判断这个递增的数 mark 中，哪些位是 0，哪些位是 1，来实现全排列

   具体判断方式即直接&和运算，通过将 1 向左转移相应脚标长度的距离 i，便会达到自己的状态位，此时只有 i 为 1，其他都是 0，因此只要和 mark 做&，便相当于只判断了 i 位的状态（其他位都是 0&0 或者 0&1 肯定 0，对于 i 位可能 1&0 和 1&1，要么 0 要么 1），如果&后为 0，则说明 i 位为 0，否则为 1，进而做其他的处理

   > 示例题目：784. 字母大小写全排列

2. 1 的剔除

   根据二进制数性质，如果 n 是奇数，则减 1 不会导致其他位改变，如果 n 是偶数，则减 1 后会导致连续的所有 0 都变为 1，遇到的第一个 1 变为 0

   由此可得，n-1 的二进制表达中，一定会导致原本 1 的数量减少 1（偶数的 0 生成的不算）

   根据此性质可计算汉明重量，即利用-1 后只会影响到最近的一个 1 的性质：
   对末尾是 1，例如 1001001，-1 后为 1001000，通过&运算会发现，因为 1 改变了，所以得到的就是变化的 1 前面的内容没有改变，其自己成为了 0

   对末尾是 0，例如 1001000，-1 后为 1000111，可以发现，也只有最近的一个 1 变为了 0，而其他的 0 变为了 1，而我们的目的是找到 1，所以新变成 1 的不需要，因此只需&运算，便可把变化的 1 及他右边的位数全变 0，不影响左边的

   属于位运算的一个经典应用

   > 示例题目：剑指 Offer 15. 二进制中 1 的个数

##### 或|

良策有一个是 1 返回 1，否则 0

#### 移位

##### 有符号移位<<和>>

分别是左移和右移
左移会在右侧补 0，右移会导致右侧数消失

对于数的符号不会改变，即如果是有符号的也不会影响原本的符号（即不会影响最左侧的符号位）

###### 应用

1. 元素状态的保存

   考虑到左移会自动补零，因此可以通过对 1 左移，来实现多个元素状态的存储，但仅可保存两个状态
   实现思路即：1 不左移，表达第一个元素，1 左移 1，此时对应的数为二进制的 10
   不难看出，1 左移 x 便可得到 x+1 位为 1，后面为 0 的情况，通过左移后修改对应位置为 1 或 0 便可保存第 x 个元素的状态

   若要判断状态可进行和&运算，因为&只有两个 1 才是 1，因此其他位的 0 一定是 0，不会影响对当前位的判断
   若要修改状态，可使用或|运算，|运算有 1 就是 1，因此其他位的 0 不会对原本的值产生影响

   > 示例题目：力扣 面试题 01.01. 判定字符是否唯一

2. 遍历

   相当于前者的进阶，结合 01 对状态的保存来实现不同情况的筛选
   即比如找三元素数组的所有子数组，只需用 mark 从 1 遍历到 8，那么就会得到 001、010、011、100、101 等从 001 到 111 的所有可能
   进而只需遍历三元素数组，通过当前脚标和 mark 进行和运算，便可基于 1 的出现位置来得到所有的子数组

   > 示例题目：805. 数组的均值分割

3. 加速运算

   对于乘 2 和除 2 之类的操作，使用位运算可以使得运算更快
   乘 2 的话只需左移<<1，除 2 的话是右移>>1

   注意除 2 由于会直接消失一位（可能 0 或者 1），所以相当于 Math.floor()函数
   也因此如果要计算负数的一半，会比正常的小 1，即-3 >> 1 会得到 -2
   结合这个 floor 的性质，可以通过对负数+1 来实现处理，即(-3+1) >> 1 == -1
   也不会影响偶数：(-4+1) >> 1 == -2

   利用这个性质，比如要计算正数的整数，便可以直接右移，而不需要再调用 Math 函数

##### 无符号右移 >>>

该无符号右移会将所有的数视作无符号（正数）
即使是负数，也会讲最左侧的符号位视作正常的用来计算大小的位数，同时会在剩余位上补零
因此如果对一个正数无符号右移会正常进行，对一个负数无符号右移会导致结果比较意想不到，因为符号位也会计算进来

```typescript
console.log(8 >>> 1); // 4
console.log(-8 >>> 1);
// 2147483644, 2147483648 - 4
// 即使无符号右移0也会使得符号位被运算
console.log(-8 >>> 0);
// 4294967288, (2147483648 - 4) * 2
console.log(-1 >>> 1); // 2147483647, max - 1
console.log(-1 >>> 0); // 4294967295, max*2 - 1
```

使用该技巧可以快速的实现有符号数转为无符号数，即直接 num >>> 0 即可，并且此时不会改变原本的二进制数排列，只是调整了读取逻辑使其成为无符号数

### 取余%

取余可得到一个元素除以另一个数的余数

```typescript
a = 7 % 3; // 1
b = -7 % 3; // -1
```

对于正数比较好理解，负数的话可以看出余数也会是一个负数，可以从原理上理解

```typescript
a % b == a - b * fix(a / b); // fix看作向零取整，如果是负数就是ceil，正数就是floor
// 因此可知，当可以整除时，余数一定0，不可以整除时通过上述公式便可知道余数的状态
console.log(7 % -3); // 7/-3 = -2，余数= 7-6=1
console.log(-7 % 3); // -7/3 = -2，余数=-7-3*-2 = -1
// 即符号是跟着取余数走的，因为(a%-b) = -1*(-a%b)
console.log(-7 % -3); // -7/-3 = 2，余数=-7--3*2 = -1
```

#### 应用

1. 判断奇偶

   对于正数，%2 后判断是否等于 1 即可，负数需要判断-1
   这里注意不是所有情况都能直接 abs%2 去处理，因为可能负数为边界值-2147483648，此时对应的正数 2147483647 是溢出的，会变成 infinity

   因此需要分情况处理

2. 对某个长度的多次利用

   当取余数的绝对值小于被取余数的绝对值时，余数等于自身，当大于时但小于 2 倍时，就相当于自身减去被取余数
   利用这个性质可以实现从灵活的循环

   ```typescript
   for (let i = n; i < n + s.length; i++) {
     // 取余可以实现从n加到l-1，再从0加到n-1
     newS += s[i % s.length];
   }
   ```

### 运算优化

#### 开根号

开根号需要使用 sqrt 函数，该计算比较复杂，会占用比较多的时间
因此可将 a == sqrt(b)调整为 a\*a == b 实现计算的调整

#### 除法

##### 优化为乘法

除法运算同样较为耗时，同时可能由于 0 值出现计算出错或者 Infinity 的情况
在计算过程中可将 a == b/c 统一调整为 a\*c == b 来优化运算

> 示例题目：力扣 1232. 缀点成线

1. 斜率计算公式

   y2-y1/x2-x1 == y3-y1/x3-x1 便可进行优化为 y2-y1\*x3-x1 - y3-y1\*x2-x1

2. 1 ～ n 的和

   n*(n+1)/2，判断大小可优化为 n*(n+1) < 2\*something

3. 平均值

   两部分平均值是否相同，转化为 A 的 sum \*B 的 len 和 B 的 sum \*A 的 len 进行就计算

## 技巧

### 规避问题

#### 变量使用

1. 初始化

   当需要多次使用某个变量时，例如全局变量，常量，循环里的变量
   一定要记得初始化，在到需要多次使用变量前就应该初始化他

2. 防止埋下祸根

   当需要对一个值调整时，主要他的初始值，他是否可能被多次调整

   如果可能被多次调整，那么就要注意修改值时多使用+=，-=等基于自身运算的符号，也因此对初始值有一定要求

   1. 当需要多次\*时，应该初始化 1
   2. 当需要多次+时应该初始化为 0

#### 边界值

1. 边界值的处理

   动态规划较为常见，在动态规划方程中经常有使用临近元素的情况，例如 a-1，b+2
   此时需要判断不要超出范围

2. 边界值的判断

   当存在有效数字的限制时，那就可能意味着存在一个可以提前达到的边界值来提前结束循环
   如果要判断这一边界值，要么在递归时传入参数，要么全局变量保存状态，要么通过循环实现，每次处理后判断结果，如果溢出则可以直接返回边界值

   > 示例题目：808. 分汤

### 时间优化

1. 判断元素是否存在

   当需要判断元素是否存在
   使用 set 比使用 array 更快，set 判断是否存在是 o(1)的时间

2. 交换变量

   不需要临时变量交换数值可以通过元组来实现直接交换，比较简洁，示例如下

   ```typescript
   [a, b] = [b, a];
   ```

   但也有代价？？？例如使用更多的空间

3. 减少函数的调用和传值

   例如 console.log 会占用很多时间，提交时注意去除
   以及使用 min，max 等函数，虽然好用，但是一定会增加运行时间
   还有一些额外的操作，例如将数组拆分后进行遍历和直接基于脚标遍历，拆分肯定会耗时

   例如当需要多次用相同参数调用函数时，此时便可用临时值保存，来实现时间的节省

   > 示例题目：剑指 Offer 16. 数值的整数次方

### 空间优化

1. 减少可能的额外变量

   例如对某个数组的一部分进行处理，一般有生成新数组和基于脚标处理的方法
   如果生成新数组则一定会花费多余的时间空间

2. 减少函数的调用

   函数调用的过程中也会生成临时数据占用空间
   如果数据量过大便可能导致栈溢出而报错，因此同样需减少调用

### 当前情况分析

#### 临时值的选择

选择临时的比较值或者标记时，注意判断原本的数据是否会和选择的冲突，例如数值选择 0 作为标记，如果原本便可能出现 0，则 0 不能作为标记，需要避免此类情况

### 测试

#### 边界值

测试时注意边界值的测试，例如空，例如大量数据等等

#### 影响

设计测试样例时注意刻意针对薄弱点进行，例如对 0 位置进行了修改，便需要针对这里进行针对测试

## 其他内容

### vscode 使用技巧

#### 扩展推荐

| 扩展名                         | 扩展类型 | 扩展描述 |
| ------------------------------ | -------- | -------- |
| auto rename tag                |          |          |
| change case                    |          |          |
| code spell checker             |          |          |
| css peek                       |          |          |
| doxygen documentation generate |          |          |
| eslint                         |          |          |
| gitlens                        |          |          |
| icon fonts                     |          |          |
| javascript and typescript      |          |          |
| live server                    |          |          |
| material icon theme            |          |          |
| mysql                          |          |          |
| one dark pro                   |          |          |
| open in brower                 |          |          |
| path intellisense              |          |          |
| prettier                       |          |          |
| pylance                        |          |          |
| python indent                  |          |          |
| qt for python                  |          |          |
| regex previewer                |          |          |
| remote ssh                     |          |          |
| typescript hero                |          |          |
| vs code counter                |          |          |
| vue language feature           |          |          |
| wsl                            |          |          |

#### 快速编辑内容

1. 快速复制一行

   将光标放在某一行上，可以是中间也可以是末尾，直接 ctrl/command + c 即可复制一整行，复制后是带有回车的

   同时使用这种方式复制的内容，在粘贴时，只要没有选中要粘贴的区域（例如替换掉几个字），均会将内容重启一行然后再粘贴，即使光标在一行的中间也不会影响这一行的内容

2. 快速剪切一行

   和复制类似，只需修改为剪切指令即可：ctrl/command + x

3. 快速删除一行

   用 vim 插件的话可以直接 dd，无奈还是感觉不方便
   在正常模式下，只需使用剪切的技巧即可，即将光标放在要删除的那一行，然后执行剪切指令，即可实现删除（不粘贴就算删除）

<link rel="stylesheet" type="text/css" href="../assets/auto_title_number.css" />
