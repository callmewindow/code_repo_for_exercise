# 刷题知识点全记录

## TypeScript 和 ES6 语言有关知识点

### 基础内容

#### 代码规范

##### 命名

变量和函数均采取小驼峰命名

##### 类型声明

声明变量和函数返回值使用冒号+变量类型可实现类型的指定和相应的判断
如果不符合或者没有定义则可能会报错提示
声明子元素的类型：

1. matrix: number[][]，将基于脚标获取的形式作为类型定义即可
2. park_max: Array<number>，使用尖括号也可以声明，但是不能和前者混用

##### 空格和缩进

###### 缩进选择

考虑实际编写习惯，准备在 javascript 和 typescript 中均采取 2 个空格缩进，尽量利用好空间

css 同样采取 2 个缩进
对 html 文件采取 4 个缩进？待定

###### 空格

1. 运算符左右
2. 保留关键字后
3. 定义类型的冒号后

##### 变量声明

声明变量尽量使用 let 和 const
let 只会在当前代码块起作用需要注意声明位置
const 一般用于声明一些不会被改变的量，例如全局使用的参数，此时放置在函数外即可

#### 条件语句

##### 判断相等

判断相等一般是直接使用两个等号==，该方式会判断二者的值是否一致
同时还有三个等号===的判断方法，该方法会在判断值之外还会判断类型是否一致，更加严谨

##### 三元式

一般用于赋值：条件?值 1:值 2
当条件满足时返回值 1，否则返回值 2

```typescript
minX = tower[0] < minX ? tower[0] : minX;
```

##### 脚标递增或递减

脚标递增一般在 for 循环中使用的较多，在一些需要循环处理的代码中也常用
一般使用的如下

```typescript
i++; // 返回值还是i
++i; // 返回值是i+1
i += 1; // 不返回i
```

一般情况下++i，--i更加好用，因为可以直接返回变化后的值，进而进行一些处理，不需要再去获取判断
当需要i从0-n时可以i++，当需要从1-n时，++i更加好用

#### 常见值

##### 无值

1. null
   空，常见于链表，树等节点所在的地方，用 null 来表示结尾

2. undefined
   未定义，常见于 map.get 等函数，当尝试获取某个值时，如果存在会返回对应值，否则会返回 undefined
   对应函数：
   map.get, arr.shift(), arr.pop()

##### 极限值

1. Infinity
   在除 0 时出现，有正负之分，正负之间为符号的差异，可通过 Math.abs 来进行比较

#### 函数使用

##### 参数传递

1. 普通变量
   对于数字、字符串等基础数据结构，在传递时会直接复制一份进行传输，因此在函数中修改时不会影响原来的变量

2. 数组
   对于数组此类高级数据结构，在传递到函数中时，实际传输的是一个引用，不会复制一份（太占时间空间）
   此时即使在函数中进行修改也会导致原变量的改变，示例如下

```typescript
function test(num: number[]): void {
  num[0] = 0;
}
a = [1, 2, 3];
test(a); // 此时a的第一位也会变成0
```

该性质可以利用，例如这种同步修改数组，可以实现函数间值的同步
也可能导致问题，例如没有复制一份出来直接修改，导致原本传入函数的不想被修改的值发生改变

因此需要注意

### 各数据类型的利用

#### 数值

##### 整数

1. normal

   最普通的数值类型，只需直接声明为整数即可

2. bigint

   大数，范围超级大，大约为：？？？
   声明时可通过在数值后加上字符 n 来声明

   ```typescript

   ```

   但注意对于大数如果直接输出的话也会带着 n，因此需要使用 Number 等工具进行转化
   同时大数也无法和普通数一起运算

###### 转化

1. parseInt(str)

   通过传入数字字符串可返回转化为数字类型的数值

##### 小数

#### 数组 Array

##### 初始化

可以直接使用中括号声明一个空数组，但是无法做一些额外工作，例如指定长度填充数据等
比较合理的方式是调用 Array 类，通过 new Array()或 Array()实现声明

括号内可加数组长度信息，后续可使用 fill、map 等函数进行初始化，示例如下：

```typescript
// 声明一个全0长度为5的数组
let arr1 = new Array(5).fill(0);
```

##### 调整

1. splice(start, cnt, item)

   splice可以实现删除和增加，start为起始脚标，cnt为删除的数量，item为增加的元素
   item需要和数组类型一致，对于数组可以使用...arr来实现批量加入，这里的加入是正序的

   如果cnt<=0那么不会删除任何元素，返回值会变为空数组，如果>1，则会返回删除元素组成的数组

   ```typescript
   // 删除hello数组1脚标开始的2个元素后，插入4，5，6
   let hello = [0,1,2,3,4]
   console.log(hello.splice(1,2,...[4,5,6])) // 输出[1,2]，单纯增加元素只会返回空数组
   // hello:0,4,5,6,3,4
   // 注意加入元素的位置是对应着start的，即如果不删除直接加入，会把原本start位置的元素后移
   let arr = [1,2,3]
   arr.splice(1,0,4) // arr:[1,4,2,3]
   ```

   如果第一个参数是-1，如果cnt>0，则必定会剔除最后一个元素，即使cnt>1也只会剔除一个，因为是从-1开始剔除
   如果增加元素则是在原本最后一个的位置进行加入，即成为倒数第二个元素，脚标对应的仍然是旧len-1
   ```typescript
   let hello = [1,2,3]
   hello.splice(-1,0,4)
   console.log(hello) // [1,2,4,3]
   ```

2. length

   length不只可以用于获取精度，通过增减length可以实现对数组基于末尾的增加和减少
   例如length-1会导致数组最后一个数据直接丢失，再+1也不会回来
   length+1会在末尾生成一个空元素，undefined

###### 增加

1. push()

   一般使用可在数组末尾增加一个元素
   向数组的末尾添加一个或更多元素，并返回新的长度。

2. unshift()

   在数组头部增加一个元素，并返回新的长度。

3. concat(arr)

   通过在 concat()中传入一个数组可实现二者的合并，并返回新数组，如果不传入参数则相当于对数组进行复制
   常用于数组的复制，复制后对新数组操作不会影响旧数组

   ```typescript
   let arr = [0,1]
   let newArr = arr.concat([2]);
   arr[1] = 2;
   console.log(newArr) // 0,1,2
   ```

###### 减少

1. pop()

   删除数组末尾的元素并返回被函数的元素

2. shift()

   删除数组头部的元素并返回

3. delete

   delete是一个关键字，在后面加入一个数组元素可以实现基于引用的清空
   清除后会变成undefined

###### 变化

1. reverse()

   将数组元素顺序反转并返回反转后的结果

2. sort(func)

   排序，如果不输入参数，默认按从小到大的字典序排序，注意是字典序，不是大小从小到大的
   进阶操作可在括号中加入函数，实现对数组元素的精准判断处理，示例如下

   > 注意，sort 函数比较特殊，该函数在数组中被执行后，会直接修改数组的值，因此如果不想如此需要提前深拷贝

   ```typescript
   // 将sArr排序为前一个元素的索引小于后一个元素索引的情况
   // back为后一个元素，front为前一个元素，当返回值大于等于0则不调整顺序，小于0则反转前后顺序
   sArr = sArr.sort(
   (b, f) => {
      let bI = oMap.get(b), fI = oMap.get(f);
      if (bI != undefined && fI != undefined) return bI - fI
      // 不存在的默认排在前面，小于0时会转b和f的顺序，大于等于0则顺序不变
      return fI == undefined ? 1 : -1;
   }

   // 可以根据条件灵活的对元素进行调序，例如将奇数放在偶数前
   // sort函数如下
   nums.sort((b, f) => {return f % 2 == 1 ? 1 : -1;})
   ```

3. map(func)
   
   通过指定函数处理数组的每个元素，并返回处理后的数组

   映射，func 是一个可接收多个参数的函数，返回值代表基于当前值所得到的新值
   如果只有一个参数，该参数就代表按顺序遍历的数组的值
   如果有两个参数，该参数就代表按顺序遍历的数组的值和对应的索引

   > map 函数中接受的值是原本的类型，其他运算符也会适配其类型，例如字符串就会是拼接

   ```typescript
   // sA是字符串数组，ch是字符串
   console.log(sA.map((ch) => ch + 1)); // 拼接了1的字符串
   console.log(sA.map((ch) => String.fromCharCode(ch.charCodeAt(0) + 1))); // ascii码+1的字符
   ```

##### 获取

###### 判断存在

1. includes(item)

   返回 item 是否存在于当前数组中

2. indexOf(item) / lastIndexOf(item)

   返回数组中第一个 / 最后一个 item 元素的脚标，不存在返回-1

###### 遍历

1. for..of

   通过 of 可对数组内容进行依次获取

2.	every(func)

   检测数值元素的每个元素是否都符合条件。
   ```typescript
   function isBigEnough(element, index, array) { 
         return (element >= 10); 
   } 
         
   var passed = [12, 5, 8, 130, 44].every(isBigEnough); 
   console.log("Test Value : " + passed ); // false
   ```
3.	some(func)

   检测数组元素中是否有元素符合指定条件。
   ```typescript
   function isBigEnough(element, index, array) { 
      return (element >= 10); 
            
   } 
            
   var retval = [2, 5, 8, 1, 4].some(isBigEnough);
   console.log("Returned value is : " + retval );  // false
            
   var retval = [12, 5, 8, 1, 4].some(isBigEnough); 
   console.log("Returned value is : " + retval );  // true
   ```

4.	filter()
   检测数值元素，并返回符合条件所有元素的数组。
   ```typescript
   function isBigEnough(element, index, array) { 
      return (element >= 10); 
   } 
            
   var passed = [12, 5, 8, 130, 44].filter(isBigEnough); 
   console.log("Test Value : " + passed ); // 12,130,44
   ```

5.	forEach()
   数组每个元素都执行一次回调函数。
   ```typescript
   let num = [7, 8, 9];
   num.forEach(function (value) {
      console.log(value);
   }); 
   ```



###### 计算

1. reduce() / reduceRight()

   
   reduce将数组元素计算为一个值（从左到右）（reduceRight即从右到左，其他没区别）
   可在 reduce()中传入一个具有两个参数的函数，返回值可对两个参数进行处理
   返回结果为基于返回值对整个数组元素从脚标 0 开始，对前两个元素的返回值作为第二个元素传入第二和第三个元素的处理函数中，以此类推处理所有元素

   ```typescript
   // 计算数组元素总和
   let sum = numArr.reduce((f, b) => f + b);
   ```

   > 注意和 sort 不同的是，reduce 的值是按顺序的前后，当前两个元素计算完成后，结果会作为f和再下一个元素传入函数

   利用reduce还可以通过对数字进行转化，实现一个数字各位上数字之和，但是比较耗时
   ```typescript
   // c = 123， cCnt = 6
   let cCnt = String(c).split('').map((ch) => Number(ch)).reduce((f, b) => f + b);
   // 注意reduce的返回值需要和f，b类型一致，即arr原本的类型
   // 例如上述操作，如果不加map将字符串转为数字数组，则需要在reduce中加上两个Number和一个String，如下
   let cCnt = String(c).split('').reduce((f, b) => {
      return String(Number(f) + Number(b));
   })
   ```

###### 拆分

1. slice(ia,ib)

   通过在 slice 中传入两个参数，返回基于元数组脚标的子数组
   生成子数组和脚标的关系为[left,right)，从 left 开始不取到 right
   如果只有参数 a，则会自动选择末尾为拆分的结尾

   ```typescript
   // 从left拆分到m
   let s2 = s.slice(left, m);
   // 注意slice只会严格按照ia和ib拆分，如果ib<=ia则会返回空数组
   ```

   如果只有一个参数-1.则会返回最后一个元素的数组，此时第二个参数如果有值，则必定是空数组
   ```typescript
   let arr = [1,2,3,4]
   console.log(arr.slice(-1)) // 输出[4]
   ```

##### 转化

1. join(ch)

   join 函数会依次读取数组的值，并将 ch 作为分隔符穿插在中间，转化为一个字符串

##### 高级操作

###### ...操作符

通过在一个数组前加...操作符，可将其传入一些不能传入数组的函数中
例如 Math.max，可计算数组的最大值
例如 push，会一个个的把数组元素输入

```typescript
let arr = [1, 2, 3];
Math.max(...arr); // 3
arr.push(...[4, 5, 6]); // 1,2,3,4,5,6，挺奇怪
```

#### 字符串 String

##### 初始化

一般定义一个字符串直接使用双引号或单引号直接声明
或者可以使用 String 类的构造函数进行，构造函数还可将数字等变量转为字符串形式

```typescript
let s = String(123);
console.log(s); // "123"
```

##### 调整

###### 增加

1. 加号+

   直接使用加号便可实现在字符串末尾增加字符

###### 删除

1. trim()

   trim 函数可对字符串整体进行调整
   trim 会移除字符串开始和末尾处的所有换行符，空格(包括连续的空格)和制表符
   如果这些空白字符在字符串中间时，它们将被保留，不会被移除

2. replace()

   通过匹配字符并将内容替换为"“即可实现删除，具体匹配方式可在下文替换中的 replace 函数学习

###### 替换

1. 前置说明

   字符串如果使用脚标得到的值只是当前位置的只读值，是无法修改的
   如果要修改只有先转为数组才能修改，如果要返回字符串还需要 join 回来
   或者比较麻烦的方法是使用两个 slice 类的拆分函数进行字符串的拆分合并

2. replace(pattern, str)

   可通过传入匹配模式和新字符串，实现匹配内容的替换，不会改变原本的 s
   模式可以是字符、字符串和正则表达式

   如果是字符或字符串，会自动识别到第一个匹配的内容并替换为 str
   如果是正则表达式则会将所有匹配的内容进行替换，具体正则表达式的书写方式可在高级操作的“正则表达式”中进行学习

   同时在该类函数中，还可利用函数对匹配内容进行的二次判断后的处理，示例如下：

   ```typescript
   // 函数的两个参数分别是值和索引，如果只有一个参数就是值
   // 函数的返回值会作为第二个输入参数输入给replace
   return S.replace(/\s/g, (s, i) => (i >= length ? "" : "%20"));
   ```

###### 调序

1. reverse()

   和数组相同，将字符串变为倒序

###### 转化

1. encodeURI()

   该函数通过将字符串传入该函数，可将内容转为地址栏中的 url 格式并返回
   例如空格会被转为%20，百分号会被转为%25

##### 获取

###### 有关函数

1. includes(ch)

   返回是否存在

2. indexOf(ch)

   返回第一个匹配 ch 字符的脚标，不存在返回-1

   应用：
   1. 根据前文可知，一般情况下indexOf(s[i])返回的应该是i，除非有重复的字符，导致匹配到了前一个出现的s[i]的位置
   通过这一性质可以用于检测是否有重复字符或判断两个字符串间是否出现字符的规律相同

   > 示例题目：205. 同构字符串

3. charAt(index)

   返回字符串在该脚标的字符

4. charCodeAt(index)

   返回字符串在该脚标的字符的 ASCII 码
   在新版中至少需要输入一个元素，如果只有一个字符串也需要输入 0
   常见的 ascii 码：
   整体范围：0~9 < A~Z < a~z
   0:48,A:65,a:97

5. String.fromCharCode(num)

   返回 ascii 码等于 num 的字符

###### 遍历

1. for..of

   通过 of 可对字符串内容进行依次获取

###### 拆分

1. slice()

   和数组相同，字符串同样可直接基于 slice()拆分，使用和性质均和数组一致，这里不再赘述

2. substring()

3. substr()

##### 转化

###### 大小写转化

1. toLowerCase()

   全部转为小写

2. toUpperCase()

   全部转为大写

> 对上述两个函数加上 Locale 会根据本机语言进行转化，例如 toLocaleLowerCase()

###### 转化为数组

1. split()

   基于传入的字符或字符串将字符串进行拆分，形成字符串数组，如果为''即将每个字符全部拆开

##### 高级操作

###### 反引号

通过反引号`实现在内部直接拼接变量和字符串的效果
变量需要使用${}进行封装，示例如下

```typescript
// 将numA和numB的值进行合并，形成(a的值)(b的值)样式的字符串
const num = `(${numA})(${numB})`;
```

#### 正则表达式 RegExp

正则表达式 expr 可通过有关的符号进行内容的匹配
进而可结合 replace 等函数进行有关内容的替换
##### 初始化

利用初始化函数new RegExp()可以创建一个正则表达式，可传入多个参数，示例如下
```typescript
let str = 'a';
let expr = new RegExp(str, 'g'); // 生成一个可全局匹配单个a的正则表达式
// 注意一些特殊符号在正则表达式中有含义，例如\
// 因此如果要基于\生成正则，需要先替换为相应的转义符号，如下所示
if (str === '\\') str = '\\\\';
```
##### 语法规则

介绍如下：
正则表达式的开始和结尾：开始为/，结束为/g，在中间便可输入字符，示例如下

```typescript
// /[\s]/g，匹配字符串中的空格，\s即对应空格
// 将所有的空格转化为%20
newS = s.replace(/[\s]/g, "%20");
```

更多符号：

1. 开头结尾

   ^表示字符串开头，$表示字符串结尾

2. 条件

   |表达或，满足一个条件即可，&表达且，满足多个条件才可匹配，示例如下：

   ```typescript
   s = s.replace(/^\s*|\s*$/g, ""); // 删除开头结尾的空格
   ```

3. 数量

   中括号 \[expr\]
   表示一个或零个 expr，如果只有一个[]出现，那么就是匹配单独的 expr
   expr 可以是一个值，也可以是范围

   ```typescript
   let t = s.replace(/[a-z,A-Z]/g, "0"); // 所有大小写字母换成0
   ```

4. 星号 expr\*

   表达匹配一个或多个连续出现的 expr，示例如下

   ```typescript
   // 将一个以上的空格替换为一个空格
   s = s.replace(/\s\s*/g, " ");
   ```

#### 栈 stack 和队列 Queue

#### 集合 Set

##### 初始化

初始化通过 Set 类的构造方法声明，如果要传入参数使用一维数组

```typescript
const meta = new Set(["a", "e", "i", "o", "u", "A", "E", "I", "O", "U"]);
// 生成一个初始有10个元素的集合
```

##### 调整

###### 增加元素

1. add()

   在 set 中新增一个值，如果已存在不会做任何操作

##### 获取

###### 有关数值

###### 有关函数

1. has()

   返回 set 是否存在该元素

##### 高级操作

#### 字典 Map

##### 初始化

初始化通过 Map 类的构造方法声明，如果要传入参数需要用二维数组

```typescript
const keyToIndex = new Map([["name", "wyx"]]);
// 生成一个初始有键name，值wyx的字典
```

注意map在大多数情况下可以用数组替换，即通过搭建一个数组，给数组的索引一个意义，便可实现基于索引对某些内容进行统计

##### 调整

###### 增加元素

1. set()

   为 map 新增或修改现有的键值对

##### 获取

1. size

   获取 map 中键值对的数量

###### 单元素

1. has()

   判断 map 是否具有某个键，返回 true 或 false

2. get()

   获取某个键对应的值，返回值或 undefined

###### 遍历

1. keys() / values()

   获取按set前后顺序所排序的所有键或者值的map迭代器
   利用for循环等方式便可进一步遍历

##### 高级操作

#### 链表 NodeList

#### 树 NodeTree

#### 类 Class

##### 结构定义

定义一个类使用 Class name {}的结构

在内部可使用 private、public 等类型声明变量，声明后在其他方法中可通过 this.来进行调用

constructor 方法可定义初始化时接收的参数并处理，内部可调用其他函数

其他方法可直接通过函数名(输入参数){}的结构声明，不必也不能添加 function 关键字

##### 初始化

初始化通过对应类名的构造方法即可声明，注意需按 constructor 的参数进行变量传入

```typescript
var obj = new ParkingSystem(big, medium, small);
```

##### 调整

###### 增加元素

##### 获取

###### 有关数值

数值获取上和定义时的类型有关，分别如下：
private：
protect：
public：

```typescript

```

###### 有关函数

```typescript
// 直接.操作符调用相关方法，属性则有一定限制
obj.addCar(carType);
```

##### 高级操作

### 有关库的使用

#### Math 库

##### 常用函数

###### 计算

1. sqrt(num)

   对传入的数值计算平方根

2. pow(a,b)

   计算 a 的 b 次幂

3. abs(num)

   返回绝对值

###### 获取

1. max，min(a,b,c,,)

   最大值最小值，可通过逗号分隔传入多个数值判断
   如果要传入数组，需要使用...运算符

###### 约分

1. floor()

   向下（更小的）约分

2. ceil()

   向上（更大的）约分

3. fix()

   向 0 约分

#### Number 库

##### 常用数值

1. MAX_VALUE

   可表示的最大的数，MAX_VALUE 属性值接近于 1.79E+308。大于 MAX_VALUE 的值代表 "Infinity"。
   MAX_SAFE_INTEGER 表示安全的最大值

2. MIN_VALUE

   可表示的最小的数，即最接近 0 的正数 (实际上不会变成 0)。最大的负数是 -MIN_VALUE，MIN_VALUE 的值约为 5e-324。小于 MIN_VALUE ("underflow values") 的值将会转换为 0。
   MIN_SAFE_INTEGER 表示安全的最小值

3. NaN

   非数字值（Not-A-Number）。

4. NEGATIVE_INFINITY

   负无穷大，溢出时返回该值。该值小于 MIN_VALUE。

5. POSITIVE_INFINITY

   正无穷大，溢出时返回该值。该值大于 MAX_VALUE。

##### 转化

和字符串的 String 相同，直接使用 Number('123')也会将其中的内容尝试转为数字
并且会转为合法数字，例如 1.200 会转为 1.2

### 其他知识

#### 地址串处理

## 算法

### 遍历

#### 子数组

##### 所有子数组

> 示例题目（假）： 力扣 6234. 最小公倍数为 K 的子数组数目，只是开始理解错以为是所有子数组

##### 连续子数组

### 动态规划

#### 前缀和

#### 最长公共子字符串

### 贪心

### 广度优先算法 BFS

### 深度优先算法 DFS

## 数学

### 常见计算

#### 最大公约数

> 示例题目： 力扣 6234. 最小公倍数为 K 的子数组数目

#### 最小公倍数

> 示例题目： 力扣 6234. 最小公倍数为 K 的子数组数目

### 位运算

#### 基础判断

##### 异或^

当两侧数不相同时返回 1，相同则是 0
如果对两个十进制数异或，会将他们视作二进制，对每位进行异或，进而再返回十进制

###### 应用

1. 寻找单一元素

   考虑到异或在不相同时返回 1 的性质，可知 num^0 = num，同时 num^num = 0
   因此可声明一个 0，通过和若干元素异或，来实现单一元素的寻找

   进阶：判断单一字符，可以转为 ascii 码然后异或实现判断

2. 规律替换

   考虑到 1^1=0,0^1=1，可以用这个规律使得一个变量在 0 和 1 之间替换，其他的数字或者符号之间的规律替换也可以利用这一性质

##### 和&

两侧数都是 1 返回 1，否则 0

##### 或|

良策有一个是 1 返回 1，否则 0

#### 移位

##### <<和>>

分别是左移和右移
左移会在右侧补 0，右移会导致右侧数消失？需要检查

###### 应用

1. 元素状态的保存

   考虑到左移会自动补零，因此可以通过对 1 左移，来实现多个元素状态的存储，但仅可保存两个状态
   实现思路即：1 不左移，表达第一个元素，1 左移 1，此时对应的数为二进制的 10
   不难看出，1 左移 x 便可得到 x+1 位为 1，后面为 0 的情况，通过左移后修改对应位置为 1 或 0 便可保存第 x 个元素的状态

   若要判断状态可进行和&运算，因为&只有两个 1 才是 1，因此其他位的 0 一定是 0，不会影响对当前位的判断
   若要修改状态，可使用或|运算，|运算有 1 就是 1，因此其他位的 0 不会对原本的值产生影响

   > 示例题目：力扣 面试题 01.01. 判定字符是否唯一

2. 遍历

   相当于前者的进阶，结合 01 对状态的保存来实现不同情况的筛选
   即比如找三元素数组的所有子数组，只需用 mark 从 1 遍历到 8，那么就会得到 001、010、011、100、101 等从 001 到 111 的所有可能
   进而只需遍历三元素数组，通过当前脚标和 mark 进行和运算，便可基于 1 的出现位置来得到所有的子数组

   > 示例题目：805. 数组的均值分割

3. 加速运算

   对于乘2和除2之类的操作，使用位运算可以使得运算更快
   乘2的话只需左移<<，除2的话是右移>>，注意除2由于会直接消失一位（可能0或者1），所以相当于Math.fix()函数

### 取余%

取余可得到一个元素除以另一个数的余数

```typescript
a = 7 % 3; // 1
b = -7 % 3; // -1
```

#### 应用

1. 对某个长度的多次利用

   当取余数的绝对值小于被取余数的绝对值时，余数等于自身，当大于时但小于 2 倍时，就相当于自身减去被取余数
   利用这个性质可以实现从灵活的循环

   ```typescript
   for (let i = n; i < n + s.length; i++) {
     // 取余可以实现从n加到l-1，再从0加到n-1
     newS += s[i % s.length];
   }
   ```

### 运算优化

#### 开根号

开根号需要使用 sqrt 函数，该计算比较复杂，会占用比较多的时间
因此可将 a == sqrt(b)调整为 a\*a == b 实现计算的调整

#### 除法

##### 优化为乘法

除法运算同样较为耗时，同时可能由于 0 值出现计算出错或者 Infinity 的情况
在计算过程中可将 a == b/c 统一调整为 a\*c == b 来优化运算

> 示例题目：力扣 1232. 缀点成线

1. 斜率计算公式

   y2-y1/x2-x1 == y3-y1/x3-x1 便可进行优化为 y2-y1\*x3-x1 - y3-y1\*x2-x1

2. 1 ～ n 的和

   n*(n+1)/2，判断大小可优化为 n*(n+1) < 2\*something

3. 平均值

   两部分平均值是否相同，转化为 A 的 sum \*B 的 len 和 B 的 sum \*A 的 len 进行就计算

## 技巧

### 时间优化

1. 判断元素是否存在

   当需要判断元素是否存在
   使用 set 比使用 array 更快，set 判断是否存在是 o(1)的时间

2. 交换变量

   不需要临时变量交换数值可以通过搭建数组来实现直接交换，比较简洁，示例如下

   ```typescript
   [a, b] = [b, a];
   ```

   但也有代价，例如使用更多的空间

3. 减少函数的调用和传值

   例如 console.log 会占用很多时间，提交时注意去除
   以及使用 min，max 等函数，虽然好用，但是一定会增加运行时间
   还有一些额外的操作，例如将数组拆分后进行遍历和直接基于脚标遍历，拆分肯定会耗时

### 空间优化

1. 减少可能的额外变量

   例如对某个数组的一部分进行处理，一般有生成新数组和基于脚标处理的方法
   如果生成新数组则一定会花费多余的时间空间

2. 减少函数的调用

   函数调用的过程中也会生成临时数据占用空间
   如果数据量过大便可能导致栈溢出而报错，因此同样需减少调用

### 当前情况分析

#### 临时值的选择

选择临时的比较值或者标记时，注意判断原本的数据是否会和选择的冲突，例如数值选择 0 作为标记，如果原本便可能出现 0，则 0 不能作为标记，需要避免此类情况

### 测试

#### 边界值

测试时注意边界值的测试，例如空，例如大量数据等等

#### 影响

设计测试样例时注意刻意针对薄弱点进行，例如对 0 位置进行了修改，便需要针对这里进行针对测试

<link rel="stylesheet" type="text/css" href="../assets/auto_title_number.css" />
