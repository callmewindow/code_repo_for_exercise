# 刷题知识点全记录

## TypeScript 和 ES6 语言有关知识点

### 基础内容

#### 代码规范

##### 命名

变量和函数均采取小驼峰命名

##### 类型声明

声明变量和函数返回值使用冒号+变量类型可实现类型的指定和相应的判断，如果不符合则会提示报错
声明子元素的类型：

1. matrix: number[][]，将基于脚标获取的形式作为类型定义即可
2. park_max: Array<number>，使用尖括号也可以声明，但是不能和前者混用

##### 空格和缩进

###### 缩进选择

考虑实际编写习惯，准备在 javascript 和 typescript 中均采取 2 个空格缩进，尽量利用好空间

css 同样采取 2 个缩进
对 html 文件采取 4 个缩进？待定

###### 空格

1. 运算符左右
2. 保留关键字后
3. 定义类型的冒号后

##### 变量声明

声明变量尽量使用 let 和 const
let 只会在当前代码块起作用需要注意声明位置
const 一般用于声明一些不会被改变的量，例如全局使用的参数，此时放置在函数外即可

#### 条件语句

##### 判断相等

判断相等一般是直接使用两个等号==，该方式会判断二者的值是否一致
同时还有三个等号===的判断方法，该方法会在判断值之外还会判断类型是否一致，更加严谨

##### 三元式

一般用于赋值：条件?值 1:值 2
当条件满足时返回值 1，否则返回值 2

```typescript
minX = tower[0] < minX ? tower[0] : minX;
```

##### 脚标递增

脚标递增一般在 for 循环中使用的较多，在一些需要循环处理的代码中也常用
一般使用的如下

```typescript
i++; // 返回值还是i
++i; // 返回值是i+1
i += 1; // 不返回i
```

#### 常见值

##### 无值

1. null
   空，常见于链表，树等节点所在的地方，用 null 来表示结尾

2. undefined
   未定义，常见易 map.get 等函数，当尝试获取某个值时，如果存在会返回对应值，否则会返回 undefined

### 各数据类型的利用

#### 数值

##### 整数

###### 类型

1. normal
   最普通的数值类型，只需直接声明为整数即可

2. bigint
   大数，范围超级大，大约为：？？？
   声明时可通过在数值后加上字符 n 来声明

```typescript

```

但注意对于大数如果直接输出的话也会带着 n，因此需要使用 Number 等工具进行转化
同时大数也无法和普通数一起运算

###### 转化

1. parseInt(str)
   通过传入数字字符串可返回转化为数字类型的数值

##### 小数

#### 数组 Array

##### 初始化

可以直接使用中括号声明一个空数组，但是无法做一些额外工作，例如指定长度填充数据等
比较合理的方式是调用 Array 类，通过 new Array()或 Array()实现声明

括号内可加数组长度信息，后续可使用 fill、map 等函数进行初始化，示例如下：

```typescript
// 声明一个全0长度为5的数组
let arr1 = new Array(5).fill(0);
```

##### 调整

###### 增加

1. push()
   一般使用可在数组末尾增加一个元素

2. unshift()
   在数组头部增加一个元素

3. concat(arr[])
   通过在 concat()中传入一个数组可实现二者的合并，并返回新数组，如果不传入参数则相当于对数组进行复制
   常用于数组的复制，复制后对新数组操作不会影响旧数组

```typescript
let newArr = arr.concat();
arr[0] = 0;
newArr[0] = 1;
// arr[0] != newArr[0]
```

###### 减少

1. pop()
   删除数组末尾的元素并返回

2. shift()
   删除数组头部的元素并返回

###### 变序

1. reverse()
   将数组元素顺序反转并返回反转后的结果

2. sort(func)
   排序，如果不输入参数，默认按从小到大的字典序排序，注意是字典序，不是大小从小到大的
   进阶操作可在括号中加入函数，实现对数组元素的精准判断处理，示例如下

> 注意，sort 函数比较特殊，该函数在数组中被执行后，会直接修改数组的值，因此如果不想如此需要提前深拷贝

```typescript
// 将sArr排序为前一个元素的索引小于后一个元素索引的情况
// back为后一个元素，front为前一个元素，当返回值大于等于0则不调整顺序，小于0则反转前后顺序
sArr = sArr.sort(
  (b, f) => {
    let bI = oMap.get(b), fI = oMap.get(f);
    if (bI != undefined && fI != undefined) return bI - fI
    // 不存在的默认排在前面，小于0时会转b和f的顺序，大于等于0则顺序不变
    return fI == undefined ? 1 : -1;
  }

// 可以根据条件灵活的对元素进行调序，例如将奇数放在偶数前
// sort函数如下
nums.sort((b, f) => {return f % 2 == 1 ? 1 : -1;})
```

##### 获取

###### 判断存在

1. includes(item)
   返回 item 是否存在于当前数组中

2. indexOf(item)
   返回数组中第一个 item 元素的脚标，不存在返回-1

###### 遍历

1. for..of
   通过 of 可对数组内容进行依次获取

2.

###### 拆分

1. slice(ia,ib)
   通过在 slice 中传入两个参数，返回基于元数组脚标的子数组
   生成子数组和脚标的关系为[left,right)，从 left 开始不取到 right
   如果只有参数 a，则会自动选择末尾为拆分的结尾

```typescript
// 从left拆分到m
let s2 = s.slice(left, m);
```

##### 转化

1. join(ch)
   join 函数会依次读取数组的值，并将 ch 作为分隔符穿插在中间，转化为一个字符串

##### 高级操作

###### reduce

可在 reduce()中传入一个具有两个参数的函数，返回值可对两个参数进行处理
返回结果为基于返回值对整个数组元素从脚标 0 开始，对前两个元素的返回值作为第二个元素传入第二和第三个元素的处理函数中，以此类推处理所有元素

```typescript
// 计算数组元素总和
let sum = numArr.reduce((f, b) => f + b);
```

###### ...操作符

通过在一个数组前加...操作符，可将其传入一些不能传入数组的函数中
例如 Math.max，可计算数组的最大值
例如 push，会倒序一个个的把数组元素输入

```typescript
arr = [1, 2, 3];
Math.max(...arr); // 3
arr.push(...[4, 5, 6]); // 1,2,3,6,5,4，挺奇怪
```

#### 字符串 String

##### 初始化

一般定义一个字符串直接使用双引号或单引号直接声明
或者可以使用 String 类的构造函数进行，构造函数还可将数字等变量转为字符串形式

```typescript
let s = String(123);
console.log(s); // "123"
```

##### 调整

###### 增加

1. 加号+
   直接使用加号便可实现在字符串末尾增加字符

###### 删除

1. trim()
   trim 函数可对字符串整体进行调整
   trim 会移除字符串开始和末尾处的所有换行符，空格(包括连续的空格)和制表符
   如果这些空白字符在字符串中间时，它们将被保留，不会被移除

2. replace()
   通过匹配字符并将内容替换为"“即可实现删除，具体匹配方式可在下文替换中的 replace 函数学习

###### 替换

1. 前置说明
   字符串如果使用脚标得到的值只是当前位置的只读值，是无法修改的
   如果要修改只有先转为数组才能修改，如果要返回字符串还需要 join 回来
   或者比较麻烦的方法是使用两个 slice 类的拆分函数进行字符串的拆分合并

2. replace(pattern, str)
   可通过传入匹配模式和新字符串，实现匹配内容的替换，不会改变原本的 s
   模式可以是字符、字符串和正则表达式

如果是字符或字符串，会自动识别到第一个匹配的内容并替换为 str
如果是正则表达式则会将所有匹配的内容进行替换，具体正则表达式的书写方式可在高级操作的“正则表达式”中进行学习

同时在该类函数中，还可利用函数对匹配内容进行的二次判断后的处理，示例如下：

```typescript
// 函数的两个参数分别是值和索引，如果只有一个参数就是值
// 函数的返回值会作为第二个输入参数输入给replace
return S.replace(/\s/g, (s, i) => (i >= length ? "" : "%20"));
```

###### 调序

1. reverse()
   和数组相同，将字符串变为倒序

###### 转化

1. encodeURI()
   该函数通过将字符串传入该函数，可将内容转为地址栏中的 url 格式并返回
   例如空格会被转为%20，百分号会被转为%25

##### 获取

###### 有关函数

1. includes(ch)
   返回是否存在

2. indexOf(ch)
   返回第一个匹配 ch 字符的脚标，不存在返回-1

3. charAt(index)
   返回字符串在该脚标的字符

4. charCodeAt(index)
   返回字符串在该脚标的字符的 ASCII 码
   在新版中至少需要输入一个元素，如果只有一个字符串也需要输入 0
   常见的 ascii 码：a：

5. String.fromCharCode(num)
   返回 ascii 码等于 num 的字符

###### 遍历

1. for..of
   通过 of 可对数组内容进行依次获取

###### 拆分

1. slice()
   和数组相同，字符串同样可直接基于 slice()拆分，使用和性质均和数组一致，这里不再赘述

2. substring()

3. substr()

##### 转化

###### 大小写转化

可对字符串使用 toLowerCase()全部转为小写，toUpperCase()全部转为大写
加上 Locale 会根据本机语言进行转化，例如 toLocaleLowerCase()

###### 转化为数组

split()
基于传入的字符或字符串将字符串进行拆分，形成字符串数组，如果为''即将每个字符全部拆开

##### 高级操作

###### 正则表达式

正则表达式 expr 可通过有关的符号进行内容的匹配
进而可结合 replace 函数进行有关内容的替换
介绍如下：
正则表达式的开始和结尾：开始为/，结束为/g，在中间便可输入字符，示例如下

```typescript
// /[\s]/g，匹配字符串中的空格，\s即对应空格
// 将所有的空格转化为%20
newS = s.replace(/[\s]/g, "%20");
```

更多符号：

1. 开头结尾
   ^表示字符串开头，$表示字符串结尾

2. 条件
   |表达或，满足一个条件即可，&表达且，满足多个条件才可匹配，示例如下：

```typescript
s = s.replace(/^\s*|\s*$/g, ""); // 删除开头结尾的空格
```

3. 数量
   中括号 \[expr\]
   表示一个或零个 expr，如果只有一个[]出现，那么就是匹配单独的 expr

星号 expr\*
表达匹配一个或多个连续出现的 expr，示例如下

```typescript
// 将一个以上的空格替换为一个空格
s = s.replace(/\s\s*/g, " ");
```

###### 反引号

通过反引号`实现在内部直接拼接变量和字符串的效果
变量需要使用${}进行封装，示例如下

```typescript
// 将numA和numB的值进行合并，形成(a的值)(b的值)样式的字符串
const num = `(${numA})(${numB})`;
```

#### 栈 stack 和队列 Queue

#### 集合 Set

##### 初始化

初始化通过 Set 类的构造方法声明，如果要传入参数使用一维数组

```typescript
const meta = new Set(["a", "e", "i", "o", "u", "A", "E", "I", "O", "U"]);
// 生成一个初始有10个元素的集合
```

##### 调整

###### 增加元素

add()
在 set 中新增一个值，如果已存在不会做任何操作

##### 获取

###### 有关数值

###### 有关函数

has()
返回 set 是否存在该元素

##### 高级操作

#### 字典 Map

##### 初始化

初始化通过 Map 类的构造方法声明，如果要传入参数需要用二维数组

```typescript
const keyToIndex = new Map([["name", "wyx"]]);
// 生成一个初始有键name，值wyx的字典
```

##### 调整

###### 增加元素

set()：为 map 新增或修改现有的键值对

##### 获取

###### 有关数值

size：获取 map 中键值对的数量

###### 有关函数

has()：判断 map 是否具有某个键，返回 true 或 false
get()：获取某个键对应的值，返回值或 undefined

##### 高级操作

#### 链表 NodeList

#### 树 NodeTree

#### 类 Class

##### 结构定义

定义一个类使用 Class name {}的结构

在内部可使用 private、public 等类型声明变量，声明后在其他方法中可通过 this.来进行调用

constructor 方法可定义初始化时接收的参数并处理，内部可调用其他函数

其他方法可直接通过函数名(输入参数){}的结构声明，不必也不能添加 function 关键字

##### 初始化

初始化通过对应类名的构造方法即可声明，注意需按 constructor 的参数进行变量传入

```typescript
var obj = new ParkingSystem(big, medium, small);
```

##### 调整

###### 增加元素

##### 获取

###### 有关数值

数值获取上和定义时的类型有关，分别如下：
private：
protect：
public：

```typescript

```

###### 有关函数

```typescript
// 直接.操作符调用相关方法，属性则有一定限制
obj.addCar(carType);
```

##### 高级操作

### 有关库的使用

#### Math 库

##### 常用函数

###### 计算

sqrt(num)
对传入的数值计算平方根

pow(a,b)
计算 a 的 b 次幂

abs(num)
返回绝对值

###### 获取

max，min(a,b,c,,)
最大值最小值，可通过逗号分隔传入多个数值判断
如果要传入数组，需要使用...运算符

###### 约分

floor() 向下约分
ceil() 向上约分
fix() 向 0 约分

#### Number 库

##### 常用数值

1. MAX_VALUE
   可表示的最大的数，MAX_VALUE 属性值接近于 1.79E+308。大于 MAX_VALUE 的值代表 "Infinity"。
   MAX_SAFE_INTEGER 表示安全的最大值

2. MIN_VALUE
   可表示的最小的数，即最接近 0 的正数 (实际上不会变成 0)。最大的负数是 -MIN_VALUE，MIN_VALUE 的值约为 5e-324。小于 MIN_VALUE ("underflow values") 的值将会转换为 0。
   MIN_SAFE_INTEGER 表示安全的最小值

3. NaN
   非数字值（Not-A-Number）。

4. NEGATIVE_INFINITY
   负无穷大，溢出时返回该值。该值小于 MIN_VALUE。

5. POSITIVE_INFINITY
   正无穷大，溢出时返回该值。该值大于 MAX_VALUE。

##### 转化

和字符串的 String 相同，直接使用 Number('123')也会将其中的内容尝试转为数字
并且会转为合法数字，例如 1.200 会转为 1.2

### 其他知识

#### 地址串处理

## 算法思想

### 前缀和

### 动态规划

#### 最长公共子字符串

### 贪心

### 广度优先算法 BFS

### 深度优先算法 DFS

## 数学

### 位运算

#### 基础判断

##### 异或^

当两侧数不相同时返回 1，相同则是 0
如果对两个十进制数异或，会将他们视作二进制，对每位进行异或，进而再返回十进制

###### 应用

1. 寻找单一元素
   考虑到异或在不相同时返回 1 的性质，可知 num^0 = num，同时 num^num = 0
   因此可声明一个 0，通过和若干元素异或，来实现单一元素的寻找

   进阶：判断单一字符，可以转为 ascii 码然后异或实现判断

##### 和&

两侧数都是 1 返回 1，否则 0

##### 或|

良策有一个是 1 返回 1，否则 0

#### 移位

##### <<和>>

分别是左移和右移
左移会在右侧补 0，右移会导致右侧数消失？需要检查

###### 应用

考虑到左移会自动补零，因此可以通过对 1 左移，来实现多个元素状态的存储，但仅可保存两个状态
实现思路即：1 不左移，表达第一个元素，1 左移 1，此时对应的数为二进制的 10
不难看出，1 左移 x 便可得到 x+1 位为 1，后面为 0 的情况，通过左移后修改对应位置为 1 或 0 便可保存第 x 个元素的状态

若要判断状态可进行和&运算，因为&只有两个 1 才是 1，因此其他位的 0 一定是 0，不会影响对当前位的判断
若要修改状态，可使用或|运算，|运算有 1 就是 1，因此其他位的 0 不会对原本的值产生影响
示例题目：力扣 面试题 01.01. 判定字符是否唯一

### 取余%

取余可得到一个元素除以另一个数的余数

```typescript
a = 7 % 3; // 1
b = -7 % 3; // -1
```

#### 应用

1. 当取余数的绝对值小于被取余数的绝对值时，余数等于自身，当大于时但小于 2 倍时，就相当于自身减去被取余数
   利用这个性质可以实现从灵活的循环

```typescript
for (let i = n; i < n + s.length; i++) {
  // 取余可以实现从n加到l-1，再从0加到n-1
  newS += s[i % s.length];
}
```

### 运算优化

#### 开根号

开根号需要使用 sqrt 函数，该计算比较复杂，会占用比较多的时间
因此可将 a == sqrt(b)调整为 a\*a == b 实现计算的调整

#### 除法

除法运算同样较为耗时，因此可将 a == b/c 调整为 a\*c == b 来优化运算
例如对于斜率计算公式：y2-y1/x2-x1 == y3-y1/x3-x1 便可进行优化

## 技巧

### 时间优化

#### 变量

1. 判断元素是否村子啊
   当需要判断元素是否存在
   使用 set 比使用 array 更快，set 判断是否存在是 o(1)的时间

2. 交换变量
   不需要临时变量交换数值可以通过搭建数组来实现直接交换，比较简洁，示例如下

```typescript
[a, b] = [b, a];
```

但也有代价，例如使用更多的空间

#### 语句

console.log 会占用很多时间，提交时注意去除

### 空间优化

### 当前情况分析

#### 临时值的选择

选择临时的比较值或者标记时，注意判断原本的数据是否会和选择的冲突，例如数值选择 0 作为标记，如果原本便可能出现 0，则 0 不能作为标记，需要避免此类情况

### 测试

#### 边界值

测试时注意边界值的测试，例如空，例如大量数据等等

#### 影响

设计测试样例时注意刻意针对薄弱点进行，例如对 0 位置进行了修改，便需要针对这里进行针对测试

<link rel="stylesheet" type="text/css" href="../assets/auto_title_number.css" />
