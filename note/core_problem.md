# 项目核心问题记录

## 普通项目

### 跨域问题解决

#### CORS

通过设置http请求头来实现允许跨域

### 数据双绑原理

vue2 使用了数据劫持的技术，在数据对象的属性被访问时自动为其创建了一个依赖收集器。当属性被修改时，依赖收集器会通知与之相关联的所有订阅者进行更新。而实现数据劫持和依赖收集的核心则是通过ES5中的Object.defineProperty()方法来实现的。

这个过程中，订阅者和消费者并没有直接参与到其中，而是由Vue框架自动完成了这些过程。当我们使用Vue的指令或组件时，Vue会自动将数据对象与相应的视图关联起来，使得视图能够动态地响应数据的变化。

Vue3使用ES6的Proxy机制实现了对数据的监听，并且能够实现对深层嵌套对象的监听。在Vue3中，每个组件实例都会有一个响应式数据对象，该对象中的每个属性都会被代理到一个特定的响应式处理程序中。

当修改数据时，该处理程序将通知相关的依赖项以进行更新。这种方式比Vue2使用的Object.defineProperty()方法更加高效、灵活，并且可以避免一些Vue2中存在的问题。

## 服务端渲染

### 优化搜索

提前加载内容可以确保搜索引擎能第一时间获取到有关内容，从而使得网站优先级更高

### 提高性能

服务器的处理速度比客户端还是要快不少的

### 保护信息

通过服务端来处理页面
客户端只能看到渲染好的html内容，将服务器端的渲染逻辑和数据处理过程封装为了黑盒，可以使得攻击者难以获取页面中的敏感信息。

例如有一个电商网站，在客户端渲染的过程中使用了 JavaScript 获取了用户的账号和密码，如果使用客户端渲染，那么这些信息将会被暴露在客户端的代码中，容易被攻击者获取。

而如果使用服务端渲染，账号和密码等敏感信息就只在服务器端处理，只有渲染好的 HTML 被发送到客户端，攻击者就无法获取这些信息。

当然，服务端渲染也并不能完全保证数据的安全，仍然需要在服务器端采取其他措施来保障数据的安全。

## 上线项目

对您在数百人同时上机的高并发场景下，如何处理用户请求、优化性能、保障系统稳定性等方面的经验和能力非常感兴趣。这涉及到前端性能优化、并发处理、错误处理等方面的技术，以及与后端和数据库的协作和交互。

### 系统稳定性

#### 错误处理

封装了错误处理工具

首先利用类继承的策略批量声明错误类型，并设计有关错误信息，第四版通过commonjs实现的封装，第五版使用module进行的封装

会在构造类中进行错误的捕获

```js
class UnknownContest extends Error
  constructor: (@message = "Unknown contest.") ->
    @name = 'UnknownContest'
    Error.captureStackTrace(this, UnknownContest)
```

这段代码使用了类来声明一个名为 UnknownContest 的错误类型，并继承自内建的 Error 类。以下是对这段代码的解释：

UnknownContest 是一个自定义的错误类型，它继承自内建的 Error 类。通过继承 Error 类，UnknownContest 类具有了内建错误类型的一些基本属性和方法，例如 name、message 和 stack。
constructor 是 UnknownContest 类的构造函数，在创建 UnknownContest 类的实例时会被调用。构造函数接受一个可选的 @message 参数，用于指定错误消息，默认为 "Unknown contest."。
@name 是 UnknownContest 类的一个属性，用于指定错误类型的名称，这里设置为 'UnknownContest'。
Error.captureStackTrace(this, UnknownContest) 是一个用于捕获错误堆栈信息的方法。它接受两个参数，第一个参数是错误对象，这里指向 this，即 UnknownContest 类的实例；第二个参数是错误类型，这里指向 UnknownContest 类本身。这样可以在错误堆栈中显示 UnknownContest 类作为错误类型的信息。

这段代码的作用是创建一个名为 UnknownContest 的自定义错误类型，用于表示未知的比赛错误。通过继承 Error 类，它可以具有基本的错误属性和方法，并且可以通过构造函数接受错误消息。同时，通过捕获错误堆栈信息，可以在错误处理时获得更详细的错误信息，方便调试和定位错误。

基于声明的错误类型为他们设计具体的报错展示内容，会根据throw时携带的msg搭建完整的报错信息和有关组件，并在有关日志文件进行记录，实时在页面上进行展示。

进而各页面通过针对不同情况进行异常抛出，即可实现错误的实时捕获和展示，通过前端而不是控制台的形式展示具体情况。

##### 有关技巧梳理

类继承的策略：您使用了类继承的策略来批量声明错误类型，这可以帮助您对不同类型的错误进行分类和处理，从而更好地管理错误。

错误信息的设计：您为每个错误类型设计了相关的错误信息，在构造类时进行了错误的捕获。这可以帮助您在错误发生时更快地定位问题，并提供有关错误的详细信息。

报错展示内容的设计：您根据错误类型和携带的错误信息，设计了完整的报错展示内容，并在页面上进行实时展示。这可以帮助用户在界面上直观地看到错误信息，而不仅仅是在控制台上查看。

日志记录：您在错误处理系统中包括了日志记录的功能，可以将错误信息记录到相关的日志文件中，从而方便后续的错误追踪和排查。

异常抛出：各页面根据不同情况进行异常抛出，从而实现错误的实时捕获和展示。这可以帮助您及时发现并处理错误，提高系统的容错性和稳定性。

综合来看，您的错误处理系统在设计上考虑了错误分类、错误信息展示、日志记录和异常抛出等方面，能够帮助您在服务端渲染的项目中更好地处理错误，提高系统的可靠性和用户体验。如果在面试中需要介绍该错误处理系统，您可以结合具体的项目经验和示例，详细说明您的设计思路、实现方式和效果，以体现您在错误处理方面的经验和能力。

##### 使用类的好处

易于扩展和维护：通过使用类来表示不同类型的错误，您可以轻松地扩展和维护错误分类体系。您可以基于现有的错误类继承关系，添加新的错误类型，从而更好地组织和管理错误。这样，在系统需要新增错误类型时，只需要创建一个新的类继承自现有的错误类，而不需要在代码中大量修改已有的逻辑。

清晰的错误层次结构：使用类可以帮助您创建一个清晰的错误层次结构，将不同类型的错误进行层级化管理。这有助于您更好地理解和组织错误的关系，以及错误处理的流程。例如，您可以创建一个基础的错误类，然后派生出多个具体的错误类，形成一个层次化的错误分类体系，使错误处理的逻辑更加清晰和可维护。

灵活的错误处理逻辑：使用类来进行错误分类可以让您更加灵活地处理不同类型的错误。不同类型的错误可能需要不同的处理逻辑，例如不同的错误信息展示方式、不同的日志记录方式、不同的错误处理流程等。通过使用类，您可以在不同的错误类中定义不同的处理逻辑，从而实现更加灵活和个性化的错误处理策略。

代码复用性：通过使用类来进行错误分类，您可以将相同或相似的错误处理逻辑封装在基础的错误类中，从而实现代码的复用性。这样，当系统中出现多个地方需要处理相同类型的错误时，可以直接使用已有的错误类，避免重复编写相同的错误处理代码，提高了代码的可维护性和代码的复用性。

总之，使用类来进行错误的分类是一种常见的策略，可以带来易于扩展和维护、清晰的错误层次结构、灵活的错误处理逻辑以及代码复用性等好处，有助于提高系统的错误处理能力和可维护性。

#### 保障稳定

异常捕获和日志记录：前端和后端都应该捕获异常并记录到日志中，便于后续排查和处理。
错误信息优化：为前端错误和后端错误设计清晰的错误信息，便于用户理解和定位问题。
监控和告警：实施系统监控和告警机制，通过监控工具实时监控系统的运行状态，及时发现并解决潜在的问题，保障系统的稳定性。

#### 服务端交互

合理设计后端接口：设计合理的后端接口，包括请求和响应的数据结构、接口规范等，便于前端和后端之间的协作和交互。
合理使用数据库：合理设计数据库结构，使用索引和优化查询，减少数据库的负担，提高数据库的性能。
使用数据库连接池：使用数据库连接池，避免频繁创建和销毁数据库连接，提高数据库访问性能。

### 服务器操纵

#### kill指令

服务器上的 kill 指令主要用于终止正在运行的进程。不同的操作系统和 shell 可能会有不同的 kill 指令和参数，下面是一些常见的特点和使用时需要注意的事项：

特点：
终止进程：kill 指令用于向指定进程发送终止信号，通常是 SIGTERM（15）或 SIGKILL（9）信号，用于请求进程优雅地退出或强制终止进程。（kill 指令默认发送的信号是 SIGTERM（15），也可以通过参数指定其他信号，如 SIGKILL（9））
进程选择：kill 指令可以通过进程 ID（PID）或进程名字（如通过 ps 命令获取的进程名）来选择目标进程。
权限限制：kill 指令通常需要足够的权限（如 root 用户或进程所有者）才能终止其他用户的进程。
异步操作：kill 指令发送信号后立即返回，实际的进程终止可能会有延迟。

使用时需要注意的事项：
谨慎使用：kill 指令具有强制终止进程的能力，因此在使用时需要谨慎，避免误操作导致不可恢复的数据丢失或系统不稳定。
选择合适的信号：不同的信号会导致不同的终止方式，SIGTERM 会请求进程优雅地退出，允许进程进行清理操作，而 SIGKILL 则会强制终止进程，可能导致数据丢失或资源未释放。
注意进程依赖关系：在终止进程时，需要注意目标进程是否有可能影响其他进程的正常运行，避免因为终止一个进程而导致整个系统或应用的异常。
注意权限限制：kill 指令通常需要足够的权限才能终止其他用户的进程，因此在使用时需要确保具有足够的权限，避免权限不足导致无法终止目标进程。
建议使用正常退出方式：在正常情况下，应该通过应用程序自身提供的退出方式（如接收信号、调用 API）来终止进程，避免使用 kill 指令强制终止进程，从而确保应用程序可以进行清理操作并保持数据的一致性。

信号是一种用于在进程间进行通信的机制，包括了一些特定的事件或操作，如终止进程、停止进程、继续进程等。在某些情况下，进程可以捕获并处理接收到的信号，这称为信号处理。
但需要注意的是，并非所有的信号都可以被捕获和处理。例如，使用 kill 指令发送的 SIGKILL 信号是无法被捕获和处理的，因为它是一个强制终止进程的信号，目的是立即终止进程而不给予进程任何处理的机会。而 SIGTERM 信号则可以被捕获和处理，因为它是一个请求优雅退出的信号，允许进程进行清理操作。

#### 常用工具

##### pm2

pm2的常用指令。
pm2 start app.js: 启动名为app.js的应用程序。
pm2 list: 显示所有正在运行的进程列表。
pm2 stop app.js: 停止名为app.js的应用程序。
pm2 restart app.js: 重启名为app.js的应用程序。
pm2 logs: 显示所有进程的日志。

使用pm2监控Node.js进程的CPU和内存使用情况
pm2 monit: 运行该命令可以进入一个交互式的监控界面，可以查看所有进程的CPU和内存使用情况。
pm2 describe \<\app-name>: 运行该命令可以查看指定进程的详细信息，包括CPU和内存使用情况。

使用pm2进行进程守护

pm2 start app.js --name=myapp -i 4: 启动名为myapp的应用程序，同时创建4个进程进行负载均衡。
pm2 startup: 运行该命令可以创建系统服务来管理所有的pm2进程，保证进程守护

使用pm2进行进程监控。
pm2 list: 显示所有正在运行的进程列表。
pm2 logs: 显示所有进程的日志。
pm2 monit: 运行该命令可以进入一个交互式的监控界面，可以查看所有进程的CPU和内存使用情况。

##### tmux

tmux的常用指令。
tmux new -s session-name: 新建一个名为session-name的会话。
tmux attach -t session-name: 进入名为session-name的会话。
tmux switch -t session-name: 切换到名为session-name的会话。
tmux list-sessions: 列出当前所有会话。
tmux kill-session -t session-name: 关闭名为session-name的会话。

#### 检测服务器情况

##### 查看进程资源占用情况

使用 top 命令或者 ps 命令。其中，top 命令可以实时地查看系统的进程和资源占用情况，包括 CPU 占用率、内存占用率等；

ps 命令可以列出系统中所有进程的信息，包括进程 ID、进程名、CPU 占用率、内存占用率等。

另外，htop 命令是 top 命令的增强版，提供了更多的交互式功能和视图。

##### 查看服务器运行和负载情况

使用 uptime 命令或者 top 命令。
其中，uptime 命令可以显示服务器的运行时间、当前登录用户数、负载情况等；
而 top 命令可以显示当前系统的进程和资源占用情况，包括 CPU 占用率、内存占用率等，从而可以判断服务器的负载情况。

##### 定位排查异常进程

查看进程日志，找出异常信息（基于pid进行查找），并尝试解决异常；
如果想要查看应用程序的日志，可以使用tail -f <应用程序目录>/logs/<日志文件名>，可以实时输出文件内容，方便查看应用程序的实时日志。

使用 top 命令或者 ps 命令查看进程的资源占用情况，如果进程的 CPU 占用率或者内存占用率过高，可以考虑进行优化或者重启进程；
使用 strace 命令或者 gdb 命令查看进程的运行情况，以及进程可能出现的错误，进而进行解决；
对于一些复杂的异常，可以使用系统性能分析工具进行深入分析，比如 perf 工具、tcpdump 工具等。

##### 查看某端口的占用情况

使用lsof命令来查看某个端口被哪个进程占用。具体命令如下：
sudo lsof -i :端口号

使用 netstat 命令来查看某个端口被谁占用。具体命令如下：
netstat -tlnp | grep 端口号
其中，-t 表示仅显示 TCP 连接，-l 表示仅显示监听状态的连接，-n 表示以数字形式显示地址和端口号，-p 表示显示占用该端口的进程名。最后用 grep 过滤出需要查看的端口号即可。

##### 设置定时任务

编写需要执行的脚本，例如脚本名为myscript.sh。

使用crontab命令编辑定时任务列表。例如，输入命令 crontab -e 可以编辑当前用户的任务列表。

在编辑器中添加一行任务定义，例如：
0 0 * * * /path/to/myscript.sh
这行代码表示在每天的 0 点 0 分执行 /path/to/myscript.sh 脚本。其中，“0 0 * * *”是任务的时间设定，依次表示分钟、小时、日、月、周几，星号代表任意值。

保存并退出编辑器即可。

注意，当修改完任务列表后，cron 服务不会自动重启，需要手动重启服务或等待下一次服务自动重启才能生效。也可以使用命令 sudo service cron reload 来重新加载 cron 配置文件。

### DNS

当您在浏览器中输入一个域名时，浏览器首先会检查本地的DNS缓存是否有该域名对应的IP地址。如果缓存中不存在该记录，浏览器会向本地DNS服务器发送一个查询请求。

1. 本地DNS服务器
本地DNS服务器是由您的ISP提供的。如果您的本地DNS服务器缓存中存在该域名的解析记录，它将直接返回对应的IP地址给您的浏览器，DNS解析结束。

2. 根域名服务器
如果本地DNS服务器缓存中不存在该域名的解析记录，它将向根域名服务器发起请求。根域名服务器包含全球顶级域名服务器的IP地址。在这里，DNS系统会将你请求的域名的顶级域名（.com、.org等）的IP地址返回给本地DNS服务器。

3. 顶级域名服务器
本地DNS服务器向根域名服务器请求后，得到了所请求的域名的顶级域名（例如.com）的IP地址。然后本地DNS服务器再向顶级域名服务器发送请求，请求其返回该域名的下一级域名服务器的IP地址。

4. 权限域名服务器
本地DNS服务器接收到顶级域名服务器返回的下一级域名服务器的IP地址后，再向下一级域名服务器发送请求，请求其返回该域名对应的IP地址。这里返回的是该域名的权限域名服务器，该服务器保存着该域名对应的IP地址。

5. 域名解析
最后，本地DNS服务器得到了该域名对应的IP地址，并将其存入缓存，然后将该地址返回给您的浏览器。您的浏览器使用该IP地址向该域名的web服务器发送请求，服务器返回请求的web页面，完成整个DNS解析过程。

需要注意的是，DNS解析过程中可能会存在多级缓存，也可能存在DNS负载均衡等机制，具体实现方式会因服务提供商而有所不同。

客户端如何获取到域名对应的ip

1. 本地DNS缓存：客户端首先会查询本地DNS缓存，如果有缓存该域名的IP地址，则直接返回。

2. 本地hosts文件：如果本地没有DNS缓存，则会查找本地hosts文件中是否有该域名的IP地址映射。

3. 本地DNS服务器：如果本地缓存和hosts文件中都没有该域名的IP地址映射，则会向本地DNS服务器发送DNS查询请求，本地DNS服务器会先查询自身缓存，如果有缓存则返回IP地址；如果本地DNS服务器没有缓存，那么它会向根DNS服务器发出请求。

4. 根DNS服务器：根DNS服务器返回本地DNS服务器所查询的顶级域名服务器的IP地址。

5. 顶级域名服务器：本地DNS服务器向顶级域名服务器发送DNS查询请求，该服务器返回权威域名服务器的IP地址。

6. 权威域名服务器：本地DNS服务器向权威域名服务器发送DNS查询请求，该服务器返回该域名的IP地址。

7. DNS缓存服务器：如果该域名的DNS记录已经被存储在中间层的DNS缓存服务器中，则本地DNS服务器会向其请求获取该域名的IP地址。

注意，不同的情况下，客户端接收到的IP地址来源可能会有所不同。

### 代理服务器nginx

实现以下目的 :  

缓存缓存服务器可以在本地保存网页或其他互联网内容，以更快的内容检索和减少对网站带宽的需求。  

身份验证控制对应用程序和在线信息的访问权限。  

记录历史数据的存储，例如向服务器发送请求的客户端的IP地址。  

网络过滤控制对可能危及安全或包含不适当内容的网页的访问。  

负载均衡客户端到服务器的请求可以由多个服务器处理，而不是只有一个。

### 安全保障

https://vue3js.cn/interview/JavaScript/security.html

常见的Web攻击方式有

XSS (Cross Site Scripting) 跨站脚本攻击
CSRF（Cross-site request forgery）跨站请求伪造
SQL注入攻击

#### IP记录

针对DDoS限制请求数量

封禁ip地址来实现保护

1. 基于服务器的防火墙配置。可以通过服务器自带的防火墙或者第三方防火墙软件来实现，将需要禁止访问的 IP 添加到黑名单中，或者将允许访问的 IP 添加到白名单中。

2. 在应用程序中实现。可以在应用程序中定义一个中间件，对所有进入的请求进行 IP 鉴定，判断是否在黑名单或白名单中。如果在黑名单中，则返回 403 错误；如果在白名单中，则继续执行后续代码。例如，在 Node.js 中，可以使用 express 库中的 express-ipfilter 中间件实现 IP 黑白名单功能。

3. 基于 CDN 的 IP 黑白名单。可以使用 CDN 服务提供商提供的功能，将需要禁止访问的 IP 添加到黑名单中，或者将允许访问的 IP 添加到白名单中。当用户请求 CDN 时，CDN 会对请求 IP 进行鉴定，判断是否在黑白名单中，从而控制是否返回内容。

需要注意的是，IP 黑白名单虽然可以有效控制访问权限，但是 IP 地址易被伪造，因此不应该作为唯一的安全措施。此外，一些用户可能共享同一个 IP 地址，因此在设置 IP 黑白名单时需要注意不要误伤正常用户。

#### XSS

XSS，跨站脚本攻击，允许攻击者将恶意代码植入到提供给其它用户使用的页面中

XSS涉及到三方，即攻击者、客户端与Web应用

XSS的攻击目标是为了盗取存储在客户端的cookie或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互

浏览器无法分辨出 <script>alert('XSS');</script> 是恶意代码，因而将其执行，试想一下，如果是获取cookie发送对黑客服务器呢？

根据攻击的来源，XSS攻击可以分成：

存储型
反射型
DOM 型

##### 存储型

存储型 XSS 的攻击步骤：

攻击者将恶意代码提交到目标网站的数据库中
用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器
用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作
这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等

##### 反射型 XSS

反射型 XSS 的攻击步骤：

攻击者构造出特殊的 URL，其中包含恶意代码
用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器
用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作
反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。

反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。

由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。

POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见

##### DOM 型 XSS

DOM 型 XSS 的攻击步骤：

攻击者构造出特殊的 URL，其中包含恶意代码
用户打开带有恶意代码的 URL
用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行
恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作
DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞

##### 预防

XSS攻击的两大要素：

攻击者提交而恶意代码
浏览器执行恶意代码
针对第一个要素，我们在用户输入的过程中，过滤掉用户输入的恶劣代码，然后提交给后端，但是如果攻击者绕开前端请求，直接构造请求就不能预防了

而如果在后端写入数据库前，对输入进行过滤，然后把内容给前端，但是这个内容在不同地方就会有不同显示

一个正常的用户输入了 5 < 7 这个内容，在写入数据库前，被转义，变成了 5 < 7

在客户端中，一旦经过了 escapeHTML()，客户端显示的内容就变成了乱码( 5 < 7 )

在前端中，不同的位置所需的编码也不同。

当 5 < 7 作为 HTML 拼接页面时，可以正常显示：

```html
<div title="comment">5 &lt; 7</div>
```

当 5 < 7 通过 Ajax 返回，然后赋值给 JavaScript 的变量时，前端得到的字符串就是转义后的字符。这个内容不能直接用于 Vue 等模板的展示，也不能直接用于内容长度计算。不能用于标题、alert 等

过滤并非可靠的，下面就要通过防止浏览器执行恶意代码：

在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等

#### CSRF

CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求

利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目

一个典型的CSRF攻击有着如下的流程：

受害者登录a.com，并保留了登录凭证（Cookie）
攻击者引诱受害者访问了b.com
b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie
a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求
a.com以受害者的名义执行了act=xx
攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作
csrf可以通过get请求，即通过访问img的页面后，浏览器自动访问目标地址，发送请求

同样，也可以设置一个自动提交的表单发送post请求，如下：

```html
<form action="http://bank.example/withdraw" method=POST>
    <input type="hidden" name="account" value="xiaoming" />
    <input type="hidden" name="amount" value="10000" />
    <input type="hidden" name="for" value="hacker" />
</form>
<script> document.forms[0].submit(); </script> 
```

访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作

还有一种为使用a标签的，需要用户点击链接才会触发
访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作

```html
<a href="http://test.com/csrf/withdraw.php?amount=1000&for=hacker" taget="_blank">
    重磅消息！！
<a/>
```

##### CSRF的特点

攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生
攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据
整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”
跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪

##### CSRF的预防

CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性

常用方案

阻止不明外域的访问

    同源检测
    Samesite Cookie

提交时要求附加本域才能获取的信息

    CSRF Token
    双重Cookie验证

这里主要讲讲token这种形式，流程如下：

用户打开页面的时候，服务器需要给这个用户生成一个Token
对于GET请求，Token将附在请求地址之后。对于 POST 请求来说，要在 form 的最后加上
```html
<input type=”hidden” name=”csrftoken” value=”tokenvalue”/>
```
当用户从客户端得到了Token，再次提交给服务器的时候，服务器需要判断Token的有效性

#### token防止网络攻击

基本思路是，在请求中添加一个token参数，该参数值是服务器随机生成的一串字符串，这个参数一般会放在请求头部中，然后服务器会在后台对这个token进行校验，只有当token合法，才会响应该请求。

具体实现方式如下：
在服务端生成一个token，并将其存储在session中或者在cookie中（需要加上HttpOnly，防止XSS攻击）。（HttpOnly是一种Cookie属性，它的作用是禁止JavaScript访问该Cookie，仅允许在HTTP请求中传输。这样，即使攻击者成功注入恶意脚本，也无法访问该Cookie，从而有效地防止XSS攻击。）

将生成的token传递到客户端，在客户端提交请求时，将token值放在请求的头部中，或者通过表单的隐藏域来提交token。
服务端收到请求后，会从session或cookie中取出相应的token进行比对，如果请求中的token值和服务器端生成的token值一致，则请求是合法的。

实现过程大概是这样的，但需要注意以下几点：
token生成时，需要考虑一些随机性，以避免攻击者猜测到token的值（哈希加密）
token的有效期要适当，过长会增加被猜测的可能，过短会增加用户体验的负担。
token的传递方式需要考虑安全性，尽量不要通过url传递，避免被泄露。
建议使用框架自带的csrf防御，如在Express中，可以使用csurf中间件。

##### 如何做到

token是由服务器生成的随机字符串，用来标识用户身份的。在每次请求中，浏览器都会携带token信息，而攻击者无法伪造该token。这样，即使攻击者成功地注入了恶意代码，或者伪造了用户的请求，也无法完成操作，因为缺乏正确的token信息。所以，使用token是一种有效的安全措施，可以帮助预防XSS和CSRF攻击。

但是注意，如果将 CSRF Token 存储在 Cookie 中，则确实可能会被攻击者获取到，并且可能被利用进行 CSRF 攻击。因此，推荐的做法是将 CSRF Token 存储在 HttpOnly Cookie 之外的其他位置，比如存储在表单中，或者在请求头中添加自定义的 X-CSRF-Token 字段等。这样可以保证 CSRF Token 不会被攻击者获取到，从而有效预防 CSRF 攻击。

#### SQL注入

Sql 注入攻击，是通过将恶意的 Sql查询或添加语句插入到应用的输入参数中，再在后台 Sql服务器上解析执行进行的攻击

流程如下所示：

找出SQL漏洞的注入点
判断数据库的类型以及版本
猜解用户名和密码
利用工具查找Web后台管理入口
入侵和破坏

预防方式如下：

严格检查输入变量的类型和格式
过滤和转义特殊字符
对访问数据库的Web应用程序采用Web应用防火墙

### 请求

#### axios封装

##### 事件循环

事件循环机制是实现异步的基础。
事件循环机制的核心是消息队列（Message Queue）和事件循环（Event Loop）。异步任务会被放入消息队列中，等待事件循环来处理。

当主线程执行完同步代码后，会检查消息队列中是否有待处理的任务。
如果有，则按照顺序取出一个任务，放入调用栈中执行。如果没有，则继续等待新的任务被添加到消息队列中。

#### Promise

#### await async

如何实现异步

阻塞await后续的所有代码，将他们视为微任务

async/await 是 ECMAScript 2017 (ES8) 的新特性，用于简化异步操作的语法，实现了更加直观、易懂的代码结构。底层原理是基于 Promise 对象。

当一个函数使用 async 关键字声明时，它会返回一个 Promise 对象。当该函数内部有一个或多个 await 关键字时，代码会等待 await 后的异步操作执行完成，再继续执行下一步操作。如果异步操作返回的是一个 rejected 状态的 Promise 对象，await 语句就会抛出一个异常，可以通过 try...catch 捕获异常。

async/await 利用了事件循环机制，通过 async 声明的函数会返回一个 Promise 对象，其中的异步操作会被包装成 Promise 对象。
await 用于等待 Promise 对象的解析，当 Promise 对象被解析后，await 后面的代码才会被执行。
当代码执行到 await 的时候，事件循环会继续执行下一个任务，等待 Promise 对象被解析后再次被加入到消息队列中执行。

await 的底层实现其实是通过将 async 函数中的代码转换成一系列的 Promise.then 方法调用，从而达到异步处理的效果。

总的来说，async/await 的底层原理是基于事件循环机制的，通过将异步任务转化为 Promise 对象，利用 await 等待 Promise 对象的解析，从而实现同步和异步的结合。

#### promise应用

##### 睡眠函数

##### 防抖节流

### 自适应

#### flex

#### 有关单位

##### em，rem

#### grid

### 性能优化

#### 常见解决方案

服务端渲染：使用服务端渲染来提高首屏渲染速度，减轻客户端的负担。同时，服务端渲染也有利于 SEO 优化。
页面统一由服务端加载并返回给前端，在后端实现信息的加解密，减少前端资源消耗

资源优化：对于图片、CSS 和 JavaScript 等静态资源进行压缩、合并和缓存等处理，减少请求次数和资源大小，从而提高页面的加载速度。
减少图片大小，进行合理压缩

按需加载：根据用户实际需要，仅加载当前页面所需的内容和资源，减少无用请求，从而提高页面的加载速度。

CDN 加速：使用 CDN（内容分发网络）来加速静态资源的传输和访问速度，从而提高页面的加载速度。
对部分资源通过cdn获取，而不是本地文件

数据库优化：优化数据库的结构、索引和查询语句等，减少数据库访问次数和响应时间，从而提高数据的读写性能。

后端性能优化：对于评测机的并发处理，可以采用分布式评测机、异步处理等技术，提高后端处理能力。

使用缓存：对于频繁访问的数据，可以采用缓存技术，减少数据库访问次数和响应时间，从而提高数据的读写性能。
例如复杂的排行榜数据会通过redis进行保存，定期根据用户提交情况来进行更新，而不是频繁的由用户获取之后再进行计算

减少 HTTP 请求次数：将多个 HTTP 请求合并成一个请求，或者通过使用 HTTP/2 协议来实现多路复用，从而减少 HTTP 请求次数，提高页面的加载速度。

使用 Web Worker：对于一些计算密集型的任务，可以使用 Web Worker 技术将其分离到另一个线程中进行处理，从而减少主线程的压力，提高页面的响应速度。

使用懒加载：对于一些非关键性的内容，可以采用懒加载技术，等到用户需要时再加载，从而提高页面的加载速度。

#### 独特优化方案

1. 评测请求分布式处理

    用户评测请求会批量保存在数据库中不会立刻处理
    对于未处理请求oj会利用redis维护一个等待评测请求的队列
    进而部署的众多评测机会尝试获取新的评测请求，服务端会按顺序从redis队列中提取请求提供给评测机，基于redis的队列管理，可以防止一个请求被多次处理，同时基于redis对评测请求的信息进行缓存，也可以减少对数据库的访问，减少数据库压力。
    评测结束后会将评测结果返回给主服务器进行同步。

    客户端会定期获取评测列表的新状态并进行更新。

2. 并发处理

    在线评测系统面临大量用户同时访问和提交评测请求的情况，因此并发处理是关键。一些最佳解决方案包括：
    异步处理：使用异步编程模式，例如使用 Promise、async/await 等，将阻塞操作放在后台线程中进行，从而避免阻塞主线程，提高并发处理能力。
    限流和队列：通过设置请求限流和使用请求队列，控制并发请求数量，防止系统过载。
    分布式处理：将请求分散到多个处理节点，通过负载均衡和分布式缓存等技术，提高并发处理能力。

3. 缓存优化：合理使用缓存，包括服务端缓存、数据库查询结果缓存、分布式缓存等，减少重复计算和查询，提升性能。
数据库优化：对数据库进行性能优化，包括合理设计数据库结构、使用索引、进行查询优化等，提高数据库的查询和写入性能。
后端代码优化：对后端代码进行性能优化，包括减少不必要的计算、优化数据库查询、使用缓存等，提高后端处理能力。

### 权限管理

1. 基于 token 的身份验证确实是一种常用的方式，但是您需要确保 token 的安全性，例如加密，防止 token 被盗用。

2. 存储用户权限信息的存储工具（如 vuex）可以确保全局权限状态的一致性，但是您需要确保您的权限信息在存储和传输过程中的安全性。此外，如果您的应用程序存在多个权限级别，您还需要确保您的状态存储和组件权限判断的逻辑能够正确地反映这些级别。

3. 对于课程等细节权限，确保您的应用程序能够在用户权限更改时及时更新，以确保权限控制的实时性。此外，您还可以考虑使用动态路由或按需加载组件等技术来延迟加载需要权限验证的组件，以提高应用程序的性能。

4. 您还可以考虑将权限控制封装成一个可重用的模块或组件，并提供相应的 API 和文档，以方便其他开发人员在项目中使用。

5. 最后，如果您的应用程序面临恶意攻击的威胁，您可能需要考虑实施一些额外的安全措施，如 IP 地址白名单、访问限制等。

#### 深入思考

1. 安全性问题

在移动端应用中，用户数量庞大，而且用户所在的网络环境多种多样，可能会受到网络攻击等安全问题的影响。在权限管理方面，我们需要考虑如何防止用户的身份信息被盗取，以及如何防止恶意攻击者通过修改或者篡改数据来达到窃取或者伪造权限的目的。

使用 HTTPS 加密用户的身份信息，避免身份信息被窃取。同时，在服务端实现防止 CSRF 攻击的机制，例如添加 token，防止攻击者利用用户的身份信息发起恶意请求。

2. 性能问题

在高并发的场景下，权限管理的实现需要考虑性能问题，避免出现瓶颈。例如，如果在每次加载时都需要通过网络请求获取权限信息，那么可能会导致应用的性能下降。因此，需要考虑如何通过缓存等方式来提升性能。

在移动端应用中，我们可以将用户的权限信息缓存在本地存储中，以避免频繁的网络请求。另外，在服务端可以使用缓存技术，例如 Redis，将权限信息缓存起来，提高读取速度。

3. 扩展性问题

在权限管理方面，我们需要考虑如何支持不同类型的权限和权限级别，以及如何在未来扩展新的权限管理功能。因此，需要考虑如何设计灵活、可扩展的权限管理方案。

在权限管理方面，可以考虑使用 RBAC（基于角色的访问控制）等权限管理模型。RBAC 模型可以通过将用户分配到不同的角色中，并为每个角色赋予不同的权限，来实现灵活的权限管理。同时，RBAC 模型也支持继承和组合等功能，能够支持更复杂的权限管理需求。

为了提高代码的可读性和可维护性，可以使用装饰器等技术，将权限判断逻辑封装成可重用的组件或者工具函数，以便于其他开发人员在开发过程中使用和维护。同时，我们还可以考虑使用动态路由等技术，将不同权限的用户分配到不同的路由中，以达到更好的权限管理效果。

##### 基于rbac和装饰器实现权限管理

RBAC（Role-Based Access Control）是一种基于角色的权限控制模型，通过对角色进行权限的分配和管理，来实现对用户权限的控制。

在前端开发中，可以使用装饰器等工具来进行权限管理。

```js
// 定义角色
const roleEnum = {
  admin: 'admin',
  user: 'user',
}

// 定义权限
const permissionEnum = {
  create: 'create',
  read: 'read',
  update: 'update',
  delete: 'delete',
}

// 定义角色与权限的关系
const rolePermissionMap = {
  [roleEnum.admin]: [
    permissionEnum.create,
    permissionEnum.read,
    permissionEnum.update,
    permissionEnum.delete,
  ],
  [roleEnum.user]: [
    permissionEnum.read,
  ],
}

// 定义装饰器，用于判断用户是否有权限
function permission(role, permission) {
  return function(target, name, descriptor) {
    const oldValue = descriptor.value;
    descriptor.value = function(...args) {
      // 判断用户是否有权限
      const user = getCurrentUser(); // 获取当前用户信息
      if (!user || !user.roles.includes(role) || !rolePermissionMap[role].includes(permission)) {
        throw new Error('You do not have permission to access this resource.');
      }
      return oldValue.apply(this, args);
    };
    return descriptor;
  }
}

// 使用装饰器定义需要权限的方法
class Example {
  @permission(roleEnum.admin, permissionEnum.create)
  createResource() {
    // 创建资源
  }

  @permission(roleEnum.admin, permissionEnum.delete)
  deleteResource() {
    // 删除资源
  }

  @permission(roleEnum.user, permissionEnum.read)
  getResource() {
    // 获取资源
  }
}
```

我们首先定义了角色和权限的枚举类型，并定义了角色与权限之间的关系，然后定义了一个装饰器 permission，用于判断用户是否有权限访问某个方法。
最后，在需要进行权限控制的方法上使用 permission 装饰器即可。

当用户访问某个需要权限的方法时，装饰器会首先获取当前用户信息，并判断用户是否具有对应的角色和权限。如果用户没有权限，会抛出一个错误。

### 封装思想

组件化开发思想：将页面或应用拆分为多个可重用的组件，降低代码耦合度，提高代码的复用性和可维护性。

面向对象编程思想：将复杂业务逻辑抽象成对象，通过对象之间的交互来完成业务处理。

设计模式：设计模式是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。通过使用设计模式，我们可以更加灵活地处理各种业务场景，提高代码的可读性、可维护性和可扩展性。

函数式编程思想：函数式编程思想可以让代码更加简洁、可读性更强，降低代码出错的可能性，而且在并发编程中也可以发挥很大的作用。

使用类库和框架：类库和框架是前端开发中不可或缺的一部分，使用类库和框架可以大大提高开发效率，减少重复工作，同时也能让代码更加规范化和可维护。

接口封装：将后端接口进行统一封装，以便于前端开发人员调用。同时，对于复杂的接口调用逻辑，也可以将其封装成可复用的函数，提高代码复用性。

错误处理：在开发过程中，错误处理是非常重要的，对于常见的错误，我们可以封装统一的错误处理函数，让错误信息更加友好和清晰，同时也方便后期的维护和修改

#### 样式表隔离

CSS Module：CSS Module 是一种解决 CSS 样式隔离问题的方案，它可以为每个组件生成一个唯一的命名空间，避免样式冲突。使用 CSS Module 可以在组件中使用普通的 CSS 语法，同时可以通过类似“import styles from './styles.module.css'”的方式引入样式，然后在组件的 JSX 中使用“className={styles.classname}”的方式使用样式。

Scoped CSS：Scoped CSS 是通过为样式选择器添加类似“:host”或“:host-context”的伪类实现的，这种方式可以实现对组件内部样式的隔离。

CSS-in-JS：CSS-in-JS 是指在 JS 中编写 CSS，然后将其动态地应用到 DOM 中。通过这种方式可以实现更好的样式隔离和组件化，同时也可以避免一些常见的 CSS 问题，如样式覆盖、继承等。

## 数据结构处理

### 嵌套字典处理

### 诸多配置项管理

1. 复杂的需求处理

您可以强调系统需要处理多语言切换、页面展示、不同单位等多个属性的配置项，并通过定义基础的配置项对象和配置控制类，实现了对这些需求的灵活处理。可以描述您如何设计配置项对象的数据结构，如何将配置文件和UI展示的配置项同步，并通过配置控制类对不同配置文件的内容进行获取和修改。

2. 灵活的配置管理

您可以强调系统的灵活性，通过简单调整配置项前缀就能实现增删和类型控制。可以描述您如何设计前缀系统来实现对不同类型的配置项的划分和管理，以及如何通过配置控制类对配置项的增删进行处理。

3. 高效的处理能力

您可以强调系统需要处理大量用户使用和高并发的情况，说明您在设计和实现系统时考虑到了性能和效率方面的需求。可以描述您如何优化系统的性能，如何处理大量配置项数据的读取和修改操作，以及如何处理高并发的情况下保持系统的稳定性和可靠性。

4. 组件化和封装思想

您可以强调您在系统设计中采用了组件化和封装思想，通过定义基础的配置项对象和配置控制类，实现了组件化的配置管理，并将配置项和UI展示进行了封装，从而实现了系统的可维护性、可扩展性和可重用性。

5. 设计模式的运用

您可以强调您在系统设计中采用了设计模式，如工厂模式、观察者模式、适配器模式等，来优化系统的结构和逻辑，并提高系统的灵活性和可维护性。可以描述您如何运用这些设计模式来解决系统中的复杂问题，并从中展示您对前端开发中常用设计模式的理解和运用能力。

工厂模式：在您的系统中，通过定义基础的配置项对象和配置控制类，实现了对不同类型的配置项对象的创建和管理。这种方式可以看作是一种工厂模式，通过工厂类（配置控制类）来创建不同的产品（配置项对象），并将产品的创建逻辑封装在工厂类中，从而实现了对不同类型配置项的灵活管理和扩展。

观察者模式：在您的系统中，通过配置控制类对配置文件和UI展示的配置项进行同步，并对配置项的内容进行获取和修改。这种方式可以看作是一种观察者模式，配置文件和UI展示的配置项充当了被观察者，而配置控制类充当了观察者，通过观察者模式来实现配置项之间的一对多的依赖关系，从而实现了配置项的同步更新和处理。

适配器模式：在您的系统中，通过定义基础的配置项对象和配置控制类，将配置文件和UI展示的配置项进行了封装，从而实现了组件化的配置管理。这种方式可以看作是一种适配器模式，将不同形式的配置项（配置文件和UI展示的配置项）进行适配和封装，从而实现了对外统一的接口和使用方式，提高了系统的可维护性和可重用性。

## 组件库

公司组件库（基于 Vue2）：我对您在公司组件库开发中如何设计和实现可复用的 UI 组件、组件的状态管理、组件间通信等方面的经验和能力非常关注。这体现了您在前端架构和组件化开发方面的深刻理解和实际应用。

### CI/CD工作流

在coding系统上创建一个项目时，你可以通过coding内置的CI/CD功能来构建一个自动化的工作流，实现自动化构建、测试、部署等功能。以下是一个基于coding系统的CI/CD工作流的基本流程：

安装依赖：CI/CD流程开始前需要先安装依赖，例如npm包、python包等，可以使用编程语言自带的包管理工具，例如npm、pip等，也可以手动安装。

构建：使用编译器或打包工具，例如webpack、rollup、gulp等，将源代码编译、打包成可执行文件或者库。

测试：对编译打包后的代码进行自动化测试，例如单元测试、集成测试、端到端测试等。测试可以使用自动化测试框架，例如Jest、Mocha、Selenium等。

部署：将构建后的代码部署到指定的服务器或平台，例如npm私有仓库、Docker容器、云服务器、云函数等。部署可以使用自动化部署工具，例如Jenkins、Ansible、Fabric等。

在coding系统上，你可以使用自带的CI/CD功能或者第三方的CI/CD工具来实现自动化构建、测试、部署等功能。以下是一个基于coding系统的CI/CD工作流的示例：

安装依赖：

```yaml
install:
  - npm install
```

构建：

```yaml
build:
  stage: build
  script:
    - npm run build
  artifacts:
    paths:
      - dist/
```

测试：

```yaml
test:
  stage: test
  script:
    - npm run test
```

部署：

```yaml
deploy:
  stage: deploy
  script:
    - npm login
    - npm publish
```

这个示例的CI/CD工作流程包括了安装依赖、构建、测试、部署四个阶段。在构建阶段中，我们使用npm安装依赖，并使用npm run build命令将源代码打包成dist目录。在测试阶段中，我们使用npm run test命令进行测试。在部署阶段中，我们使用npm login命令登录到npm私有仓库，并使用npm publish命令将dist目录中的代码发布到npm私有仓库中。

当代码更新后，CI/CD系统会自动触发流程，根据上述配置自动完成依赖安装、构建、测试、部署等工作。你可以在coding系统中查看CI/CD的执行记录，以便快速定位问题并及时解决。

### npm私库搭建

verdaccio

### 组件间通信

Props 和 Events：通过 Props 和 Events 机制，实现父组件向子组件传递数据和子组件向父组件发送事件，实现组件间的通信。
EventBus：使用 Vue2 的 EventBus，实现组件之间的发布/订阅模式的通信，解耦组件间的依赖关系。
Provide 和 Inject：使用 Vue2 的 Provide 和 Inject 特性，实现祖先组件向后代组件传递数据，避免 Props 层层传递的情况。
ref节点通信

### 全局管理

工具函数 (utils)

在 utils 文件夹下，可能包含了一些工具函数，用于处理通用的业务逻辑或实现一些辅助功能。例如，可以包含日期处理、字符串处理、网络请求、数据处理等常用的工具函数。

配置文件 (config.js)

config.js 文件可能包含了一些配置信息，例如组件库的全局配置、样式配置、接口地址等。这样可以方便地进行配置管理，提高组件库的可配置性和可维护性。

入口文件 (index.js)

index.js 文件可能用于实现组件库的入口逻辑，包括组件的导入和注册、全局配置的初始化、Vue2 插件的安装等。这样可以将组件库的主要功能和逻辑集中在一个入口文件中，方便管理和维护。

TypeScript 类型定义 (types)

types 文件夹可能包含了一些 TypeScript 类型定义文件，用于为组件库提供严格的类型检查和类型推断，增加代码的健壮性和可维护性。

### 复用组件开发策略

1. 设计和实现可复用的 UI 组件：

单一职责原则：每个 UI 组件应该只负责一个功能，遵循单一职责原则，保持组件的简洁和高内聚性。
组件化思维：将页面拆分为多个可复用的组件，将页面的不同功能模块抽象成独立的组件，便于复用和维护。
Props 和 Slots：通过 Props 和 Slots 机制，实现组件之间的数据传递和组合，使组件更加灵活和可配置。
可定制性：设计组件时应考虑到不同场景和需求的定制性，提供灵活的 API 或配置选项，便于组件的定制和扩展。
TypeScript 类型定义：使用 TypeScript 为组件库提供严格的类型定义，增加代码的健壮性和可维护性。

2. TypeScript 类型定义的利用：

接口和类型别名：使用 TypeScript 的接口和类型别名，为组件、Props、事件等定义明确的类型，提高代码的可读性和可维护性。
泛型：使用 TypeScript 的泛型，为通用组件和函数提供灵活的类型支持，增加代码的健壮性和灵活性。
类型推断：使用 TypeScript 的类型推断，充分发挥 TypeScript 在开发过程中自动推导类型的特性，减少手动定义类型的工作量。

#### 自定义指令 (directives)

在 directives 文件夹下，可能包含了一些自定义指令，用于扩展 Vue2 的指令系统，实现一些特定的功能或行为。例如，可以通过自定义指令实现表单验证、权限控制、动画效果等。

#### mixin

不同选项有不同的合并策略

混入 (mixins)：在 mixins 文件夹下，可能包含了一些混入（mixins），用于将一些通用的逻辑或功能注入到多个组件中，以实现代码的复用和逻辑的解耦。例如，可以通过混入实现全局的消息提示、权限控制、数据请求等。

##### vue3如何实现类似的复用

直接通过封装函数的方式进行

在 Vue 3 中，可以使用 Composition API 中提供的函数 composables 实现类似 mixin 的复用功能。

具体来说，可以创建一个函数，该函数返回一个对象，对象中包含了一些逻辑代码（例如：数据、计算属性、方法等），然后在组件中通过 setup 函数引入该对象，就可以使用其中的代码了。多个组件都可以引入同一个对象，实现复用的效果。

下面是一个简单的示例：

```javascript
// 创建一个 composable
const myComposable = () => {
  const count = ref(0)
  const increment = () => {
    count.value++
  }
  return { count, increment }
}

// 在组件中引入 composable
export default {
  setup() {
    const { count, increment } = myComposable()
    return { count, increment }
  }
}
```
在上面的示例中，myComposable 函数返回了一个对象，其中包含了一个名为 count 的响应式数据和一个名为 increment 的方法。在组件中通过 myComposable() 函数引入该对象，然后就可以使用其中的代码了。多个组件都可以引入同一个对象，实现代码的复用。

### webpack

#### 优化性能

一些可能的优化方案：

开启多进程/多线程编译：使用工具如 thread-loader 或 happypack 来开启多进程/多线程编译，加快打包速度。

优化构建目标：对于不需要支持的浏览器或平台，可以使用 babel 和 webpack 提供的相关插件或选项进行快速的目标构建。例如，可以通过在 babel.config.js 中配置 targets 来只编译需要支持的浏览器或平台的特性。

使用按需加载：对于一些比较大的组件或库，可以采用按需加载的方式，只在需要使用时再加载相应的代码。例如，在 Vue 2 中可以使用 vue-router 提供的 lazyLoad 方法来实现按需加载。

拆分代码：通过 webpack 提供的代码拆分机制，将组件库中的代码按照功能和用途进行拆分，可以有效地减小打包后的文件大小。

移除无用的代码：使用工具如 babel-plugin-transform-remove-console、webpack 的 uglifyjs-webpack-plugin 等来移除无用的代码，进一步减小打包后的文件大小。

压缩代码：使用 webpack 的 uglifyjs-webpack-plugin 等插件来压缩打包后的代码，减小文件大小。

使用 Tree Shaking：对于使用了 ES6 module 的组件库，可以通过启用 webpack 的 Tree Shaking 机制来消除无用代码，进一步减小打包后的文件大小。

使用 Scope Hoisting：通过启用 webpack 的 Scope Hoisting 机制，将模块之间的依赖关系进行静态分析，并将具有相同作用域的模块合并为一个函数，从而减少打包后代码的体积和函数声明的数量。

缩小依赖范围：通过配置 webpack 的 resolve.alias 或 externals 等选项，缩小组件库对其他模块和库的依赖范围，进一步减小打包后的文件大小。

优化图片资源：对于组件库中使用的图片资源，可以使用工具如 imagemin-webpack-plugin 来对其进行压缩和优化，减小文件大小。

需要注意的是，以上的优化方案并非适用于所有场景，具体的优化策略需要根据具体的组件库和项目进行调整和优化。

### ES6新特性

块级作用域和常量声明：使用 let 和 const 关键字来声明变量，使得变量在块级作用域内有效，从而避免了变量污染和冲突的问题。

箭头函数：使用箭头函数可以简化函数的定义，并且在处理 this 的时候更为方便。

模板字符串：使用反引号来定义字符串，可以方便地插入变量和表达式，并且可以跨行定义字符串。

解构赋值：使用解构赋值可以方便地从数组或对象中提取值，并且可以给变量指定默认值。

对象字面量增强：使用对象字面量增强可以方便地定义对象属性和方法。

类和继承：使用 class 关键字定义类和继承，可以更方便地创建对象和组织代码。

模块化：使用 import 和 export 关键字来导入和导出模块，使得代码更易于组织和重用。

Promise 和异步/await：使用 Promise 对象来处理异步操作，可以更好地控制异步代码的执行顺序和错误处理；使用 async/await 可以更方便地处理异步代码，使得代码更加可读和易于维护。

Generator 函数：使用 function* 定义 Generator 函数，可以迭代生成器的值，从而实现更加高效的异步编程。

Map 和 Set 数据结构：使用 Map 和 Set 数据结构来存储和管理数据，可以更方便地操作数据和避免重复代码。

### ts特性

熟练的前端开发工程师会经常使用 TypeScript 中的以下特性：

类型定义：TypeScript 可以定义变量、函数、类等的类型，让代码具有更好的可读性和健壮性。

接口：接口可以定义对象的类型、方法的参数和返回值等，可以帮助我们更好的约束代码，避免类型错误。

泛型：泛型可以定义可重用的代码模板，可以在不同的类型间复用同一段代码，提高了代码的复用性和灵活性。

枚举：枚举可以定义一些具有特定值的常量，可以提高代码的可读性。

类和继承：TypeScript 可以使用类和继承来实现面向对象编程，可以更好的组织代码。

装饰器：装饰器可以对类、方法、属性等进行注解，可以在代码执行前或后执行一些操作，例如日志记录、性能监测等。

```ts
function log(target: any, name: string, descriptor: PropertyDescriptor) {
  const original = descriptor.value;

  descriptor.value = function(...args: any[]) {
    console.log(`Calling ${name} with args: ${JSON.stringify(args)}`);
    const result = original.apply(this, args);
    console.log(`Result of ${name}: ${JSON.stringify(result)}`);
    return result;
  };

  return descriptor;
}

class MyClass {
  @log
  myMethod(arg1: string, arg2: number): string {
    return `arg1: ${arg1}, arg2: ${arg2}`;
  }
}

const instance = new MyClass();
instance.myMethod('foo', 42); // Calling myMethod with args: ["foo",42], Result of myMethod: "arg1: foo, arg2: 42"
```

log 装饰器接收三个参数：target 表示被装饰的类，name 表示被装饰的方法名，descriptor 表示被装饰的方法的属性描述符。
在装饰器内部，我们首先保存原始方法的引用，然后覆盖属性描述符的 value 属性，以创建一个新的函数。
新的函数包含了我们的日志逻辑，它会在调用原始方法之前和之后打印日志，并返回原始方法的结果。

在类定义中，我们使用 @log 装饰器来修饰 myMethod 方法。这意味着 myMethod 方法在调用时会被 log 函数包装。

使用装饰器实现日志功能可以方便地将日志逻辑与业务逻辑分离，提高代码的可维护性和可读性。同时，它也可以避免在每个函数或方法中编写重复的日志代码，节省开发时间。

元组：元组可以定义一个固定长度的数组，并且数组中每个元素的类型可以不同，可以更好地描述一些复杂的数据结构。

构造函数参数属性：可以在构造函数参数中直接定义类的属性，避免了冗长的代码。

可选属性和参数：可以定义一些可选的属性和参数，使代码更加灵活。

类型别名和联合类型：可以使用类型别名和联合类型定义复杂的类型，提高代码可读性。

# 基础能力

## 计网

### HTTP

https://juejin.cn/post/6844904045572800525

#### 如何实现http性能优化

1. 缓存

一种常见的性能优化技巧，利用浏览器或服务器缓存来减少重复请求，从而提高网页加载速度和性能。

常见的缓存控制方式包括设置 Cache-Control 和 Expires 等响应头来控制缓存行为。
其中 Cache-Control 响应头是HTTP/1.1标准中用来控制缓存的最重要的头部之一，可以设置多个缓存控制指令，比如max-age、no-cache、no-store等，来控制缓存策略。
而 Expires 响应头是HTTP/1.0标准中用来控制缓存的头部之一，表示资源的过期时间，过期后客户端必须重新请求该资源。

cache-control：
no-cache: 强制客户端在使用缓存前重新验证资源的有效性，一般不会从缓存中读取资源，而是通过重新请求来获取资源。
no-store: 禁止缓存，不缓存请求或响应的任何部分。
max-age: 缓存最大有效时间，单位为秒。例如 max-age=3600 表示资源可以被缓存 1 小时。
s-maxage: 与 max-age 类似，但只适用于共享缓存，比如 CDN 缓存，不会被浏览器缓存。一般会设置为较大的值，比如 s-maxage=86400 表示 CDN 缓存 1 天。
public: 允许任何缓存对资源进行缓存，包括客户端和共享缓存，比如 CDN 缓存。
private: 只允许客户端进行缓存，不允许共享缓存，比如 CDN 缓存。一般用于用户隐私数据等敏感资源。
must-revalidate: 缓存必须在使用前经过验证，过期的缓存必须从源服务器重新获取，不能直接使用过期的缓存。
proxy-revalidate: 类似 must-revalidate，但只适用于共享缓存，不适用于客户端缓存。

Expires 是 HTTP/1.0 定义的字段，它的作用是设置缓存资源的过期时间，指定的是一个具体的日期时间，而非一个时间段，例如 Expires: Sat, 01 Jan 2022 00:00:00 GMT，表示该资源会在这个时间之后过期。但是由于 Expires 字段的时间是由服务端返回的，如果服务端的时间与客户端的时间不一致，则可能导致缓存失效的时间不准确，因此在 HTTP/1.1 中引入了 Cache-Control 字段，用于代替 Expires 字段。

Cache-Control: max-age 则是 HTTP/1.1 中引入的字段，它是一个相对时间，在响应头中指定的是一个时间段（秒）而非具体的日期时间，例如 Cache-Control: max-age=3600 表示该资源可以被缓存并在 3600 秒（1 小时）之内有效。使用 Cache-Control: max-age 比 Expires 更为可靠，因为它不受服务端时间和客户端时间不一致的影响，同时也更加灵活，可以用于指定更加复杂的缓存控制策略，例如 Cache-Control: no-cache 表示该资源可以被缓存，但是每次访问都需要向服务端验证缓存是否过期。


2. 压缩

压缩是另一种常见的性能优化技巧，通过压缩 HTTP 请求和响应的数据来减少传输数据量，从而提高网页加载速度和性能。
常见的压缩算法包括gzip、deflate等，这些算法可以将HTTP数据压缩后再发送，以减少传输数据量。

在使用压缩技术时，我们需要在HTTP请求和响应中设置Content-Encoding和Accept-Encoding请求头来指定压缩类型。
其中，Content-Encoding响应头用于告诉客户端返回的数据被压缩了，而Accept-Encoding请求头则用于告诉服务器客户端支持哪些压缩类型。

3. 减少请求次数

当网页需要加载多个资源时，每个资源都需要发起一个请求，而每个请求都需要耗费时间和资源，因此减少请求次数是提高页面加载性能的有效方法。其中，合并多个请求可以通过将多个 CSS 或 JS 文件合并成一个文件，或将多个图片合并成一张雪碧图来实现。
使用 Link 或者 rel 属性来指定资源的依赖关系可以帮助浏览器对多个资源进行并行下载，进而减少页面加载时间。

雪碧图（Sprite）是指将多个小图片拼接成一个大图，然后通过CSS的background-position和background-size属性来显示需要的部分，以减少HTTP请求次数，提高页面性能。常用于Web开发中的图标、按钮等小图片的展示。

使用雪碧图可以减少HTTP请求次数，因为只需要加载一张大图，而不是多张小图。同时，减少HTTP请求次数也可以提高网页的加载速度，从而提高用户的体验。

4. DNS 预解析

DNS 查询也会消耗时间，因此通过预先解析可能需要的域名来减少 DNS 查询的时间是提高页面加载性能的有效方法。可以使用 dns-prefetch 或 preconnect 等预解析技术。例如，以下是使用 dns-prefetch 来预解析百度网站的示例代码：

##### 更多有关请求头

If-None-Match：用于向服务器传递 ETag，询问服务器是否有更新的版本。示例代码：
req.setHeader('If-None-Match', etag);

If-Modified-Since：用于向服务器传递 Last-Modified 时间，询问服务器是否有更新的版本。示例代码：
req.setHeader('If-Modified-Since', lastModified);

Range：用于实现断点续传等功能，可以指定获取资源的某个范围。示例代码：
req.setHeader('Range', 'bytes=0-1023');

User-Agent：用于向服务器传递客户端信息，例如浏览器类型、操作系统等。示例代码：
req.setHeader('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36');

##### 更多有关响应头

ETag：用于标识请求资源的版本号，如果资源未发生变化，服务器会返回 304 Not Modified 状态码，浏览器就可以直接从缓存中获取资源，而不必重新下载。示例代码：
res.setHeader('ETag', etag);

Last-Modified：用于标识资源最后修改的时间，与 ETag 类似，用于判断资源是否需要重新下载。示例代码：
res.setHeader('Last-Modified', lastModified);

#### https

HTTPS是使用安全套接字层(SSL)或传输层安全(TLS)作为常规HTTP应用程序层下的子层。
对用户的HTTP页面请求以及web服务器返回的页面进行加密和解密。 它还可以防止窃听和中间人(MitM)攻击

## css

https://vue3js.cn/interview/css/selector.html

### 选择器优先级

body #abc和#abc

第一个选择器多了一个标签选择器，优先级肯定会更高

### 常用选择器

#### 前后选择器

后代选择器“nav ul”选择器匹配所有属于 nav 元素后代的 ul 元素，不论它们是直接子元素还是更深层次的子元素。

自选择器 “nav > ul”选择器只会匹配作为 nav 直接子元素的 ul 元素。
即nav和ul中间不能有其他元素

相邻同胞选择器（.one+.two），选择紧接在.one之后的所有.two元素

层次选择器（p~ul），选择前面有p元素的每个ul元素

#### 伪类选择器

:link ：选择未被访问的链接
:visited：选取已被访问的链接
:active：选择活动链接
:hover ：鼠标指针浮动在上面的元素
:focus ：选择具有焦点的
:first-child：父元素的首个子元素

css3

:first-of-type 表示一组同级元素中其类型的第一个元素
:last-of-type 表示一组同级元素中其类型的最后一个元素
:only-of-type 表示没有同类型兄弟元素的元素
:only-child 表示没有任何兄弟的元素
:nth-child(n) 根据元素在一组同级中的位置匹配元素
:nth-last-of-type(n) 匹配给定类型的元素，基于它们在一组兄弟元素中的位置，从末尾开始计数
:last-child 表示一组兄弟元素中的最后一个元素
:root 设置HTML文档
:empty 指定空的元素
:enabled 选择可用元素
:disabled 选择被禁用元素
:checked 选择选中的元素
:not(selector) 选择与 \<\selector> 不匹配的所有元素

#### 伪元素选择器

##### after和before

伪类选择器 :after 和 :before 可以在选定元素的内容前面或后面插入生成的内容，常见的用法包括添加样式、清除浮动等。

以下是几个常见的使用示例：

添加样式
可以使用 :after 或 :before 为选定元素添加一些装饰性的内容，如下面的示例将在每个段落后面添加一个装饰性的箭头：

```css
p:after {
  content: "→";
  font-size: 20px;
  color: #ccc;
}
```

清除浮动
可以使用 :after 清除浮动，如下面的示例：

```css
.clearfix:after {
  content: "";
  display: block;
  clear: both;
}
```

实现菜单下划线效果
可以使用 :before 为菜单项添加下划线，如下面的示例：
```css
ul li:before {
  content: "";
  position: absolute;
  bottom: -5px;
  left: 0;
  width: 100%;
  height: 2px;
  background-color: #ccc;
  transform: scaleX(0);
  transition: transform 0.2s ease-in-out;
}

ul li:hover:before {
  transform: scaleX(1);
}
```
上述代码中，:before 伪类用于创建下划线，:hover 伪类用于在鼠标悬停时触发下划线动画。

总的来说，:after 和 :before 可以帮助开发者通过CSS生成一些额外的内容，从而增强页面的交互和视觉效果。


### 预处理器

https://vue3js.cn/interview/css/sass_less_stylus.html

提问预处理器的嵌套css实现后是什么效果（不太会，介绍了vue的样式隔离）

以sass为例：
通过嵌套来简化CSS代码的书写和维护

```css
nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;

    li {
      display: inline-block;
      margin: 0 10px;
      a {
        text-decoration: none;
      }
    }
  }
}
```

Sass会将其编译为普通的CSS选择器，例如上面的代码会被编译为：

```css
nav ul {
  margin: 0;
  padding: 0;
  list-style: none;
}
nav ul li {
  display: inline-block;
  margin: 0 10px;
}
nav ul li a {
  text-decoration: none;
}
```

### 一些属性的使用

#### 控制文本

white-space：控制如何处理空格和换行符。

    normal：默认值，忽略额外的空格和换行符。
    nowrap：不允许文本换行。
    pre：保留额外的空格和换行符。
    pre-wrap：保留额外的空格和换行符，并允许文本换行。
    pre-line：保留额外的空格，允许文本换行，但将忽略换行符。

text-overflow：控制文本溢出的显示方式。

    clip：默认值，裁剪文本，并将溢出的文本隐藏。
    ellipsis：显示省略号，以表示溢出的文本。
    string：显示给定字符串，以表示溢出的文本。

overflow-wrap：控制如何在单词中断时换行。

    normal：默认值，根据需要换行。
    break-word：在单词中断时强制换行。

word-break：控制在哪里中断单词换行。

    normal：默认值，根据需要换行。
    break-all：在单词中断时强制换行。
    keep-all：不允许在空格之间中断单词。

### css3

Flexbox：弹性盒子布局，可以实现更灵活的布局方式。

Grid：网格布局，可以实现复杂的布局方式，支持更多的对齐方式和间距控制。

Animation：动画效果，可以通过CSS实现简单的动画效果。

Transition：过渡效果，可以实现元素在某些状态之间的平滑过渡。

Box-shadow、Text-shadow：盒子阴影和文字阴影效果，可以为元素添加立体感。

Transform：变形效果，可以实现旋转、缩放、倾斜等效果。

Gradient：渐变效果，可以实现背景色的渐变。

Border-radius：边框圆角效果，可以实现元素边角的圆角化。

Filters：滤镜效果，可以为元素添加色彩调整、模糊、饱和度等效果。

除此之外，还有一些CSS3中的新特性，如变量、媒体查询、多列布局等，也是前端开发工程师常用的特性。

#### transform和transition

Transition：过渡效果，可以实现元素在某些状态之间的平滑过渡。

可以对元素状态改变时的变化过程进行设定，例如平滑变化或者突然变化，或者多长时间完成变化

transform可以做到很多种变化

位移（translate）：改变元素的位置。可以用translateX和translateY来分别指定水平和竖直方向的位移。可以结合transition来实现平滑的动画效果。

```css
/* 例子：向右移动50像素 */
.box {
  transform: translateX(50px);
  transition: transform 0.3s ease-out;
}
.box:hover {
  transform: translateX(100px);
}
```
旋转（rotate）：改变元素的方向。可以用rotate来指定旋转角度，单位是度数（deg）。同样可以结合transition来实现动画效果。
```css
/* 例子：顺时针旋转45度 */
.box {
  transform: rotate(45deg);
  transition: transform 0.3s ease-out;
}
.box:hover {
  transform: rotate(90deg);
}
```
缩放（scale）：改变元素的大小。可以用scaleX和scaleY来分别指定水平和竖直方向的缩放比例。同样可以结合transition来实现动画效果。
```css
/* 例子：放大1.5倍 */
.box {
  transform: scale(1.5);
  transition: transform 0.3s ease-out;
}
.box:hover {
  transform: scale(2);
}
```
扭曲（skew）：改变元素的形状。可以用skewX和skewY来分别指定水平和竖直方向的扭曲角度，单位是度数（deg）。
```css
/* 例子：向右扭曲30度 */
.box {
  transform: skewX(30deg);
}
```
透视（perspective）：改变元素在三维空间中的投影效果。可以用perspective来指定透视距离，单位是像素（px）。
```css
/* 例子：添加透视效果 */
.container {
  perspective: 1000px;
}
.box {
  transform: rotateY(45deg);
}
```
以上是一些常见的transform用法，你可以结合transition来实现更加动态、流畅的效果。

#### gradient

可以使用CSS3中的渐变（gradient）来实现渐变效果的蒙版。具体实现可以使用以下样式：
background: linear-gradient(to bottom, rgba(0,0,0,0), rgba(0,0,0,1));
其中，linear-gradient是渐变的类型，to bottom表示从上到下的渐变方向，rgba(0,0,0,0)表示渐变的起始颜色为透明，rgba(0,0,0,1)表示渐变的结束颜色为黑色。这样，就可以实现一个从上到下逐渐变深的蒙版效果。

还可以使用radial-gradient来实现圆形渐变蒙版，如下所示：
background: radial-gradient(circle, rgba(0,0,0,0), rgba(0,0,0,1));
其中，circle表示圆形渐变，rgba(0,0,0,0)表示渐变的起始颜色为透明，rgba(0,0,0,1)表示渐变的结束颜色为黑色。这样，就可以实现一个中心逐渐变深的圆形蒙版效果。

需要注意的是，渐变效果的蒙版并不是所有浏览器都支持，建议在使用时做好兼容性处理。

## js

### dom树操纵

https://vue3js.cn/interview/JavaScript/Dom.html

文档对象模型 (DOM) 是 HTML 和 XML 文档的编程接口

它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容

任何 HTML或XML文档都可以用 DOM表示为一个由节点构成的层级结构

节点分很多类型，每种类型对应着文档中不同的信息和（或）标记，也都有自己不同的特性、数据和方法，而且与其他类型有某种关系

DOM操作才能有助于我们理解框架深层的内容

常见的操作，主要分为：

创建节点
查询节点
更新节点
添加节点
删除节点

每个DOM元素还有parentNode、childNodes、firstChild、lastChild、nextSibling、previousSibling属性

#### 创建节点

createElement
创建新元素，接受一个参数，即要创建元素的标签名
const divEl = document.createElement("div");

createTextNode
创建一个文本节点
const textEl = document.createTextNode("content");

createDocumentFragment
用来创建一个文档碎片，它表示一种轻量级的文档，主要是用来存储临时节点，然后把文档碎片的内容一次性添加到DOM中
const fragment = document.createDocumentFragment();
当请求把一个DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment自身，而是它的所有子孙节点

createAttribute
创建属性节点，可以是自定义属性
const dataAttribute = document.createAttribute('custom');
consle.log(dataAttribute);

#### 获取节点

1. querySelector

    传入任何有效的css 选择器，即可选中单个 DOM元素（首个）：

    document.querySelector('.element')
    document.querySelector('#element')
    document.querySelector('div')
    可以通过任何css选择器来进行，包括属性选择器
    document.querySelector('[name="username"]')
    document.querySelector('div + p > span')
    如果页面上没有指定的元素时，返回 null

2. querySelectorAll

    返回一个包含节点子树内所有与之相匹配的Element节点列表，如果没有相匹配的，则返回一个空节点列表

    const notLive = document.querySelectorAll("p");
    需要注意的是，该方法返回的是一个 NodeList的静态实例，它是一个静态的“快照”，而非“实时”的查询

关于获取DOM元素的方法还有如下，就不一一述说

document.getElementById('id属性值');返回拥有指定id的对象的引用
document.getElementsByClassName('class属性值');返回拥有指定class的对象集合
document.getElementsByTagName('标签名');返回拥有指定标签名的对象集合
document.getElementsByName('name属性值'); 返回拥有指定名称的对象结合
document/element.querySelector('CSS选择器');  仅返回第一个匹配的元素
document/element.querySelectorAll('CSS选择器');   返回所有匹配的元素
document.documentElement;  获取页面中的HTML标签
document.body; 获取页面中的BODY标签
document.all[''];  获取页面中的所有元素节点的对象集合型

##### evaluate方法

document.evaluate() 是一个强大的 DOM API，它允许开发者使用 XPath 表达式在 DOM 中进行搜索。它的语法如下：

```javascript
document.evaluate(xpathExpression, contextNode, namespaceResolver, resultType, result);
```

xpathExpression：一个字符串，包含要搜索的 XPath 表达式。
contextNode：一个节点，表示搜索的起始点。通常为 document。
namespaceResolver：一个函数，用于处理命名空间。通常不需要使用，可以传递 null。
resultType：一个数字，表示要返回的结果类型。默认为 XPathResult.ORDERED_NODE_SNAPSHOT_TYPE。
result：一个对象，用于保存搜索结果。如果传递 null，则会返回一个新的 XPathResult 对象。
document.evaluate() 返回一个 XPathResult 对象，该对象包含符合搜索条件的节点列表。可以通过 XPathResult 对象的属性和方法获取搜索结果，例如 snapshotLength 属性表示结果的数量，snapshotItem() 方法返回结果列表中的某个节点等等。

使用 document.evaluate() 可以灵活地搜索 DOM 中的节点，支持一些高级的搜索功能，比如按照节点类型、属性值、文本内容等进行搜索。不过由于语法比较复杂，一般不适用于简单的 DOM 操作。

##### xpath

一种在XML、HTML等文档中查找信息的语言，它通过元素和属性的层级关系来定位节点。XPath有以下几种基本表达式：

路径表达式：用于从根节点或当前节点开始查找节点，路径表达式可以是绝对路径或相对路径。
绝对路径表达式：以斜杠“/”开头，表示从根节点开始查找节点。例如：/html/body/div/p 表示查找根节点下的html元素，其子元素body，其子元素div，最后查找其子元素p。
相对路径表达式：不以斜杠“/”开头，表示从当前节点开始查找节点。例如：div/p 表示查找当前节点下的div元素，其子元素p。

选择器：用于查找符合条件的元素或属性。
元素选择器：通过元素名称来查找元素，例如：div 表示查找所有的div元素。
属性选择器：通过属性名称和属性值来查找元素，例如：input[type="text"] 表示查找所有type属性为text的input元素。（如果没有路径，则可直接使用这种选择器语法进行选择，即直接）

```js
const elements = document.evaluate('input[type="text"]', document, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
```

谓语：用于进一步筛选节点，谓语表达式必须跟在节点后面，用一对方括号包裹。
位置谓语：用于选择节点的位置，例如：//div[position()=1] 表示查找文档中第一个div元素。
条件谓语：用于选择满足条件的节点，例如：//div[@class="container"] 表示查找所有class属性为container的div元素。（如果有路径了，此时需要规范，增加@）

运算符：用于组合和比较表达式。
算术运算符：加号“+”、“-”、“*”、“div”和“mod”。
比较运算符：等于“=”、“!=”、“<”、“<=”、“>”和“>=”。
逻辑运算符：与“and”、“or”、“not”。

XPath表达式的书写规则如下：
路径表达式必须以斜杠“/”开头。
选择器和谓语表达式必须用方括号“[]”包裹。
每个表达式之间可以使用运算符组合。
表达式可以包含函数调用。
表达式中可以使用通配符“*”和“@”表示任意元素和属性。

例如：//div[@class="container"]/p[position()=1] 表示查找所有class属性为container的div元素下的第一个p元素。

在XPath中不加@，则默认匹配的是节点名称，而非节点的属性。以下是一些例子：
匹配所有的 <p> 元素：//p
匹配当前节点的所有子节点：./*
匹配所有的文本节点：//text()
匹配所有的超链接元素：//a
匹配根节点下的所有元素：/*
注意，在XPath中，属性值需要用 @ 来标识，而如果省略 @，则匹配的是节点名称而非属性值。

一些例子

根据节点类型进行搜索
假设我们想要获取文档中所有的段落标签，可以使用如下代码：

```javascript
const paragraphs = document.evaluate("//p", document, null, XPathResult.ANY_TYPE, null);
```
这里的第一个参数就是我们要查找的节点类型，使用 //p 表示查找所有的段落标签。第二个参数表示搜索的范围，这里是整个文档。第三个参数指定了返回值类型，使用 XPathResult.ANY_TYPE 表示返回所有类型的节点。最后一个参数为命名空间，这里不需要指定。

根据属性值进行搜索
假设我们想要获取文档中所有 data-type 属性为 image 的 div 元素，可以使用如下代码：

```javascript
const divs = document.evaluate("//div[@data-type='image']", document, null, XPathResult.ANY_TYPE, null);
```
这里使用了属性选择器 [@data-type='image']，表示查找所有 data-type 属性值为 image 的 div 元素。

根据文本内容进行搜索
假设我们想要获取文档中所有包含 "Hello World" 文本的节点，可以使用如下代码：

```javascript
const nodes = document.evaluate("//*[contains(text(), 'Hello World')]", document, null, XPathResult.ANY_TYPE, null);
```
这里使用了 contains() 函数来查找包含 "Hello World" 文本的节点。* 表示匹配所有节点类型。

##### 示例

1. 基于dom树获取所有span，多种方法

document.getElementsByTagName('span'): 返回包含所有\<\span>元素的HTMLCollection对象。

document.querySelectorAll('span'): 返回一个包含所有\<\span>元素的NodeList对象。

document.getElementsByTagNameNS('http://www.w3.org/1999/xhtml', 'span'): 返回包含所有\<\span>元素的HTMLCollection对象。
通过命名空间和元素名称获取文档中指定的所有元素，返回一个 HTMLCollection 对象，其中包含所有符合条件的元素。

document.evaluate("//span", document, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null): 使用XPath表达式返回一个包含所有\<\span>元素的XPathResult对象。
返回一个 XPathResult 对象，该对象包含符合搜索条件的节点列表。可以通过 XPathResult 对象的属性和方法获取搜索结果，例如 snapshotLength 属性表示结果的数量，snapshotItem() 方法返回结果列表中的某个节点等等。

2. 获取当前页面所有节点数量

使用document.getElementsByTagName('*')获取页面中的所有DOM节点。这将返回一个包含所有节点的NodeList对象，可以通过获取该对象的长度属性得到节点数量。

使用document.querySelectorAll('*')方法获取页面中的所有DOM节点。该方法会返回一个NodeList对象，可以通过获取该对象的长度属性得到节点数量。

遍历页面中的所有DOM节点，统计节点数量。可以使用递归遍历所有节点的方式来实现。例如，以下代码使用递归方式遍历页面中的所有DOM节点，并统计节点数量
document.documentElement代表HTML文档的根元素，即<html>标签。
遍历方法可能会包括一些不必要的节点，如注释节点、空白文本节点等

3. 获取所有没加载的图片

使用document.images或getElementsByTagName获取所有的图片元素，再遍历这些元素，判断每个元素的complete属性是否为false
一些元素是异步加载的，例如图片（img标签）和脚本（script标签）。当这些元素加载完成后，浏览器会将它们的complete属性设置为true
除了图片元素（img标签）外，脚本元素（script标签）也有complete属性。对于脚本元素，complete属性表示脚本是否已经加载完成并执行。如果脚本加载完成并执行成功，则complete属性为true，否则为false。

使用querySelectorAll选择所有的img元素，再遍历这些元素，判断每个元素的naturalWidth和naturalHeight属性是否为0
表示该元素的本来的宽度和高度，即图片的原始尺寸，如果元素本身就是图片，则这两个属性表示的是图片的宽度和高度。
当图片还没有被完全加载时，width和height属性的值为0，而naturalWidth和naturalHeight属性的值则可以在图片加载之前就能获取到，可以利用这个特性来实现图片预加载等功能。
另外，通过比较naturalWidth和naturalHeight属性与元素实际的width和height属性，可以判断图片是否被缩放或拉伸了，从而做出相应的处理。

query也可以快速实现判断
```js
const completeElements = document.querySelectorAll('img[complete=false]');
```

使用window.getComputedStyle获取所有样式计算结果，再遍历这些结果，判断其中background-image和content属性是否为url链接

#### 更新节点

innerHTML
不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树

```js
// 获取<p id="p">...</p >
var p = document.getElementById('p');
// 设置文本为abc:
p.innerHTML = 'ABC'; // <p id="p">ABC</p >
// 设置HTML:
p.innerHTML = 'ABC <span style="color:red">RED</span> XYZ';
// <p>...</p >的内部结构已修改
```

innerText、textContent
自动对字符串进行HTML编码，保证无法设置任何HTML标签

```js
// 获取<p id="p-id">...</p >
var p = document.getElementById('p-id');
// 设置文本:
p.innerText = '<script>alert("Hi")</script>';
// HTML被自动编码，无法设置一个<script>节点:
// <p id="p-id">&lt;script&gt;alert("Hi")&lt;/script&gt;</p >
```

两者的区别在于读取属性时，innerText不返回隐藏元素的文本，而textContent返回所有文本

style
DOM节点的style属性对应所有的CSS，可以直接获取或设置。遇到-需要转化为驼峰命名

```js
// 获取<p id="p-id">...</p >
const p = document.getElementById('p-id');
// 设置CSS:
p.style.color = '#ff0000';
p.style.fontSize = '20px'; // 驼峰命名
p.style.paddingTop = '2em';
```

#### 添加节点

innerHTML
如果这个DOM节点是空的，例如，\<\div></>，那么，直接使用innerHTML = '\<\span>child</>'就可以修改DOM节点的内容，相当于添加了新的DOM节点

如果这个DOM节点不是空的，那就不能这么做，因为innerHTML会直接替换掉原来的所有子节点

appendChild
把一个子节点添加到父节点的最后一个子节点

举个例子
```html
<!-- HTML结构 -->
<p id="js">JavaScript</p >
<div id="list">
    <p id="java">Java</p >
    <p id="python">Python</p >
    <p id="scheme">Scheme</p >
</div>
```

添加一个p元素
```js
const js = document.getElementById('js')
js.innerHTML = "JavaScript"
const list = document.getElementById('list');
list.appendChild(js);
```

现在HTML结构变成了下面

```html
<!-- HTML结构 -->
<div id="list">
    <p id="java">Java</p >
    <p id="python">Python</p >
    <p id="scheme">Scheme</p >
    <p id="js">JavaScript</p >  <!-- 添加元素 -->
</div>
```
上述代码中，我们是获取DOM元素后再进行添加操作，这个js节点是已经存在当前文档树中，因此这个节点首先会从原先的位置删除，再插入到新的位置

如果动态添加新的节点，则先创建一个新的节点，然后插入到指定的位置
```js
const list = document.getElementById('list'),
const haskell = document.createElement('p');
haskell.id = 'haskell';
haskell.innerText = 'Haskell';
list.appendChild(haskell);
```

insertBefore
把子节点插入到指定的位置，使用方法如下：
```js
parentElement.insertBefore(newElement, referenceElement)
```
子节点会插入到referenceElement之前

setAttribute
在指定元素中添加一个属性节点，如果元素中已有该属性改变属性值
```js
const div = document.getElementById('id')
div.setAttribute('class', 'white');//第一个参数属性名，第二个参数属性值。
```

#### 删除节点

删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的removeChild把自己删掉
```js
// 拿到待删除节点:
const self = document.getElementById('to-be-removed');
// 拿到父节点:
const parent = self.parentElement;
// 删除:
const removed = parent.removeChild(self);
removed === self; // true
```

删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置

### BOM操纵

https://vue3js.cn/interview/JavaScript/BOM.html

BOM (Browser Object Model)，浏览器对象模型，提供了独立于内容与浏览器窗口进行交互的对象

其作用就是跟浏览器做一些交互效果,比如如何进行页面的后退，前进，刷新，浏览器的窗口发生变化，滚动条的滚动，以及获取客户的一些信息如：浏览器品牌版本，屏幕分辨率

浏览器的全部内容可以看成DOM，整个浏览器可以看成BOM

#### window
Bom的核心对象是window，它表示浏览器的一个实例

在浏览器中，window对象有双重角色，即是浏览器窗口的一个接口，又是全局对象

因此所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法

```js
var name = 'js每日一题';
function lookName(){
  alert(this.name);
}

console.log(window.name);  //js每日一题
lookName();                //js每日一题
window.lookName();         //js每日一题
```

关于窗口控制方法如下：

moveBy(x,y)：从当前位置水平移动窗体x个像素，垂直移动窗体y个像素，x为负数，将向左移动窗体，y为负数，将向上移动窗体
moveTo(x,y)：移动窗体左上角到相对于屏幕左上角的(x,y)点
resizeBy(w,h)：相对窗体当前的大小，宽度调整w个像素，高度调整h个像素。如果参数为负值，将缩小窗体，反之扩大窗体
resizeTo(w,h)：把窗体宽度调整为w个像素，高度调整为h个像素
scrollTo(x,y)：如果有滚动条，将横向滚动条移动到相对于窗体宽度为x个像素的位置，将纵向滚动条移动到相对于窗体高度为y个像素的位置
scrollBy(x,y)： 如果有滚动条，将横向滚动条向左移动x个像素，将纵向滚动条向下移动y个像素
window.open() 既可以导航到一个特定的url，也可以打开一个新的浏览器窗口

如果 window.open() 传递了第二个参数，且该参数是已有窗口或者框架的名称，那么就会在目标窗口加载第一个参数指定的URL

window.open('http://www.vue3js.cn','topFrame')
==> < a href=" " target="topFrame"></ a>
window.open() 会返回新窗口的引用，也就是新窗口的 window 对象

const myWin = window.open('http://www.vue3js.cn','myWin')
window.close() 仅用于通过 window.open() 打开的窗口

新创建的 window 对象有一个 opener 属性，该属性指向打开他的原始窗口对象

#### location

url地址如下：

http://foouser:barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents

location属性描述如下：
属性名	例子	说明
hash	"#contents"	utl中#后面的字符，没有则返回空串
host	www.wrox.com:80	服务器名称和端口号
hostname	www.wrox.com	域名，不带端口号
href	http://www.wrox.com:80/WileyCDA/?q=javascript#contents	完整url
pathname	"/WileyCDA/"	服务器下面的文件路径
port	80	url的端口号，没有则为空
protocol	http:	使用的协议
search	?q=javascript	url的查询字符串，通常为？后面的内容
除了 hash之外，只要修改location的一个属性，就会导致页面重新加载新URL

location.reload()，此方法可以重新刷新当前页面。这个方法会根据最有效的方式刷新页面，如果页面自上一次请求以来没有改变过，页面就会从浏览器缓存中重新加载

如果要强制从服务器中重新加载，传递一个参数true即可

#### navigator

navigator 对象主要用来获取浏览器的属性，区分浏览器类型。属性较多，且兼容性比较复杂

#### screen

保存的纯粹是客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息，比如像素宽度和像素高度

#### history

history对象主要用来操作浏览器URL的历史记录，可以通过参数向前，向后，或者向指定URL跳转

常用的属性如下：

history.go()
接收一个整数数字或者字符串参数：向最近的一个记录中包含指定字符串的页面跳转，

history.go('maixaofei.com')
当参数为整数数字的时候，正数表示向前跳转指定的页面，负数为向后跳转指定的页面

history.go(3) //向前跳转三个记录
history.go(-1) //向后跳转一个记录
history.forward()：向前跳转一个页面
history.back()：向后跳转一个页面
history.length：获取历史记录数

# 其他开放性

## 最有成就感项目

第五版在线评测系统

成像快视软件

Alight组件库

## 最困难的问题

评测机卡顿无法评测问题
（多方面调研，评测机项目、mysql、服务器问题、strace追踪）

mysql数据丢失寻找
基于此前的mysqlbin实现操作点的记录
找到发生修改的sql指令，利用工具生成反向代码
利用python刷新脚本，去除荣誉内容

python嵌套数据转h5
涉及到诸多类型判断、类型标记、递归处理、深拷贝问题

## 学习前端的历程

按照怎么接触，17年接触，18年开发小程序后来拿奖，中间找实习锻炼，拼接框架

